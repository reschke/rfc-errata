[
  {
    "errata_id": "2294",
    "doc-id": "RFC0791",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "Page 21",
    "orig_text": "If it is, it inserts its\r\nown internet address as known in the environment into which this\r\ndatagram is being forwarded into the recorded route begining at\r\nthe octet indicated by the pointer, and increments the pointer\r\nby four.",
    "correct_text": "If it is, it inserts its\r\nown internet address as known in the environment into which this\r\ndatagram is being forwarded into the recorded route beginning at\r\nthe octet indicated by the pointer, and increments the pointer\r\nby four.",
    "notes": "s/begining/beginning/g",
    "submit_date": "2010-06-03",
    "submitter_name": "Vishwas Manral",
    "verifier_id": "105",
    "verifier_name": "ron bonica",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2295",
    "doc-id": "RFC0791",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "Page 27",
    "orig_text": "For example, one could implement\r\na fragmentation procedure that repeatly divided large datagrams in\r\nhalf until the resulting fragments were less than the maximum\r\ntransmission unit size.",
    "correct_text": "For example, one could implement\r\na fragmentation procedure that repeatedly divided large datagrams in\r\nhalf until the resulting fragments were less than the maximum\r\ntransmission unit size.",
    "notes": "s/ repeatly/repeatedly/",
    "submit_date": "2010-06-03",
    "submitter_name": "Vishwas Manral",
    "verifier_id": "105",
    "verifier_name": "ron bonica",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2519",
    "doc-id": "RFC0791",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "3.1",
    "orig_text": "Total Length is the length of the datagram, measured in octets,\r\nincluding internet header and data.  ",
    "correct_text": "Total Length is the length of the datagram or fragment, measured in octets,\r\nincluding internet header and data.  ",
    "notes": "Section 2.3 makes it clear that during fragmentation the total length field is corrected to the length of the fragment. Wording such as \"break a datagram into an almost arbitrary number of pieces\" implies that \"datagram\" means the entire original packet. Thus, without the proposed correction, one may be led to believe that the total length contains the length of the original datagram.",
    "submit_date": "2010-09-14",
    "submitter_name": "Yaakov (J) Stein",
    "verifier_id": "105",
    "verifier_name": "ron bonica",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3074",
    "doc-id": "RFC0791",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "3.1 Page 12",
    "orig_text": "Bits   5:  0 = Normal Relibility, 1 = High Relibility.",
    "correct_text": "Bits   5:  0 = Normal Reliability, 1 = High Reliability.",
    "notes": "Spelling error.",
    "submit_date": "2012-01-04",
    "submitter_name": "ChengYan Wang",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3874",
    "doc-id": "RFC0791",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "3",
    "orig_text": "    The number 576 is selected to allow a reasonable sized data block to\r\n    be transmitted in addition to the required header information.  For\r\n    example, this size allows a data block of 512 octets plus 64 header\r\n    octets to fit in a datagram.  The maximal internet header is 60\r\n    octets, and a typical internet header is 20 octets, allowing a\r\n    margin for headers of higher level protocols.",
    "correct_text": "    The number 576 is selected to allow a reasonable sized data block to\r\n    be transmitted in addition to the required header information.  For\r\n    example, this size allows a data block of 516 octets plus 60 header\r\n    octets to fit in a datagram.  The maximal internet header is 60\r\n    octets, and a typical internet header is 20 octets, allowing a\r\n    margin for headers of higher level protocols.",
    "notes": "It is not consistent that it first give an example which illustrates the header is 64 octets, but then explains the maximum header size is 60 octets.\n --VERIFIER NOTES-- \nI believe that the discrepancy you are seeing is because in the one case the text is referring to the set of all headers, and in the other case it's referring to the IP header alone.   The IP header does have a maximum size of 60 octets, but for example an IP header plus a UDP header would be 28 octets, and IP+TCP would be 40 octets, plus a timestamp header in current practice.   Notice the \"for example\" at the beginning of the sentence that mentions 64 header octets.",
    "submit_date": "2014-01-23",
    "submitter_name": "Bo-Jhang Ho",
    "verifier_id": "134",
    "verifier_name": "Ted Lemon",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4126",
    "doc-id": "RFC0791",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "2.3",
    "orig_text": "    If internet datagram marked don't fragment cannot be\r\n    delivered to its destination without fragmenting it, it is to be\r\n    discarded instead.",
    "correct_text": "    If an internet datagram marked don't fragment cannot be\r\n    delivered to its destination without fragmenting it, it is to be\r\n    discarded instead.",
    "notes": "Grammar mistake.",
    "submit_date": "2014-10-04",
    "submitter_name": "Federico do Pino",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4752",
    "doc-id": "RFC0791",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "3.1.",
    "orig_text": "The Option Length is the number of octets \r\nin the option counting the type, length, \r\npointer, and overflow/flag octets (maximum length 40).",
    "correct_text": "The Option Length is the number of octets \r\nin the option counting the type, length, \r\npointer, overflow/flag octets \r\nand timestamp area (maximum length 40).",
    "notes": "The original version implies that the length is only the sum of the constant fields, in this case, 4. This is in conflict with\r\nA) All prior statements that the length is variable\r\nB) The pointer with it >=5 constraint, implies the timestamp area is always full, which is the case when pointer > length\r\nC) Any need to know how much timestamps will follow",
    "submit_date": "2016-07-29",
    "submitter_name": "Markus Klemm",
    "verifier_id": "146",
    "verifier_name": "Terry Manderson",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5037",
    "doc-id": "RFC0791",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "GLOSSARY",
    "orig_text": "NFB\r\n          The Number of Fragment Blocks in a the data portion of an\r\n          internet fragment.  That is, the length of a portion of data\r\n          measured in 8 octet units.",
    "correct_text": "NFB\r\n          The Number of Fragment Blocks in the data portion of an\r\n          internet fragment.  That is, the length of a portion of data\r\n          measured in 8-octet units.",
    "notes": "Extra article 'a' before the term 'data portion of an internet fragment'.",
    "submit_date": "2017-06-10",
    "submitter_name": "Prabhu K Lokesh",
    "verifier_id": "2",
    "verifier_name": "RFC Editor",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5038",
    "doc-id": "RFC0791",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "3.1",
    "orig_text": "The option begins with the option type code.  The second octet\r\n        is the option length which includes the option type code and the\r\n        length octet, the pointer octet, and length-3 octets of route\r\n        data.",
    "correct_text": "The option begins with the option type code.  The second octet\r\n        is the option length, measured in octets, including the option \r\n        type code octet, the length octet, the pointer octet, and the\r\n        octets of route data.",
    "notes": "The way the second octet is defined, although readable to majority of the audience with no concern, will incorrectly equate to:\r\nlength = 'option type code octet' + 'length octet + 'pointer octet' + length - 3 octet of route data\r\n\r\nSo, what is the value of 'length' in 'length - 3'; when reader encounters 'length - 3', the term 'length' itself is not completely defined. Using the term 'length - 3' to define the term 'length' may not be very appropriate. \r\n\r\nFor better readability, we can simply write -\r\nThe second octet is the option length, measured in octets, including the option type code octet, the length octet, the pointer octet, and the octets of route data.\r\n\r\nThe same correction applies to the following sections -\r\n3.1.  Internet Header Format > Loose Source and Record Route\r\n3.1.  Internet Header Format > Strict Source and Record Route\r\n3.1.  Internet Header Format > Record Route\n --VERIFIER NOTES-- \nWhile the text can be simplified as the submitter of the Erratum implies, the current text has been in use for close to 4 decades without any interoperability issues rising out of it. Hence this ",
    "submit_date": "2017-06-10",
    "submitter_name": "Prabhu K Lokesh",
    "verifier_id": "152",
    "verifier_name": "Suresh Krishnan",
    "update_date": "2020-03-25 13:50:22"
  },
  {
    "errata_id": "5679",
    "doc-id": "RFC0791",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "3.1",
    "orig_text": "The time is measured in units of seconds, but since every module that\r\nprocesses a datagram must decrease the TTL by at least one even if it\r\nprocess the datagram in less than a second, the TTL must be thought of\r\nonly as an upper bound on the time a datagram may exist.",
    "correct_text": "The time is measured in units of seconds, but since every module that\r\nprocesses a datagram must decrease the TTL by at least one even if it\r\nprocesses the datagram in less than a second, the TTL must be thought\r\nof only as an upper bound on the time a datagram may exist.",
    "notes": "Grammar mistake (s/process/processes)",
    "submit_date": "2019-03-30",
    "submitter_name": "Greg Skinner",
    "verifier_id": "159",
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "578",
    "doc-id": "RFC0791",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "3.2",
    "orig_text": "Note that this is consistent with the the datagram total length field (of \r\ncourse, the header is counted in the total length and not in the \r\nfragments).",
    "correct_text": "Note that this is consistent with the datagram total length field (of \r\ncourse, the header is counted in the total length and not in the \r\nfragments).\r\n",
    "notes": "",
    "submit_date": "2006-02-18",
    "submitter_name": "Yin Shuming",
    "verifier_id": "105",
    "verifier_name": "ron bonica",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "579",
    "doc-id": "RFC0791",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "On page 21, it says:",
    "orig_text": "The intitial contents of the route data area must be zero.",
    "correct_text": "The initial contents of the route data area must be zero.",
    "notes": "",
    "submit_date": "2004-06-16",
    "submitter_name": "Pavel Uvarov",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "583",
    "doc-id": "RFC0791",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "On page 23, it says:",
    "orig_text": "The intitial contents of the timestamp data area must be zero \r\nor internet address/zero pairs.",
    "correct_text": "The initial contents of the timestamp data area must be zero \r\nor internet address/zero pairs.",
    "notes": "Spelling error.",
    "submit_date": "2004-06-16",
    "submitter_name": "Pavel Uvarov",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "6184",
    "doc-id": "RFC0791",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "3.2",
    "orig_text": "The fragmentation strategy is designed so than an unfragmented datagram\r\nhas all zero fragmentation information",
    "correct_text": "The fragmentation strategy is designed so that an unfragmented datagram\r\nhas all zero fragmentation information",
    "notes": "typo: so than => so that",
    "submit_date": "2020-05-21",
    "submitter_name": "Ye Shu",
    "verifier_id": "2",
    "verifier_name": "Erik Kline",
    "update_date": "2024-12-04 08:56:23"
  },
  {
    "errata_id": "6356",
    "doc-id": "RFC0791",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "3.2",
    "orig_text": "(14) THEN TL <- TDL+(IHL*4)",
    "correct_text": "(14) THEN TL <- TDL+(IHL-Of-First-Fragment*4)",
    "notes": "IHL could be different between the first fragment and the rest. Only the first fragment's IHL is the same as the one in the original datagram before fragmentation\r\n\r\n--- Verifier note ---\r\nUpdated the type of errata to technical from editorial.\r\n\r\nSection 3.2 of RFC 791 clearly states that \"When fragmentation occurs, some options are copied, but others remain with the first fragment only.\" so IHL varies from fragment to fragment. Therefore when copying the IP header of the F=0 fragment (step 11) all options are rightfully copied and must be counted in the re-assembled fragment total length on step 14 as noted by Patrick Ni.",
    "submit_date": "2020-12-15",
    "submitter_name": "Patrick Ni",
    "verifier_id": "161",
    "verifier_name": "Eric Vyncke",
    "update_date": "2021-01-04 00:32:06"
  },
  {
    "errata_id": "6677",
    "doc-id": "RFC0791",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "3.1",
    "orig_text": "Protocol:  8 bits\r\n\r\n    This field indicates the next level protocol used in the data\r\n    portion of the internet datagram.  The values for various protocols\r\n    are specified in \"Assigned Numbers\" [9].",
    "correct_text": "Protocol:  8 bits\r\n\r\n    This field indicates the next upper level protocol used in the data\r\n    portion of the internet datagram.  The values for various protocols\r\n    are specified in \"Assigned Numbers\" [9], section ASSIGNED INTERNET PROTOCOL NUMBERS.",
    "notes": "The word 'next' is ambiguous in the sense that it does not indicate whether the 'next' protocol is at the next LOWER or UPPER level (referring to Fig. 1). Although it may be obvious to people well versed in this domain that the next UPPER level protocol is meant, as a newcomer I had to think twice to reach at this conclusion.\r\n\r\nAlso, the reference to [9] could be more specific.\n --VERIFIER NOTES-- \nThe description of the Protocol field states that it refers to the protocol \"used in the data portion of the internet datagram\".  In the context of Figure 1, this cannot refer to a lower layer protocol.",
    "submit_date": "2021-09-06",
    "submitter_name": "Øyvind Bolme Fredriksen",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2023-06-10 16:49:05"
  },
  {
    "errata_id": "716",
    "doc-id": "RFC0791",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "3.1",
    "orig_text": "        +--------+--------+--------+--------+\r\n        |10001000|00000010|    Stream ID    |\r\n        +--------+--------+--------+--------+\r\n         Type=136 Length=4",
    "correct_text": "        +--------+--------+--------+--------+\r\n        |10001000|00000100|    Stream ID    |\r\n        +--------+--------+--------+--------+\r\n         Type=136 Length=4\r\n\r\nRationale:\r\n\r\nThis number count the length which is 4 and not 2.\r\n10 in binary is 2 in decimal, 100 in binary is 4 in decimal.\r\n\r\nThe option-length octet counts the option-type octet and the \r\noption-length octet as well as the option-data octets.(see page 15)\r\nThe length is 4 for the Stream identifier option as we have 4 bytes and \r\nit is well written in page 16 of RFC 791:\r\n\r\nThe following internet options are defined:\r\n\r\n      CLASS NUMBER LENGTH DESCRIPTION\r\n      ----- ------ ------ -----------\r\n        0     0      -    End of Option list.  This option occupies only\r\n                          1 octet; it has no length octet.\r\n        0     1      -    No Operation.  This option occupies only 1\r\n                          octet; it has no length octet.\r\n        0     2     11    Security.  Used to carry Security,\r\n                          Compartmentation, User Group (TCC), and\r\n                          Handling Restriction Codes compatible with DOD\r\n                          requirements.\r\n        0     3     var.  Loose Source Routing.  Used to route the\r\n                          internet datagram based on information\r\n                          supplied by the source.\r\n        0     9     var.  Strict Source Routing.  Used to route the\r\n                          internet datagram based on information\r\n                          supplied by the source.\r\n        0     7     var.  Record Route.  Used to trace the route an\r\n                          internet datagram takes.\r\n        0     8      4    Stream ID.  Used to carry the stream\r\n                          identifier.\r\n        2     4     var.  Internet Timestamp.",
    "notes": "from pending",
    "submit_date": "2007-01-03",
    "submitter_name": "Damien Mattei",
    "verifier_id": "117",
    "verifier_name": "Ralph Droms",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "7560",
    "doc-id": "RFC0791",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "3.1, Line 904",
    "orig_text": "Bits   5:  0 = Normal Relibility, 1 = High Relibility.",
    "correct_text": "Bits   5:  0 = Normal Reliability, 1 = High Reliability.",
    "notes": "Typo",
    "submit_date": "2023-07-04",
    "submitter_name": "Simon Günther",
    "verifier_id": "2",
    "verifier_name": "RFC Editor",
    "update_date": "2023-07-06 14:51:59"
  },
  {
    "errata_id": "7561",
    "doc-id": "RFC0791",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "3.2",
    "orig_text": "  Identification\r\n\r\n    The choice of the Identifier for a datagram is based on the need to\r\n    provide a way to uniquely identify the fragments of a particular\r\n    datagram.  The protocol module assembling fragments judges fragments\r\n    to belong to the same datagram if they have the same source,\r\n    destination, protocol, and Identifier.  Thus, the sender must choose\r\n    the Identifier to be unique for this source, destination pair and\r\n    protocol for the time the datagram (or any fragment of it) could be\r\n    alive in the internet.\r\n\r\n    It seems then that a sending protocol module needs to keep a table\r\n    of Identifiers, one entry for each destination it has communicated\r\n    with in the last maximum packet lifetime for the internet.\r\n\r\n    However, since the Identifier field allows 65,536 different values,\r\n    some host may be able to simply use unique identifiers independent\r\n    of destination.",
    "correct_text": "  Identification\r\n\r\n    The choice of the Identification for a datagram is based on the need to\r\n    provide a way to uniquely identify the fragments of a particular\r\n    datagram.  The protocol module assembling fragments judges fragments\r\n    to belong to the same datagram if they have the same source,\r\n    destination, protocol, and Identification.  Thus, the sender must choose\r\n    the Identification to be unique for this source, destination pair and\r\n    protocol for the time the datagram (or any fragment of it) could be\r\n    alive in the internet.\r\n\r\n    It seems then that a sending protocol module needs to keep a table\r\n    of Identification values, one entry for each destination it has communicated\r\n    with in the last maximum packet lifetime for the internet.\r\n\r\n    However, since the Identification field allows 65,536 different values,\r\n    some host may be able to simply use unique identifiers independent\r\n    of destination.",
    "notes": "The field is called \"Identification\", and not \"Identifier\" (please note the capitalization in the text).",
    "submit_date": "2023-07-10",
    "submitter_name": "Fernando Gont",
    "verifier_id": "161",
    "verifier_name": "Eric Vyncke",
    "update_date": "2023-08-03 03:56:28"
  }
]
