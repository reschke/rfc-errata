[
  {
    "errata_id": "7272",
    "doc-id": "RFC9171",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "4.2.5.1.1",
    "orig_text": "dtn-hier-part = \"//\" node-name name-delim demux ; a path-rootless\r\n\r\nnode-name = reg-name\r\n\r\ndemux = *VCHAR\r\n",
    "correct_text": "dtn-hier-part = \"//\" node-name name-delim demux [ \"?\" query ]\r\n\r\nnode-name = reg-name\r\n\r\ndemux = path-rootless / path-empty\r\n",
    "notes": "The demux portion of an EID should match only URI path segments and not match query or fragment URI parts. A fragment part should not actually be sent as encoded EID to be consistent with other URI uses (e.g. HTTP). The administrative endpoint is the allowed empty demux path.\r\n\r\n--- see also ---\r\n\r\n* https://mailarchive.ietf.org/arch/msg/dtn/7cdgvvfv7Tg3ivLwCW-UFjgvWsc/",
    "submit_date": "2022-12-12",
    "submitter_name": "Brian Sipos",
    "verifier_id": "2",
    "verifier_name": "Erik Kline",
    "update_date": "2025-08-12 17:08:34"
  },
  {
    "errata_id": "7337",
    "doc-id": "RFC9171",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "Appendix B",
    "orig_text": "   ; Actual CBOR data embedded in a byte string, with optional tag to\r\n   indicate so.\r\n \r\n...\r\n \r\n   ; Extension block type, which does not specialize other than the\r\n   code/number\r\n\r\n...\r\n\r\n   payload-block = payload-block-structure .within canonical-block-\r\n   structure\r\n",
    "correct_text": "   ; Actual CBOR data embedded in a byte string, with optional tag to\r\n   ; indicate so.\r\n\r\n... \r\n \r\n   ; Extension block type, which does not specialize other than the\r\n   ; code/number\r\n\r\n...\r\n\r\n   payload-block = payload-block-structure .within\r\n                   canonical-block-structure\r\n",
    "notes": "Various line breaking events cause syntax errors while parsing Appendix B.\r\n\r\n--- notes ---\r\n\r\nChanged from Technical to Editorial as it seems like this was just a tooling/formatting issue.",
    "submit_date": "2023-02-06",
    "submitter_name": "Carsten Bormann",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2025-08-11 10:38:32"
  },
  {
    "errata_id": "7881",
    "doc-id": "RFC9171",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "6.1.1",
    "orig_text": "   The first element of each bundle status item SHALL be a status\r\n   indicator, a Boolean value indicating whether or not the\r\n   corresponding bundle status is asserted, encoded as a CBOR Boolean\r\n   value.",
    "correct_text": "   The first element of each bundle status item SHALL be a status\r\n   indicator, a Boolean value indicating whether or not the\r\n   corresponding bundle status is asserted, encoded as a CBOR simple\r\n   value.  A value of 'true' SHALL be encoded as a CBOR simple value\r\n   with additional information 21.  A value of 'false' SHALL be encoded\r\n   as a CBOR simple value with additional information 20.",
    "notes": "The CBOR spec does not define a 'Boolean' type (RFC8949). It's become common practice to encode boolean values as simple values (major type 7), with additional information 21 indicating 'true' and additional information 20 indicating 'false' (RFC9254, RFC8152). However, this should be explicitly stated for clarity.\r\n\r\n--- comments ---\r\n\r\nThe original text refers to \"Boolean values\" and not to any \"Boolean type\"; it is technically correct as is.\r\n\r\nAs noted, CBOR doesn't have a specific \"type\" per se for a Boolean, but RFC 8948 S3.3 clearly specifies an encoding for `true` and `false`.\r\n\r\nThat said, there might be room here for additional clarity for implementers if there is ever to be a 9171bis.",
    "submit_date": "2024-04-03",
    "submitter_name": "John Huff",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2024-04-07 16:12:46"
  },
  {
    "errata_id": "8043",
    "doc-id": "RFC9171",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.3.1",
    "orig_text": "   CRC:  A CRC SHALL be present in the primary block unless the bundle\r\n      includes a BPSec Block Integrity Block [BPSEC] whose target is the\r\n      primary block, in which case a CRC MAY be present in the primary\r\n      block.  The length and nature of the CRC SHALL be as indicated by\r\n      the CRC type.  The CRC SHALL be computed over the concatenation of\r\n      all bytes (including CBOR \"break\" characters) of the primary block\r\n      including the CRC field itself, which, for this purpose, SHALL be\r\n      temporarily populated with all bytes set to zero.",
    "correct_text": "   CRC:  A CRC SHALL be present in the primary block unless the bundle\r\n      includes a BPSec Block Integrity Block [BPSEC] whose target is the\r\n      primary block, in which case a CRC MAY be present in the primary\r\n      block.  The length and nature of the CRC SHALL be as indicated by\r\n      the CRC type.  The CRC SHALL be computed over the concatenation of\r\n      all bytes (including CBOR \"break\" characters) of the primary block\r\n      including the CRC field itself, which, for this purpose, SHALL be\r\n      temporarily populated with all value bytes set to zero. The\r\n      initial byte of the CBOR encoded CRC field SHALL remain unchanged.",
    "notes": "There was some confusion about the wording of \"temporarily populated with all bytes set to zero\" when talking about the CRC field in the CBOR encoded primary block. An implementer thought this might mean to also zeroize the intial byte(s) of the CBOR encoded byte string that represents the CRC field. This correction makes it clear that only the bytes that represent the value of the CRC field should be zeroized when calculating the CRC.\r\n\r\nMy correction uses \"initial byte\" because the current CRC types will only ever have a single intial byte when encoding the CRC value as a CBOR byte string. However, technically CBOR byte strings can byte more than 1 initial byte so it may be better to use \"initial byte(s)\".\r\n\r\n--- see also ---\r\n\r\n* https://mailarchive.ietf.org/arch/msg/dtn/3JAFDy9xJXIZNOItbnoqXkjlons/",
    "submit_date": "2024-07-22",
    "submitter_name": "John Huff",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2025-08-10 17:09:13"
  },
  {
    "errata_id": "8376",
    "doc-id": "RFC9171",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "5.8",
    "orig_text": "If the fragmented bundle is not a fragment or is the fragment with\r\noffset zero, then all extension blocks of the fragmented bundle \r\nMUST be replicated in the fragment whose offset is zero.",
    "correct_text": "All extension blocks of the fragmented bundle MUST be represented \r\nin at least one fragment.",
    "notes": "Requiring that the \"first fragment\" of a bundle contain every extension block of the fragmented bundle can lead to situations where the \"first fragment\" bundle is, itself, larger than some reasonable MTU.\r\n\r\nMore generally, more thought needs to be put into the way in which extension blocks from the fragmented bundle are placed into bundles representing fragments.  This is particularly an issue if the bundle holding the fragment will also have extension blocks added to it, as there is no evident way to distinguish between extension blocks in a bundle holding a fragment that were part of the fragmented bundle versus extension blocks in a bundle holding a fragment that are not associated with the fragmented bundle.\r\n\r\n--- AD notes ---\r\n\r\nRFC 9171 ADU Fragmentation has issues with extension blocks and fragmented bundle size.  It requires a thorough and consistent update via a separate document (too large for an erratum).\r\n\r\nFor more context see:\r\n    * https://mailarchive.ietf.org/arch/msg/dtn/2lY2RE_onIXCbO-IAPdylsf819s/\r\n    * other discussion ongoing on the mailing list",
    "submit_date": "2025-04-07",
    "submitter_name": "Ed Birrane",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2025-08-11 10:33:27"
  },
  {
    "errata_id": "8377",
    "doc-id": "RFC9171",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "5.7",
    "orig_text": "If the received bundle is a fragment, the ADU \r\nReassembly procedure described in Section 5.9 MUST \r\nbe followed. If this procedure results in reassembly \r\nof the entire original ADU, processing of the \r\nfragmentary bundle whose payload has been replaced \r\nby the reassembled ADU (whether this bundle or a \r\npreviously received fragment) proceeds from Step 2; ",
    "correct_text": "If the received bundle is a fragment, the ADU \r\nReassembly procedure described in Section 5.9 MUST \r\nbe followed. If this procedure results in reassembly \r\nof the entire original ADU, \r\n\r\nthen the original primary block of the fragmented \r\nbundle whose ADU has been reassembled must replace \r\nthe primary block of the fragmentary bundle whose\r\npayload has been replaced by the reassembled ADU.\r\n\r\nProcessing of this fragmentary bundle proceeds \r\nfrom Step 2; ",
    "notes": "When performing bundle fragmentation, the original bundle is never fully reconstituted because the original bundle primary block is never recreated upon reassembly.  This means that any extension blocks that require the original bundle primary block to be intact (such as security blocks) cannot verify the reassembled bundle.\r\n\r\nA solution to bundle reassembly that allows for the original bundle to be secured and then verified/decrypted upon reassembly needs to be put in place as the text in 9171 currently cannot support this.\r\n\r\n--- AD notes ---\r\n\r\nRFC 9171 ADU Fragmentation has issues with extension blocks and fragmented bundle size.  It requires a thorough and consistent update via a separate document (too large for an erratum).\r\n\r\nFor more context see:\r\n    * https://mailarchive.ietf.org/arch/msg/dtn/2lY2RE_onIXCbO-IAPdylsf819s/\r\n    * other discussion ongoing on the mailing list",
    "submit_date": "2025-04-07",
    "submitter_name": "Ed Birrane",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2025-08-11 10:35:57"
  },
  {
    "errata_id": "8495",
    "doc-id": "RFC9171",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "5.2",
    "orig_text": "Step 2:\r\nProcessing proceeds from Step 1 of Section 5.4.\r\n",
    "correct_text": "Step 2:\r\nProcessing proceeds from Step 1 of Section 5.3.\r\n",
    "notes": "The original text requires bundles transmitted from local endpoints to pass through the forwarding process even if the destination EID is registered by a local application and is expected to result in delivery. This can result in logical confusion for a BPA, because it might be forwarding-to-self which is specifically disallowed in other sections.\r\n\r\nThe corrected text proceeds to the disposition process which allows transmitted bundles to be delivered locally, as necessary, just the same as received bundles. This avoids possible forwarding-to-self confusion and allows for efficient local-to-local delivery.\r\n\r\n--- see also ---\r\n\r\n* https://mailarchive.ietf.org/arch/msg/dtn/2hea7LjMlr0CQ6VIR2qhfXq6UiU/\n --VERIFIER NOTES-- \n   See discussion in: https://mailarchive.ietf.org/arch/msg/dtn/2hea7LjMlr0CQ6VIR2qhfXq6UiU/",
    "submit_date": "2025-07-02",
    "submitter_name": "Brian Sipos",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2025-08-10 17:12:27"
  },
  {
    "errata_id": "8525",
    "doc-id": "RFC9171",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "6.1.1",
    "orig_text": "as described in Section 4.2.5.1.1.",
    "correct_text": "as described in Section 4.2.5.1.1. or Section 4.2.5.1.2.\r\n\r\n--- or ---\r\n\r\nas described in Section 4.2.5.1 and its subsections.\r\n",
    "notes": "Node IDs may be expressed using either the dtn or ipn URI scheme. The original sentence could be mistakenly read as allowing only the dtn scheme for the source node ID in a Bundle Status Report. The revised wording clarifies that both schemes—dtn (Section 4.2.5.1.1) and ipn (Section 4.2.5.1.2)—are valid, keeping this requirement consistent with the rest of the specification.",
    "submit_date": "2025-08-05",
    "submitter_name": "Huiung Park",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2025-08-10 16:51:54"
  }
]
