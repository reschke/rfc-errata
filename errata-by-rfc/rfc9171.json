[
  {
    "errata_id": "7272",
    "doc-id": "RFC9171",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.2.5.1.1",
    "orig_text": "dtn-hier-part = \"//\" node-name name-delim demux ; a path-rootless\r\n\r\nnode-name = reg-name\r\n\r\ndemux = *VCHAR\r\n",
    "correct_text": "dtn-hier-part = \"//\" node-name name-delim demux [ \"?\" query ]\r\n\r\nnode-name = reg-name\r\n\r\ndemux = path-rootless / path-empty\r\n",
    "notes": "The demux portion of an EID should match only URI path segments and not match query or fragment URI parts. A fragment part should not actually be sent as encoded EID to be consistent with other URI uses (e.g. HTTP). The administrative endpoint is the allowed empty demux path.",
    "submit_date": "2022-12-12",
    "submitter_name": "Brian Sipos",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7337",
    "doc-id": "RFC9171",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "Appendix B",
    "orig_text": "   ; Actual CBOR data embedded in a byte string, with optional tag to\r\n   indicate so.\r\n \r\n...\r\n \r\n   ; Extension block type, which does not specialize other than the\r\n   code/number\r\n\r\n...\r\n\r\n   payload-block = payload-block-structure .within canonical-block-\r\n   structure\r\n",
    "correct_text": "   ; Actual CBOR data embedded in a byte string, with optional tag to\r\n   ; indicate so.\r\n\r\n... \r\n \r\n   ; Extension block type, which does not specialize other than the\r\n   ; code/number\r\n\r\n...\r\n\r\n   payload-block = payload-block-structure .within\r\n                   canonical-block-structure\r\n",
    "notes": "Various line breaking events cause syntax errors while parsing Appendix B.",
    "submit_date": "2023-02-06",
    "submitter_name": "Carsten Bormann",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7881",
    "doc-id": "RFC9171",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "6.1.1",
    "orig_text": "   The first element of each bundle status item SHALL be a status\r\n   indicator, a Boolean value indicating whether or not the\r\n   corresponding bundle status is asserted, encoded as a CBOR Boolean\r\n   value.",
    "correct_text": "   The first element of each bundle status item SHALL be a status\r\n   indicator, a Boolean value indicating whether or not the\r\n   corresponding bundle status is asserted, encoded as a CBOR simple\r\n   value.  A value of 'true' SHALL be encoded as a CBOR simple value\r\n   with additional information 21.  A value of 'false' SHALL be encoded\r\n   as a CBOR simple value with additional information 20.",
    "notes": "The CBOR spec does not define a 'Boolean' type (RFC8949). It's become common practice to encode boolean values as simple values (major type 7), with additional information 21 indicating 'true' and additional information 20 indicating 'false' (RFC9254, RFC8152). However, this should be explicitly stated for clarity.\r\n\r\n--- comments ---\r\n\r\nThe original text refers to \"Boolean values\" and not to any \"Boolean type\"; it is technically correct as is.\r\n\r\nAs noted, CBOR doesn't have a specific \"type\" per se for a Boolean, but RFC 8948 S3.3 clearly specifies an encoding for `true` and `false`.\r\n\r\nThat said, there might be room here for additional clarity for implementers if there is ever to be a 9171bis.",
    "submit_date": "2024-04-03",
    "submitter_name": "John Huff",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2024-04-07 16:12:46"
  },
  {
    "errata_id": "8043",
    "doc-id": "RFC9171",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.3.1",
    "orig_text": "   CRC:  A CRC SHALL be present in the primary block unless the bundle\r\n      includes a BPSec Block Integrity Block [BPSEC] whose target is the\r\n      primary block, in which case a CRC MAY be present in the primary\r\n      block.  The length and nature of the CRC SHALL be as indicated by\r\n      the CRC type.  The CRC SHALL be computed over the concatenation of\r\n      all bytes (including CBOR \"break\" characters) of the primary block\r\n      including the CRC field itself, which, for this purpose, SHALL be\r\n      temporarily populated with all bytes set to zero.",
    "correct_text": "   CRC:  A CRC SHALL be present in the primary block unless the bundle\r\n      includes a BPSec Block Integrity Block [BPSEC] whose target is the\r\n      primary block, in which case a CRC MAY be present in the primary\r\n      block.  The length and nature of the CRC SHALL be as indicated by\r\n      the CRC type.  The CRC SHALL be computed over the concatenation of\r\n      all bytes (including CBOR \"break\" characters) of the primary block\r\n      including the CRC field itself, which, for this purpose, SHALL be\r\n      temporarily populated with all value bytes set to zero. The\r\n      initial byte of the CBOR encoded CRC field SHALL remain unchanged.",
    "notes": "There was some confusion about the wording of \"temporarily populated with all bytes set to zero\" when talking about the CRC field in the CBOR encoded primary block. An implementer thought this might mean to also zeroize the intial byte(s) of the CBOR encoded byte string that represents the CRC field. This correction makes it clear that only the bytes that represent the value of the CRC field should be zeroized when calculating the CRC.\r\n\r\nMy correction uses \"initial byte\" because the current CRC types will only ever have a single intial byte when encoding the CRC value as a CBOR byte string. However, technically CBOR byte strings can byte more than 1 initial byte so it may be better to use \"initial byte(s)\".",
    "submit_date": "2024-07-22",
    "submitter_name": "John Huff",
    "verifier_id": "2",
    "verifier_name": null,
    "update_date": "2024-07-25 10:59:40"
  },
  {
    "errata_id": "8376",
    "doc-id": "RFC9171",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "5.8",
    "orig_text": "If the fragmented bundle is not a fragment or is the fragment with\r\noffset zero, then all extension blocks of the fragmented bundle \r\nMUST be replicated in the fragment whose offset is zero.",
    "correct_text": "All extension blocks of the fragmented bundle MUST be represented \r\nin at least one fragment.",
    "notes": "Requiring that the \"first fragment\" of a bundle contain every extension block of the fragmented bundle can lead to situations where the \"first fragment\" bundle is, itself, larger than some reasonable MTU.\r\n\r\nMore generally, more thought needs to be put into the way in which extension blocks from the fragmented bundle are placed into bundles representing fragments.  This is particularly an issue if the bundle holding the fragment will also have extension blocks added to it, as there is no evident way to distinguish between extension blocks in a bundle holding a fragment that were part of the fragmented bundle versus extension blocks in a bundle holding a fragment that are not associated with the fragmented bundle.",
    "submit_date": "2025-04-07",
    "submitter_name": "Ed Birrane",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "8377",
    "doc-id": "RFC9171",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "5.7",
    "orig_text": "If the received bundle is a fragment, the ADU \r\nReassembly procedure described in Section 5.9 MUST \r\nbe followed. If this procedure results in reassembly \r\nof the entire original ADU, processing of the \r\nfragmentary bundle whose payload has been replaced \r\nby the reassembled ADU (whether this bundle or a \r\npreviously received fragment) proceeds from Step 2; ",
    "correct_text": "If the received bundle is a fragment, the ADU \r\nReassembly procedure described in Section 5.9 MUST \r\nbe followed. If this procedure results in reassembly \r\nof the entire original ADU, \r\n\r\nthen the original primary block of the fragmented \r\nbundle whose ADU has been reassembled must replace \r\nthe primary block of the fragmentary bundle whose\r\npayload has been replaced by the reassembled ADU.\r\n\r\nProcessing of this fragmentary bundle proceeds \r\nfrom Step 2; ",
    "notes": "When performing bundle fragmentation, the original bundle is never fully reconstituted because the original bundle primary block is never recreated upon reassembly.  This means that any extension blocks that require the original bundle primary block to be intact (such as security blocks) cannot verify the reassembled bundle.\r\n\r\nA solution to bundle reassembly that allows for the original bundle to be secured and then verified/decrypted upon reassembly needs to be put in place as the text in 9171 currently cannot support this.",
    "submit_date": "2025-04-07",
    "submitter_name": "Ed Birrane",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  }
]
