[
  {
    "errata_id": "7277",
    "doc-id": "RFC9204",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "Appendix A",
    "orig_text": "In the static table, entry 73 has a value of:\r\n\r\naccess-control-allow-credentials: TRUE\r\n\r\nand entry 74 has a value of:\r\n\r\naccess-control-allow-credentials: FALSE",
    "correct_text": "Entry 73 should have a value of:\r\n\r\naccess-control-allow-credentials: true\r\n\r\n(note the lower-case value of \"true\")\r\n\r\nand entry 74 should NOT EXIST since \"FALSE\" (in upper-case\r\nor lower-case) is not a valid value for this header.",
    "notes": "The \"access-control-allow-credentials\" header is a CORS header. It only has one allowed value - \"true\" (without quotes, MUST be in lower-case). Values of \"TRUE\", \"FALSE\" and \"false\" are all invalid values, as is any mixed-case version of \"true\".\r\n\r\nSee the latest WHATWG spec at https://fetch.spec.whatwg.org/#cors-protocol-and-credentials which notes the required case-sensitivity of the \"true\" value and that it is the only valid value.\r\n\r\nAlso see the prior W3C spec at https://www.w3.org/TR/2020/SPSD-cors-20200602/#access-control-allow-credentials-response-header which says the same thing. Note that the W3C spec was superseded by the WHATWG spec.\r\n\r\nNote that there are many instances of \"access-control-allow-credentials: false\" being returned from server responses (which is presumably why these values were added to the table), but they are invalid and the servers that send them are not following the CORS specification.\r\n\r\nThere may be case to be made that the static table is defined to make the QPACK algorithm as performant as possible and therefore it should include not only commonly-used valid values, but also commonly-used invalid values. However, the static table should ideally contain only valid header values.\r\n\r\n-- Verifier notes\r\nSee https://mailarchive.ietf.org/arch/msg/quic/tgmjRvHDPev-mjPQWEM_zqRn5LE/",
    "submit_date": "2022-12-15",
    "submitter_name": "Rory Hewitt",
    "verifier_id": "170",
    "verifier_name": "Francesca Palombini",
    "update_date": "2024-01-30 06:27:48"
  },
  {
    "errata_id": "8410",
    "doc-id": "RFC9204",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "Appendix C",
    "orig_text": "base = dynamicTable.getInsertCount()\r\nrequiredInsertCount = 0\r\nfor line in fieldLines:\r\n  staticIndex = staticTable.findIndex(line)\r\n  if staticIndex is not None:\r\n    encodeStaticIndexReference(streamBuffer, staticIndex)\r\n    continue\r\n\r\n  dynamicIndex = dynamicTable.findIndex(line)\r\n  if dynamicIndex is None:\r\n    # No matching entry.  Either insert+index or encode literal\r\n    staticNameIndex = staticTable.findName(line.name)\r\n    if staticNameIndex is None:\r\n       dynamicNameIndex = dynamicTable.findName(line.name)\r\n\r\n    if shouldIndex(line) and dynamicTable.canIndex(line):\r\n      encodeInsert(encoderBuffer, staticNameIndex,\r\n                   dynamicNameIndex, line)\r\n      dynamicIndex = dynamicTable.add(line)\r\n\r\n  if dynamicIndex is None:\r\n    # Could not index it, literal\r\n    if dynamicNameIndex is not None:\r\n      # Encode literal with dynamic name, possibly above Base\r\n      encodeDynamicLiteral(streamBuffer, dynamicNameIndex,\r\n                           base, line)\r\n      requiredInsertCount = max(requiredInsertCount,\r\n                                dynamicNameIndex)\r\n    else:\r\n      # Encodes a literal with a static name or literal name\r\n      encodeLiteral(streamBuffer, staticNameIndex, line)\r\n  else:\r\n    # Dynamic index reference\r\n    assert(dynamicIndex is not None)\r\n    requiredInsertCount = max(requiredInsertCount, dynamicIndex)\r\n    # Encode dynamicIndex, possibly above Base\r\n    encodeDynamicIndexReference(streamBuffer, dynamicIndex, base)\r\n\r\n# encode the prefix\r\nif requiredInsertCount == 0:\r\n  encodeInteger(prefixBuffer, 0x00, 0, 8)\r\n  encodeInteger(prefixBuffer, 0x00, 0, 7)\r\nelse:\r\n  wireRIC = (\r\n    requiredInsertCount\r\n    % (2 * getMaxEntries(maxTableCapacity))\r\n  ) + 1;\r\n  encodeInteger(prefixBuffer, 0x00, wireRIC, 8)\r\n  if base >= requiredInsertCount:\r\n    encodeInteger(prefixBuffer, 0x00,\r\n                  base - requiredInsertCount, 7)\r\n  else:\r\n    encodeInteger(prefixBuffer, 0x80,\r\n                  requiredInsertCount - base - 1, 7)\r\n\r\nreturn encoderBuffer, prefixBuffer + streamBuffer",
    "correct_text": "base = dynamicTable.getInsertCount()\r\nrequiredInsertCount = 0\r\nfor line in fieldLines:\r\n  staticIndex = staticTable.findIndex(line)\r\n  if staticIndex is not None:\r\n    encodeStaticIndexReference(streamBuffer, staticIndex)\r\n    continue\r\n\r\n  dynamicIndex = dynamicTable.findIndex(line)\r\n  if dynamicIndex is None:\r\n    # No matching entry.  Either insert+index or encode literal\r\n    staticNameIndex = staticTable.findName(line.name)\r\n    if staticNameIndex is None:\r\n       dynamicNameIndex = dynamicTable.findName(line.name)\r\n\r\n    if shouldIndex(line) and dynamicTable.canIndex(line):\r\n      encodeInsert(encoderBuffer, staticNameIndex,\r\n                   dynamicNameIndex, line)\r\n      dynamicIndex = dynamicTable.add(line)\r\n\r\n  if dynamicIndex is None:\r\n    # Could not index it, literal\r\n    if dynamicNameIndex is not None:\r\n      # Encode literal with dynamic name, possibly above Base\r\n      encodeDynamicLiteral(streamBuffer, dynamicNameIndex,\r\n                           base, line)\r\n      requiredInsertCount = max(requiredInsertCount,\r\n                                dynamicNameIndex + 1)\r\n    else:\r\n      # Encodes a literal with a static name or literal name\r\n      encodeLiteral(streamBuffer, staticNameIndex, line)\r\n  else:\r\n    # Dynamic index reference\r\n    assert(dynamicIndex is not None)\r\n    requiredInsertCount = max(requiredInsertCount, dynamicIndex + 1)\r\n    # Encode dynamicIndex, possibly above Base\r\n    encodeDynamicIndexReference(streamBuffer, dynamicIndex, base)\r\n\r\n# encode the prefix\r\nif requiredInsertCount == 0:\r\n  encodeInteger(prefixBuffer, 0x00, 0, 8)\r\n  encodeInteger(prefixBuffer, 0x00, 0, 7)\r\nelse:\r\n  wireRIC = (\r\n    requiredInsertCount\r\n    % (2 * getMaxEntries(maxTableCapacity))\r\n  ) + 1;\r\n  encodeInteger(prefixBuffer, 0x00, wireRIC, 8)\r\n  if base >= requiredInsertCount:\r\n    encodeInteger(prefixBuffer, 0x00,\r\n                  base - requiredInsertCount, 7)\r\n  else:\r\n    encodeInteger(prefixBuffer, 0x80,\r\n                  requiredInsertCount - base - 1, 7)\r\n\r\nreturn encoderBuffer, prefixBuffer + streamBuffer\r\n",
    "notes": "\"Sample Single-Pass Encoding Algorithm\" in Appendix C has a bug that Count is equel to the index. Count must be one higher than index.\r\n\r\nReasoning the code:\r\n\r\nrequiredInsertCount is initialized with 0:\r\n\r\n    requiredInsertCount = 0\r\n\r\ndynamicIndex can be 0 if it is the first entry of the dynamic table:\r\n\r\n    dynamicIndex = dynamicTable.findIndex(line)\r\n\r\nIn this case, requiredInsertCount stay with 0:\r\n\r\n   requiredInsertCount = max(requiredInsertCount, dynamicIndex)\r\n\r\nThis results in a wrong prefix:\r\n\r\n    if requiredInsertCount == 0:\r\n      encodeInteger(prefixBuffer, 0x00, 0, 8)\r\n      encodeInteger(prefixBuffer, 0x00, 0, 7)\r\n\r\nThe following code is correct:\r\n\r\n    requiredInsertCount = max(requiredInsertCount, dynamicIndex + 1)",
    "submit_date": "2025-05-08",
    "submitter_name": "Kazu Yamamoto",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  }
]
