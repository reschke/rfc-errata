[
  {
    "errata_id": "2794",
    "doc-id": "RFC2104",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "Appendix",
    "orig_text": "  key =         \"Jefe\"\r\n  data =        \"what do ya want for nothing?\"\r\n  data_len =    28 bytes\r\n  digest =      0x750c783e6ab0b503eaa86e310a5db738",
    "correct_text": "  key =         \"Jefe\"\r\n  key_len =     4\r\n  data =        \"what do ya want for nothing?\"\r\n  data_len =    28 bytes\r\n  digest =      0x750c783e6ab0b503eaa86e310a5db738",
    "notes": "key_len was omitted from this test vector. The other test vectors specify both key_len and data_len.",
    "submit_date": "2011-05-02",
    "submitter_name": "Kasper Dupont",
    "verifier_id": "124",
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3694",
    "doc-id": "RFC2104",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "References",
    "orig_text": "\"Keyed Hash Functions and Message Authentication\"",
    "correct_text": "\"Keying Hash Functions for Message Authentication\"",
    "notes": "This is reference [BCK1]. It is also no longer directly available at the advertised URL, though can be found on that site. Alternatively it is easily available elsewhere, by searching with the quoted corrected title (which is why this erratum may help).",
    "submit_date": "2013-08-14",
    "submitter_name": "Christopher Dearlove",
    "verifier_id": "124",
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4459",
    "doc-id": "RFC2104",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "Appendix",
    "orig_text": "        /* start out by storing key in pads */\r\n        bzero( k_ipad, sizeof k_ipad);\r\n        bzero( k_opad, sizeof k_opad);\r\n        bcopy( key, k_ipad, key_len);\r\n        bcopy( key, k_opad, key_len);\r\n\r\n        /* XOR key with ipad and opad values */\r\n        for (i=0; i<64; i++) {\r\n                k_ipad[i] ^= 0x36;\r\n                k_opad[i] ^= 0x5c;\r\n        }",
    "correct_text": "        /* start out by storing key in pads */\r\n        bzero( k_ipad, sizeof k_ipad);\r\n        bzero( k_opad, sizeof k_opad);\r\n        bcopy( k_ipad, key, key_len);\r\n        bcopy( k_opad, key, key_len);\r\n\r\n        /* XOR key with ipad and opad values */\r\n        for (i=0; i<64; i++) {\r\n                k_ipad[i] ^= 0x36;\r\n                k_opad[i] ^= 0x5c;\r\n        }",
    "notes": "The ipad = the byte 0x36 repeated 64 times, opad = the type 0x5C repeated B times and then ipad and opad XOR K after it appended to 64 byptes.\n --VERIFIER NOTES-- \n\r\nThe net effect of the suggested change would be to zero the key \r\nand make HMAC useless.",
    "submit_date": "2015-08-27",
    "submitter_name": "Bozhi ZHENG",
    "verifier_id": "128",
    "verifier_name": "Stephen Farrell",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4809",
    "doc-id": "RFC2104",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "2",
    "orig_text": "Applications that use keys longer\r\n   than B bytes will first hash the key using H and then use the\r\n   resultant L byte string as the actual key to HMAC.",
    "correct_text": "Applications MUST not use keys longer than B bytes.",
    "notes": "Using this approach creates an exploitable vulnerability where there are two known K instances, one the hashed key, and the other the key itself.  As shown in the sample Java code below:\r\n\r\n    final byte[] keyBytes = KEY.getBytes();\r\n    final byte[] sha1 = HashUtil.sha1(keyBytes);\r\n    final String a = hmac_sha1(keyBytes, TEXT);\r\n    final String b = hmac_sha1(sha1, TEXT);\r\n\r\nAs demonstrated a equals b.  To cite a real world vulnerability; for all keys longer than B, using password storage configurations which store the hash of the key for integrity checks, and store the key itself in a tamper proof device, there will exist plain text keys stored on both storage systems.  Compromising a hash database should not reveal plain text secrets, which will only be true if an implementation first hashes the key and uses the resultant L byte string as the actual key to HMAC.\r\n\r\nI suggest simply not allowing keys longer than B bytes, which will greatly improve the security of the standard.\r\n\r\nVerifier notes: I started a thread [1] on the CFRG mailing list to discuss this. My reading of that thread leads me to conclude there there's consensus to not verify the erratum on the basis that the threat isn't that significant and a backwards incompatible change as would be required is not justified. However, if HMAC were to be updated in a manner that didn't require backwards compatibility then one would likely consider this. Hence marking this as \"hold for document update\"\r\n",
    "submit_date": "2016-09-23",
    "submitter_name": "Erdem Memisyazici",
    "verifier_id": "128",
    "verifier_name": "Stephen Farrell",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "501",
    "doc-id": "RFC2104",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "9",
    "orig_text": "        MD5Update(&context, k_ipad, 64)      /* start with inner pad */\r\n",
    "correct_text": "        MD5Update(&context, k_ipad, 64);     /* start with inner pad */\r\n",
    "notes": " \r\n",
    "submit_date": "2005-06-23",
    "submitter_name": "Gregory Ogonowski",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "8185",
    "doc-id": "RFC2104",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "5",
    "orig_text": "length t be not less than",
    "correct_text": "length to be not less than",
    "notes": "typo on what I assume should be 'to'\r\n\n --VERIFIER NOTES-- \nWe assume that \"the output length t\" refers to the t bits of output in the previous sentence:\r\n\r\n\"Applications of HMAC can choose to truncate the output of HMAC by outputting the t leftmost bits of the HMAC computation for some parameter t (namely, the computation is carried in the normal way as defined in section 2 above but the end result is truncated to t bits). We recommend that the output length t be not less than half the length of the hash output (to match the birthday attack bound) and not less than 80 bits (a suitable lower bound on the number of bits that need to be\r\npredicted by an attacker).\"",
    "submit_date": "2024-11-22",
    "submitter_name": "ev",
    "verifier_id": "2",
    "verifier_name": "RFC Editor",
    "update_date": "2024-11-25 08:06:18"
  },
  {
    "errata_id": "8296",
    "doc-id": "RFC2104",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "GLOBAL",
    "orig_text": "[BCK1]  M. Bellare, R. Canetti, and H. Krawczyk,\r\n           \"Keyed Hash Functions and Message Authentication\",\r\n           Proceedings of Crypto'96, LNCS 1109, pp. 1-15.\r\n           (http://www.research.ibm.com/security/keyed-md5.html)",
    "correct_text": "[BCK1]  M. Bellare, R. Canetti, and H. Krawczyk,\r\n           \"Keyed Hash Functions and Message Authentication\",\r\n           Proceedings of Crypto'96, LNCS 1109, pp. 1-15.",
    "notes": "The link is dead.",
    "submit_date": "2025-02-14",
    "submitter_name": "Andreas Johannessen",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  }
]
