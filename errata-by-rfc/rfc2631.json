[
  {
    "errata_id": "1060",
    "doc-id": "RFC2631",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "",
    "orig_text": "This reference is cited in Section 1, but does not appear in the\r\nReferences section. It should be added:\r\n\r\n[DH76]  W. Diffie and M. E. Hellman, \"New Directions in Cryptography\",\r\n        IEEE Transactions on Information Theory, vol. IT-22, Nov. 1976, \r\n        pp: 644-654.",
    "correct_text": "",
    "notes": null,
    "submit_date": "2007-09-13",
    "submitter_name": "Javier Ader",
    "verifier_id": "112",
    "verifier_name": "Tim Polk",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2506",
    "doc-id": "RFC2631",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.2.1.1",
    "orig_text": "6. For i = 0 to m' - 1\r\n\r\n        U = U + (SHA1[SEED + i] XOR SHA1[(SEED + m' + i)) * 2^(160 * i)\r\n\r\n   Note that for m=160, this reduces to the algorithm of [FIPS-186]\r\n\r\n        U = SHA1[SEED] XOR SHA1[(SEED+1) mod 2^160 ].\r\n",
    "correct_text": "6. For i = 0 to m' - 1\r\n\r\n        U = U + [SHA1(seed + i) Xor SHA1((seed + m' +i ) mod 2^{seedlen})] * 2^{160 * i}\r\n\r\n   Note that for m=160, this reduces to the algorithm of [FIPS-186]\r\n\r\n        U = [SHA1(seed) Xor SHA1((seed +1) mod 2^{seedlen})], where seedlen\r\n            is the binary length of seed.",
    "notes": "The line:\r\n  U = U + (SHA1[SEED + i] XOR SHA1[(SEED + m' + i)) * 2^(160 * i)\r\nis syntactically incorrect. Closing bracket of last 'SHA1[' is missing.\r\nMoreover, when m=160 (m'=1), the loop cannot reduce to the line:\r\n  U = SHA1[SEED] XOR SHA1[(SEED + 1) mod 2^160]\r\nas it can be easily seen.",
    "submit_date": "2010-09-01",
    "submitter_name": "Yves Legrandgerard",
    "verifier_id": "124",
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5480",
    "doc-id": "RFC2631",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.1.1",
    "orig_text": "h is any integer with 1 < h < p-1 such that h{(p-1)/q} mod p > 1\r\n(g has order q mod p; i.e. g^q mod p = 1 if g!=1)",
    "correct_text": "h is any integer with 1 < h < p-1 such that h^{(p-1)/q} mod p > 1\r\n(g has order q mod p; i.e. g^q mod p = 1 if g!=1)",
    "notes": "The explanation of h omitted the exponentiation operator in the inline formula.",
    "submit_date": "2018-08-27",
    "submitter_name": "Charlie Zhuo",
    "verifier_id": "159",
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5897",
    "doc-id": "RFC2631",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.1.2",
    "orig_text": "     KeySpecificInfo ::= SEQUENCE {\r\n       algorithm OBJECT IDENTIFIER,\r\n       counter OCTET STRING SIZE (4..4) }",
    "correct_text": "     KeySpecificInfo ::= SEQUENCE {\r\n       algorithm OBJECT IDENTIFIER,\r\n       counter OCTET STRING (SIZE (4..4)) }",
    "notes": "The addition of '(' and ')' are needed for an ASN.1 compiler to accept the syntax without raising an error.",
    "submit_date": "2019-11-07",
    "submitter_name": "Russ Housley",
    "verifier_id": "162",
    "verifier_name": "Roman Danyliw",
    "update_date": "2022-01-19 14:25:17"
  },
  {
    "errata_id": "5954",
    "doc-id": "RFC2631",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "2.1.5.",
    "orig_text": "     1. Verify that y lies within the interval [2,p-1]. If it does not,\r\n        the key is invalid.\r\n     2. Compute y^q mod p. If the result == 1, the key is valid.\r\n        Otherwise the key is invalid.\r\n",
    "correct_text": "     1. Verify that y lies within the interval [2,p-1]. If it does not,\r\n        the key is invalid.\r\n     2. Compute y^q mod p. If the result == 1, the key is valid.\r\n        Otherwise the key is invalid.\r\n     3. Verify that y does not match g.\r\n",
    "notes": "Validating that (g == received y) needs to be an additional exclusion to the valid range [2,p-1]. If party 'a' accepts received public key 'yb' matching 'g', then ZZ matches  public key 'ya'. i.e. if yb = 2, then xb = 1, therefore ZZ = ya^1 = ya",
    "submit_date": "2020-01-02",
    "submitter_name": "Paul Janson",
    "verifier_id": "159",
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2020-01-12 20:44:09"
  },
  {
    "errata_id": "6302",
    "doc-id": "RFC2631",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.2.1.1",
    "orig_text": "3. Set Nâ€™= L/1024\r\n",
    "correct_text": "3. Set N = L/1024",
    "notes": "The definition of N' is not used in the document. On line 19 of the algorithm, we have \"If counter < (4096 * N) then go to 8.\". Hence, either the definition on line 3 has to be N instead of N', or it should be N' instead of N on line 19.",
    "submit_date": "2020-10-07",
    "submitter_name": "Abdullah Talayhan",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2025-03-07 08:42:33"
  },
  {
    "errata_id": "7761",
    "doc-id": "RFC2631",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "2.2.1.1",
    "orig_text": "   6. If p > 2^(L-1) use a robust primality test to test whether p is\r\n      prime. Else go to 18.",
    "correct_text": "   16. If p > 2^(L-1) use a robust primality test to test whether p is\r\n       prime. Else go to 18.",
    "notes": "This should be numbered as step 16, not step 6.",
    "submit_date": "2024-01-12",
    "submitter_name": "Russ Housley",
    "verifier_id": "2",
    "verifier_name": "RFC Editor",
    "update_date": "2024-01-16 10:37:47"
  }
]
