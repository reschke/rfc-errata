[
  {
    "errata_id": "5729",
    "doc-id": "RFC8555",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "7.5.1",
    "orig_text": "The client indicates to the server that it is ready for the challenge\r\nvalidation by sending an empty JSON body (\"{}\") carried in a POST\r\nrequest to the challenge URL (not the authorization URL).",
    "correct_text": "The client indicates to the server that it is ready for the challenge\r\nvalidation by sending a POST request to the challenge URL (not the\r\nauthorization URL), where the body of the POST request is a JWS object\r\nwhose JSON payload is a response object (see Section 8).  For all\r\nchallenge types defined in this document, the response object is the\r\nempty JSON object (\"{}\").",
    "notes": "It's clear from other text in section 7.5.1 that the \"empty JSON body\" is interpreted by the ACME server as a \"response object\".  (The first function of this erratum is to clarify this point).\r\n\r\nSection 8 says that \"The definition of a challenge type includes...Contents of response objects\", and section 7.5.1 notes that \"the challenges in this document do not define any response fields, but future specifications might define them\".  (The second function of this erratum is to permit clients to send response objects that contain response fields).",
    "submit_date": "2019-05-22",
    "submitter_name": "Rob Stradling",
    "verifier_id": "162",
    "verifier_name": "Roman Danyliw.com",
    "update_date": "2024-01-11 06:07:36"
  },
  {
    "errata_id": "5732",
    "doc-id": "RFC8555",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "8",
    "orig_text": "A challenge object with an error MUST have status\r\nequal to \"invalid\".",
    "correct_text": "A challenge object with an error MUST have status\r\nequal to \"processing\" or \"invalid\".",
    "notes": "Section 8.2 says that 'The server MUST add an entry to the \"error\" field in the challenge after each failed validation query'.  However, if the challenge must then become \"invalid\", it is never possible to retry any validation query (because \"invalid\" is a final state for a challenge object).\r\nThis erratum is necessary to permit validation query retries to ever happen.",
    "submit_date": "2019-05-23",
    "submitter_name": "Rob Stradling",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-02-22 07:52:09"
  },
  {
    "errata_id": "5733",
    "doc-id": "RFC8555",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "8.3",
    "orig_text": "POST /acme/chall/prV_B7yEyA4",
    "correct_text": "POST /acme/chall/prV_B7yEyA4 HTTP/1.1",
    "notes": null,
    "submit_date": "2019-05-23",
    "submitter_name": "Rob Stradling",
    "verifier_id": "162",
    "verifier_name": "Roman Danyliw.com",
    "update_date": "2024-01-11 06:11:53"
  },
  {
    "errata_id": "5734",
    "doc-id": "RFC8555",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "8.4",
    "orig_text": "POST /acme/chall/Rg5dV14Gh1Q",
    "correct_text": "POST /acme/chall/Rg5dV14Gh1Q HTTP/1.1",
    "notes": null,
    "submit_date": "2019-05-23",
    "submitter_name": "Rob Stradling",
    "verifier_id": "162",
    "verifier_name": "Roman Danyliw.com",
    "update_date": "2024-01-11 06:13:29"
  },
  {
    "errata_id": "5735",
    "doc-id": "RFC8555",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "8.3",
    "orig_text": "GET /.well-known/acme-challenge/LoqXcYV8...jxAjEuX0",
    "correct_text": "GET /.well-known/acme-challenge/LoqXcYV8...jxAjEuX0 HTTP/1.1",
    "notes": null,
    "submit_date": "2019-05-23",
    "submitter_name": "Rob Stradling",
    "verifier_id": "162",
    "verifier_name": "Roman Danyliw.com",
    "update_date": "2024-01-11 06:14:39"
  },
  {
    "errata_id": "5771",
    "doc-id": "RFC8555",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "7.1.1",
    "orig_text": "Clients access the directory by sending a GET request to the\r\ndirectory URL.",
    "correct_text": "Clients access the directory by sending a GET request to the directory\r\nURL.  Before making a request to any URL from the directory, the client\r\nMUST evaluate whether the directory object is still fresh according to\r\nthe Cache-Control header(s) received when that directory object was\r\naccessed.  If no Cache-Control header(s) were received, the client MUST\r\nact as if \"Cache-Control: no-cache\" was received.  If the directory\r\nobject is no longer fresh, the client MUST access the directory again\r\n(by sending another GET request to the directory URL) and then use the\r\nupdated directory object.",
    "notes": "The original text is underspecified, because it doesn't say how long a directory remains valid.  A server should be able to update its directory (e.g., to add support for newAuthz, to update the termsOfService URL, etc) without having to worry about clients holding on to stale directory objects.\r\nWhilst in practice many clients tend to re-fetch the server's directory object frequently, I think that it's unwise to leave this to chance.\n --VERIFIER NOTES-- \n   WG consensus per the thread including https://mailarchive.ietf.org/arch/msg/acme/I2oeALKJTyCwlMOp1v9BTadahyE is to reject the proposed erratum.",
    "submit_date": "2019-07-02",
    "submitter_name": "Rob Stradling",
    "verifier_id": "159",
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5861",
    "doc-id": "RFC8555",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7.4.1",
    "orig_text": null,
    "correct_text": "If a server receives a newAuthz request for an identifier where the authorization object already exists, whether created by CA provisioning on the ACME server or by the ACME server handling a previous newAuthz request from a client, the server returns a 200 (OK) response with the existing authorization URL in the Location header field and the existing JSON authorization object in the body.",
    "notes": "The above text (or similar) should be appended to the end of section 7.4.1",
    "submit_date": "2019-09-23",
    "submitter_name": "owen friel",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "5979",
    "doc-id": "RFC8555",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "7.4",
    "orig_text": " If the server is willing to issue the requested certificate, it\r\n   responds with a 201 (Created) response.  The body of this response is\r\n   an order object reflecting the client's request and any\r\n   authorizations the client must complete before the certificate will\r\n   be issued.\r\n\r\n",
    "correct_text": " If the server is willing to issue the requested certificate, it\r\n   responds with a 201 (Created) response.  The body of this response is\r\n   an order object reflecting the client's request and any\r\n   authorizations the client must complete before the certificate will\r\n   be issued. The server returns an order URL in a Location header field.\r\n",
    "notes": "The RFC does not specify/require where the \"order URL\" is presented.  The RFC is very explicit about where other URLs are obtained, and the common understanding is that the URL appears in a Location header after a new-order. \r\n\r\nFor example: \r\n\r\nIn 7.3; 7.3.1; 7.3.5, the RFC explicitly declares the account URL is in the Location header field.\r\n\r\nIn 7.4.1 the RFC is explicit that authorization URLs in pre-authorization appear in the Location header field.\r\n\r\nBut the order URL is only mentioned by example:\r\n\r\nIn 7.4, the RFC illustrates the order URL appearing in the Location header field (All clients seem to implement this).  In 7.1, the RFC shows a table with \"a typical sequence of requests\" that note the \"account\" and \"order\" URLs appear in the location header field.\r\n\r\nThe specification should state something to the effect of \"The server returns an order URL in a Location header field.\" making this functionality explicit.",
    "submit_date": "2020-02-11",
    "submitter_name": "jonathan vanasco",
    "verifier_id": "159",
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2020-02-24 09:45:19"
  },
  {
    "errata_id": "5983",
    "doc-id": "RFC8555",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "9.1",
    "orig_text": "   A file of this type contains one or more certificates encoded with\r\n   the PEM textual encoding, according to [RFC7468].  The textual\r\n   encoding of certificates in this file MUST use the strict encoding\r\n   and MUST NOT include explanatory text.  The ABNF for this format is\r\n   as follows, where \"stricttextualmsg\" and \"eol\" are as defined in\r\n   Section 3 of RFC 7468:\r\n\r\n   certchain = stricttextualmsg *(eol stricttextualmsg)",
    "correct_text": "   A file of this type contains one or more certificates encoded with\r\n   the PEM textual encoding, according to [RFC7468].  The textual\r\n   encoding of certificates in this file MUST use the strict encoding\r\n   and MUST NOT include explanatory text.  The ABNF for this format is\r\n   as follows, where \"stricttextualmsg\" is as defined in\r\n   Section 3 of RFC 7468:\r\n\r\n   certchain = stricttextualmsg *(stricttextualmsg)",
    "notes": "Examples within RFC 8555 indicate that only one EOL should be present between entries in the PEM chain.\r\n\r\nRFC 7468 already defines a stricttextualmsg as ending with EOL\r\nstricttextualmsg = preeb eol\r\n                           strictbase64text\r\n                           posteb eol\r\n\r\nIf a second EOL is to be added before each strict textual message this would result in a blank line between entries.  The prior example in https://tools.ietf.org/html/rfc8555#section-7.4.2 indicates an intention for only one EOL marker to be used:\r\n   -----BEGIN CERTIFICATE-----\r\n   [End-entity certificate contents]\r\n   -----END CERTIFICATE-----\r\n   -----BEGIN CERTIFICATE-----\r\n   [Issuer certificate contents]\r\n   -----END CERTIFICATE-----\r\n   -----BEGIN CERTIFICATE-----\r\n   [Other certificate contents]\r\n   -----END CERTIFICATE-----",
    "submit_date": "2020-02-14",
    "submitter_name": "Jason Baker",
    "verifier_id": "159",
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2020-02-29 10:25:37"
  },
  {
    "errata_id": "6016",
    "doc-id": "RFC8555",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "7.3.5",
    "orig_text": "holder of the new key to take over the account form the holder of the",
    "correct_text": "holder of the new key to take over the account from the holder of the",
    "notes": "Should be \"from\" instead of \"form\"",
    "submit_date": "2020-03-13",
    "submitter_name": "Benjamin Wilson",
    "verifier_id": "159",
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2020-03-13 08:51:01"
  },
  {
    "errata_id": "6030",
    "doc-id": "RFC8555",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "7.2",
    "orig_text": "To get a fresh nonce, the client sends a HEAD request to the newNonce\r\nresource on the server.  The server's response MUST include a Replay-\r\nNonce header field containing a fresh nonce and SHOULD have status\r\ncode 200 (OK).  The server MUST also respond to GET requests for this\r\nresource, returning an empty body (while still providing a Replay-\r\nNonce header) with a status code of 204 (No Content).",
    "correct_text": "To get a fresh nonce, the client sends a HEAD request to the newNonce\r\nresource on the server.  The server's response MUST include a Replay-\r\nNonce header field containing a fresh nonce and SHOULD have status\r\ncode 204 (No Content).  The server MUST also respond to GET requests for this\r\nresource, returning an empty body (while still providing a Replay-\r\nNonce header) with a status code of 204 (No Content).",
    "notes": "RFC7321 s4.3.2, says \"The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request had been a GET\".  I can't see any rationale for violating this SHOULD in the discussion in the GH issue which introduced the discrepancy in response code between GET and HEAD (https://github.com/ietf-wg-acme/acme/pull/371), thus (IMHO) it violates the tenets of a SHOULD, as \"the full implications\" do not appear to have \"be[en] understood and carefully weighed before choosing a different course\" (RFC2119, of course).",
    "submit_date": "2020-03-25",
    "submitter_name": "Matt Palmer",
    "verifier_id": "179",
    "verifier_name": "Deb Cooley",
    "update_date": "2024-03-22 08:00:45"
  },
  {
    "errata_id": "6103",
    "doc-id": "RFC8555",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "7.1.",
    "orig_text": "   o  A \"newAccount\" resource (Section 7.3)\r\n\r\n   o  A \"newOrder\" resource (Section 7.4)",
    "correct_text": "   o  A \"newAccount\" resource (Section 7.3)\r\n\r\n   o  A \"newAuthz\" resource (Section 7.4)\r\n\r\n   o  A \"newOrder\" resource (Section 7.4)",
    "notes": "The item for the \"newAuthz\" resource is missing in the list of resources.",
    "submit_date": "2020-04-14",
    "submitter_name": "Theodor Nolte",
    "verifier_id": "162",
    "verifier_name": "Roman Danyliw.com",
    "update_date": "2024-01-11 07:44:03"
  },
  {
    "errata_id": "6104",
    "doc-id": "RFC8555",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "6.7.1",
    "orig_text": "   in the problem document.\r\n\r\nHTTP/1.1 403 Forbidden\r\nContent-Type: application/problem+json\r\nLink: <https://example.com/acme/directory>;rel=\"index\"\r\n\r\n{\r\n    \"type\": \"urn:ietf:params:acme:error:malformed\",\r\n    \"detail\": \"Some of the identifiers requested were rejected\",\r\n    \"subproblems\": [\r\n        {\r\n            \"type\": \"urn:ietf:params:acme:error:malformed\",\r\n            \"detail\": \"Invalid underscore in DNS name \\\"_example.org\\\"\",\r\n            \"identifier\": {\r\n                \"type\": \"dns\",\r\n                \"value\": \"_example.org\"\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"urn:ietf:params:acme:error:rejectedIdentifier\",\r\n            \"detail\": \"This CA will not issue for \\\"example.net\\\"\",\r\n            \"identifier\": {\r\n                \"type\": \"dns\",\r\n                \"value\": \"example.net\"\r\n            }\r\n        }\r\n    ]\r\n}",
    "correct_text": "   in the problem document.\r\n\r\n   HTTP/1.1 403 Forbidden\r\n   Content-Type: application/problem+json\r\n   Link: <https://example.com/acme/directory>;rel=\"index\"\r\n\r\n   {\r\n       \"type\": \"urn:ietf:params:acme:error:malformed\",\r\n       \"detail\": \"Some of the identifiers requested were rejected\",\r\n       \"subproblems\": [\r\n           {\r\n               \"type\": \"urn:ietf:params:acme:error:malformed\",\r\n               \"detail\": \"Invalid underscore in DNS name \\\"_example.org\\\"\",\r\n               \"identifier\": {\r\n                   \"type\": \"dns\",\r\n                   \"value\": \"_example.org\"\r\n               }\r\n           },\r\n           {\r\n               \"type\": \"urn:ietf:params:acme:error:rejectedIdentifier\",\r\n               \"detail\": \"This CA will not issue for \\\"example.net\\\"\",\r\n               \"identifier\": {\r\n                   \"type\": \"dns\",\r\n                   \"value\": \"example.net\"\r\n               }\r\n           }\r\n       ]\r\n   }",
    "notes": "The indenting of the code block of the HTTP reply is not aligned.",
    "submit_date": "2020-04-14",
    "submitter_name": "Theodor Nolte",
    "verifier_id": "162",
    "verifier_name": "Roman Danyliw.com",
    "update_date": "2024-01-11 06:18:15"
  },
  {
    "errata_id": "6276",
    "doc-id": "RFC8555",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "2",
    "orig_text": "   o  The CA verifies that the client controls the requested domain\r\n      name(s) by having the ACME client perform some action(s) that can\r\n      only be done with control of the domain name(s).  For example, the\r\n      CA might require a client requesting example.com to provision a\r\n      DNS record under example.com or an HTTP resource under\r\n      http://example.com.\r\n",
    "correct_text": "   o  The CA verifies that the client controls the requested domain\r\n      name(s) by having the ACME client perform some action(s) that can\r\n      only be done with control of the domain name(s).  For example, the\r\n      CA might require a client requesting example.org to provision a\r\n      DNS record under example.org or an HTTP resource under\r\n      http://example.org.\r\n",
    "notes": "The spec consistently uses example.com for an ACME CA server, and example.org for a site requesting a certificate -- except in this sentence.",
    "submit_date": "2020-09-03",
    "submitter_name": "James Manger",
    "verifier_id": "159",
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2020-09-03 18:15:40"
  },
  {
    "errata_id": "6317",
    "doc-id": "RFC8555",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "7.5.1",
    "orig_text": "The server is said to \"finalize\" the authorization when it has\r\ncompleted one of the validations.",
    "correct_text": "The server is said to \"finalize\" the authorization when it has\r\nsuccessfully completed one of the validations or failed all of\r\nthem.",
    "notes": "The current handling of failed challenges is ambiguous, or at least inefficient.\r\n\r\nTo get a certificate, a client creates an Order. The client then has to validate all Authorizations (\"authzs\"). For each Authorization, the client needs to successfully complete one of the offered Challenges. One successful Challenge is sufficient to validate the authz. However, currently in practice, one failed Challenge is sufficient to invalidate the authz, and thus the entire Order. To try another Challenge, the client then has to first deactivate the other Authorizations (expensive) and create a new Order (also expensive), then repeat the whole process, remembering what was already tried.\r\n\r\nIt is proposed that an Authorization MUST NOT be finalized until all possible challenges have failed. The client could then simply try the next Challenge. In other words, a single failed Challenge should not invalidate an authz; an authz should be \"pending\" until all offered challenges have failed or one has succeeded.\r\n\r\nThe spec should be clear that a single failed challenge is not sufficient to finalize an authz which has multiple possible challenges.\r\n\r\nACME servers see many, many failed validations. ACME clients need to keep more state. This change will speed up ACME transactions, lower costs for CAs, reduce code complexity, and make ACME more reliable on the whole.\r\n\r\nReal-world experience: https://github.com/mholt/acmez/commit/80adb6d5e64a3d36a56c58c66965b131ea366b8c\r\nMailing list discussion: https://mailarchive.ietf.org/arch/msg/acme/wIHaqikTCZ59zrWsUUus8lZ4VSg/",
    "submit_date": "2020-10-23",
    "submitter_name": "Matthew Holt",
    "verifier_id": "162",
    "verifier_name": "Roman Danyliw",
    "update_date": "2024-01-11 13:31:57"
  },
  {
    "errata_id": "6364",
    "doc-id": "RFC8555",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "7.1.4",
    "orig_text": "   wildcard (optional, boolean):  This field MUST be present and true\r\n      for authorizations created as a result of a newOrder request\r\n      containing a DNS identifier with a value that was a wildcard\r\n      domain name.  For other authorizations, it MUST be absent.\r\n      Wildcard domain names are described in Section 7.1.3.",
    "correct_text": "   wildcard (optional, boolean):  This field MUST be present and true\r\n      for authorizations created as a result of a newOrder request\r\n      containing a DNS identifier with a value that was a wildcard\r\n      domain name.  For other authorizations, it MUST be absent or\r\n      false.  For pre-authorizations, it MUST be absent or false.\r\n      Wildcard domain names are described in Section 7.1.3.",
    "notes": "This section states that the wildcard field must be absent for other authorizations, but the example in this section has an explicitly set wildcard field with value false. The proposed change allows both options, either omitting it or explicitly setting it to false. Also a sentence has been added to explicitly describe the behavior for pre-authorizations.",
    "submit_date": "2020-12-23",
    "submitter_name": "Evangelos Karatsiolis",
    "verifier_id": "179",
    "verifier_name": "Deb Cooley",
    "update_date": "2024-03-22 07:57:21"
  },
  {
    "errata_id": "6843",
    "doc-id": "RFC8555",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "8.3",
    "orig_text": "Because many web servers\r\nallocate a default HTTPS virtual host to a particular low-privilege\r\ntenant user in a subtle and non-intuitive manner, the challenge must\r\nbe completed over HTTP, not HTTPS.\r\n",
    "correct_text": "Because many web servers\r\nallocate a default HTTPS virtual host to a particular low-privilege\r\ntenant user in a subtle and non-intuitive manner, the challenge must\r\nbe initiated over HTTP, not HTTPS.",
    "notes": "Completing the entire http-01 challenge over HTTP is unnecessary. The threat of default HTTPS virtual hosts is remediated by \"initiating\" the http-01 challenge over HTTP. Validation servers which redirect from HTTP to HTTPS should be permitted following the rest of the guidance within Section 10, Security Considerations.",
    "submit_date": "2022-02-08",
    "submitter_name": "James Kasten",
    "verifier_id": "162",
    "verifier_name": "Roman Danyliw",
    "update_date": "2024-01-11 10:51:38"
  },
  {
    "errata_id": "6950",
    "doc-id": "RFC8555",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "GLOBAL",
    "orig_text": "token (required, string):  A random value that uniquely identifies\r\n      the challenge.  This value MUST have at least 128 bits of entropy.",
    "correct_text": "token (required, string):  A random value that uniquely identifies\r\n      the challenge.  This value MUST have at least 128 bits of entropy, which in the \r\n      base64url alphabet means a minimum string length of 22 characters if the full\r\n      scope of the base64url alphabet is in use in the token, by:\r\n                        log2(64^22) = 132 bits of entropy\r\n\r\n",
    "notes": "This standards-track document doesn't specify the string ramifications for entropy; I'd expect it to be called out to implementers, just the once, and then referred to later at other tokens.\r\n\r\nIf entropy is log2 the number of possible characters (64 if full base64url set of chars is in use) then \r\nlog2 (64^21) = 126\r\nlog2 (64^22) = 132\r\n\r\nso a minimum of 22 characters are needed to get a minimum of 128 bits of entropy in the token.\r\n\r\nBut, if the random value is specified using a subset of the base64url, say because the implementer doesn't like or use CAPITALS or (most likely) the punctuation symbols, then the token must necessarily be longer to meet the local implementer entropy requirement (though just losing only the punctuation marks means you're still good and meet the requirement with 22 characters). Not sure that matters so much on the wire.\r\n\r\nI also have editing nits about base64url being defined clearly in ABNF just for Replay-Nonce:, but then both 'base64 alphabet' and 'base64url alphabet' are in use in the document, and base64url references are to RFC4648 via RFC7515, but those are to Base64url, not to base64url... it all seems a bit inconsistent editingwise. So all the references to 'base64 alphabet' should be to 'base64url alphabet' as defined in the doc, but it should really be 'Base64url alphabet' to be consistent with references?\r\n\r\n(I really think that it should have been called 'Base-64_url alphabet' way back when to enphasise the punctuation use, but that ship has sailed.)\r\n\r\nTo me, 'base64 alphabet' is the a-zA-Z subset of base64... I think the document could be much clearer in this regard, and I hope any doc revisions taking into account all the other errata raised consider this too.\r\n\r\nMy thanks to Lee Maguire for pointing much of this out.",
    "submit_date": "2022-05-02",
    "submitter_name": "Lloyd Wood",
    "verifier_id": "179",
    "verifier_name": "Deb Cooley",
    "update_date": "2024-03-22 08:01:54"
  },
  {
    "errata_id": "7565",
    "doc-id": "RFC8555",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "8.1",
    "orig_text": " The \"Thumbprint\" step indicates the computation specified in\r\n   [RFC7638], using the SHA-256 digest [FIPS180-4].  As noted in\r\n   [RFC7518] any prepended zero octets in the fields of a JWK object\r\n   MUST be stripped before doing the computation.",
    "correct_text": "The \"Thumbprint\" step indicates the computation specified in\r\n   [RFC7638], using the SHA-256 digest [FIPS180-4].  As noted in\r\n   [RFC7518] any additional prepended zero octets in the fields of a JWK object\r\n   MUST be stripped before doing the computation.  \r\n   Fixed length fields such as found in ECDSA keys should be their natural length and \r\n   leading zero octets should not be stripped.",
    "notes": "This comment was really aimed at the leading 0 octet sometimes used with RSA, but the comment is not RSA specific. ECDSA keys can have fixed length fields (X,Y) where there can be leading zeros.  This led me astray in implementing an ECDSA thumbprint routine for ACME. The result was that 1/128 ECDSA keys failed to generate t humbp[rint as leading zeros were removed.",
    "submit_date": "2023-07-13",
    "submitter_name": "Paul Breed",
    "verifier_id": "162",
    "verifier_name": "Roman Danyliw",
    "update_date": "2024-01-11 10:49:44"
  },
  {
    "errata_id": "7826",
    "doc-id": "RFC8555",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "8.2",
    "orig_text": "The server MUST provide information about its retry state to the \r\nclient via the \"error\" field in the challenge and the Retry-After \r\nHTTP header field in response to requests to the challenge resource.",
    "correct_text": "In responding to requests to the challenge resource while the status \r\nof the challenge remains \"processing\", the server MUST provide \r\ninformation about its retry state to the client via the \"error\" field \r\nin the challenge and the Retry-After HTTP header field.",
    "notes": "The current text seems to require the server to include the \"error\" field and Retry-After HTTP header in all responses to requests for a challenge resource, even before that challenge has moved from \"pending\" to \"processing\", and even after that challenge has moved from \"processing\" to \"valid\" or \"invalid\".  However, the \"State Transitions for Challenge Objects\" diagram in Section 7.1.6 shows that it only makes sense for the server to communicate \"its retry state\" to the client when the challenge is \"processing\".\r\n\r\nI've modelled the structure of my suggested Corrected Text on similar language in Section 7.5.1: \"In responding to poll requests while the validation is still in progress, the server MUST...\".",
    "submit_date": "2024-02-28",
    "submitter_name": "Rob Stradling",
    "verifier_id": "2",
    "verifier_name": null,
    "update_date": "2024-02-28 13:15:45"
  },
  {
    "errata_id": "8381",
    "doc-id": "RFC8555",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "8.3",
    "orig_text": "   3.  Dereference the URL using an HTTP GET request.  This request MUST\r\n       be sent to TCP port 80 on the HTTP server.",
    "correct_text": "   3.  Dereference the URL using an HTTP GET request.  This request MUST\r\n       be sent to TCP port 80 on the HTTP server.  (The HTTP client must\r\n       not resolve and/or must ignore any HTTPS DNS RRs [RFC 9460].)",
    "notes": "Doing a DNS lookup of an HTTPS DNS RR [RFC 9460] might force the client to switch from HTTP to HTTPS scheme which would break HTTP-01 lookups.  The RFC8555 text is clear that \"request MUST be sent to TCP port 80 on the HTTP server\" which would be violated if the validating client did an HTTPS RR lookup in the DNS and followed the instructions in RFC 9460 section 9.5.",
    "submit_date": "2025-04-15",
    "submitter_name": "Erik Nygren",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  }
]
