[
  {
    "errata_id": 5729,
    "doc-id": "RFC8555",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7.5.1",
    "orig_text": "The client indicates to the server that it is ready for the challenge\r\nvalidation by sending an empty JSON body (\"{}\") carried in a POST\r\nrequest to the challenge URL (not the authorization URL).",
    "correct_text": "The client indicates to the server that it is ready for the challenge\r\nvalidation by sending a POST request to the challenge URL (not the\r\nauthorization URL), where the body of the POST request is a JWS object\r\nwhose JSON payload is a response object (see Section 8).  For all\r\nchallenge types defined in this document, the response object is the\r\nempty JSON object (\"{}\").",
    "notes": "It's clear from other text in section 7.5.1 that the \"empty JSON body\" is interpreted by the ACME server as a \"response object\".  (The first function of this erratum is to clarify this point).\r\n\r\nSection 8 says that \"The definition of a challenge type includes...Contents of response objects\", and section 7.5.1 notes that \"the challenges in this document do not define any response fields, but future specifications might define them\".  (The second function of this erratum is to permit clients to send response objects that contain response fields).",
    "submit_date": "2019-05-22",
    "submitter_name": "Rob Stradling",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5732,
    "doc-id": "RFC8555",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 8,
    "orig_text": "A challenge object with an error MUST have status\r\nequal to \"invalid\".",
    "correct_text": "A challenge object with an error MUST have status\r\nequal to \"processing\" or \"invalid\".",
    "notes": "Section 8.2 says that 'The server MUST add an entry to the \"error\" field in the challenge after each failed validation query'.  However, if the challenge must then become \"invalid\", it is never possible to retry any validation query (because \"invalid\" is a final state for a challenge object).\r\nThis erratum is necessary to permit validation query retries to ever happen.",
    "submit_date": "2019-05-23",
    "submitter_name": "Rob Stradling",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5733,
    "doc-id": "RFC8555",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": 8.3,
    "orig_text": "POST /acme/chall/prV_B7yEyA4",
    "correct_text": "POST /acme/chall/prV_B7yEyA4 HTTP/1.1",
    "notes": null,
    "submit_date": "2019-05-23",
    "submitter_name": "Rob Stradling",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5734,
    "doc-id": "RFC8555",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": 8.4,
    "orig_text": "POST /acme/chall/Rg5dV14Gh1Q",
    "correct_text": "POST /acme/chall/Rg5dV14Gh1Q HTTP/1.1",
    "notes": null,
    "submit_date": "2019-05-23",
    "submitter_name": "Rob Stradling",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5735,
    "doc-id": "RFC8555",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": 8.3,
    "orig_text": "GET /.well-known/acme-challenge/LoqXcYV8...jxAjEuX0",
    "correct_text": "GET /.well-known/acme-challenge/LoqXcYV8...jxAjEuX0 HTTP/1.1",
    "notes": null,
    "submit_date": "2019-05-23",
    "submitter_name": "Rob Stradling",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5771,
    "doc-id": "RFC8555",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "7.1.1",
    "orig_text": "Clients access the directory by sending a GET request to the\r\ndirectory URL.",
    "correct_text": "Clients access the directory by sending a GET request to the directory\r\nURL.  Before making a request to any URL from the directory, the client\r\nMUST evaluate whether the directory object is still fresh according to\r\nthe Cache-Control header(s) received when that directory object was\r\naccessed.  If no Cache-Control header(s) were received, the client MUST\r\nact as if \"Cache-Control: no-cache\" was received.  If the directory\r\nobject is no longer fresh, the client MUST access the directory again\r\n(by sending another GET request to the directory URL) and then use the\r\nupdated directory object.",
    "notes": "The original text is underspecified, because it doesn't say how long a directory remains valid.  A server should be able to update its directory (e.g., to add support for newAuthz, to update the termsOfService URL, etc) without having to worry about clients holding on to stale directory objects.\r\nWhilst in practice many clients tend to re-fetch the server's directory object frequently, I think that it's unwise to leave this to chance.\n --VERIFIER NOTES-- \n   WG consensus per the thread including https://mailarchive.ietf.org/arch/msg/acme/I2oeALKJTyCwlMOp1v9BTadahyE is to reject the proposed erratum.",
    "submit_date": "2019-07-02",
    "submitter_name": "Rob Stradling",
    "verifier_id": 159,
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5861,
    "doc-id": "RFC8555",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7.4.1",
    "orig_text": null,
    "correct_text": "If a server receives a newAuthz request for an identifier where the authorization object already exists, whether created by CA provisioning on the ACME server or by the ACME server handling a previous newAuthz request from a client, the server returns a 200 (OK) response with the existing authorization URL in the Location header field and the existing JSON authorization object in the body.",
    "notes": "The above text (or similar) should be appended to the end of section 7.4.1",
    "submit_date": "2019-09-23",
    "submitter_name": "owen friel",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 5979,
    "doc-id": "RFC8555",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": 7.4,
    "orig_text": " If the server is willing to issue the requested certificate, it\r\n   responds with a 201 (Created) response.  The body of this response is\r\n   an order object reflecting the client's request and any\r\n   authorizations the client must complete before the certificate will\r\n   be issued.\r\n\r\n",
    "correct_text": " If the server is willing to issue the requested certificate, it\r\n   responds with a 201 (Created) response.  The body of this response is\r\n   an order object reflecting the client's request and any\r\n   authorizations the client must complete before the certificate will\r\n   be issued. The server returns an order URL in a Location header field.\r\n",
    "notes": "The RFC does not specify/require where the \"order URL\" is presented.  The RFC is very explicit about where other URLs are obtained, and the common understanding is that the URL appears in a Location header after a new-order. \r\n\r\nFor example: \r\n\r\nIn 7.3; 7.3.1; 7.3.5, the RFC explicitly declares the account URL is in the Location header field.\r\n\r\nIn 7.4.1 the RFC is explicit that authorization URLs in pre-authorization appear in the Location header field.\r\n\r\nBut the order URL is only mentioned by example:\r\n\r\nIn 7.4, the RFC illustrates the order URL appearing in the Location header field (All clients seem to implement this).  In 7.1, the RFC shows a table with \"a typical sequence of requests\" that note the \"account\" and \"order\" URLs appear in the location header field.\r\n\r\nThe specification should state something to the effect of \"The server returns an order URL in a Location header field.\" making this functionality explicit.",
    "submit_date": "2020-02-11",
    "submitter_name": "jonathan vanasco",
    "verifier_id": 159,
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2020-02-24 09:45:19"
  },
  {
    "errata_id": 5983,
    "doc-id": "RFC8555",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 9.1,
    "orig_text": "   A file of this type contains one or more certificates encoded with\r\n   the PEM textual encoding, according to [RFC7468].  The textual\r\n   encoding of certificates in this file MUST use the strict encoding\r\n   and MUST NOT include explanatory text.  The ABNF for this format is\r\n   as follows, where \"stricttextualmsg\" and \"eol\" are as defined in\r\n   Section 3 of RFC 7468:\r\n\r\n   certchain = stricttextualmsg *(eol stricttextualmsg)",
    "correct_text": "   A file of this type contains one or more certificates encoded with\r\n   the PEM textual encoding, according to [RFC7468].  The textual\r\n   encoding of certificates in this file MUST use the strict encoding\r\n   and MUST NOT include explanatory text.  The ABNF for this format is\r\n   as follows, where \"stricttextualmsg\" is as defined in\r\n   Section 3 of RFC 7468:\r\n\r\n   certchain = stricttextualmsg *(stricttextualmsg)",
    "notes": "Examples within RFC 8555 indicate that only one EOL should be present between entries in the PEM chain.\r\n\r\nRFC 7468 already defines a stricttextualmsg as ending with EOL\r\nstricttextualmsg = preeb eol\r\n                           strictbase64text\r\n                           posteb eol\r\n\r\nIf a second EOL is to be added before each strict textual message this would result in a blank line between entries.  The prior example in https://tools.ietf.org/html/rfc8555#section-7.4.2 indicates an intention for only one EOL marker to be used:\r\n   -----BEGIN CERTIFICATE-----\r\n   [End-entity certificate contents]\r\n   -----END CERTIFICATE-----\r\n   -----BEGIN CERTIFICATE-----\r\n   [Issuer certificate contents]\r\n   -----END CERTIFICATE-----\r\n   -----BEGIN CERTIFICATE-----\r\n   [Other certificate contents]\r\n   -----END CERTIFICATE-----",
    "submit_date": "2020-02-14",
    "submitter_name": "Jason Baker",
    "verifier_id": 159,
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2020-02-29 10:25:37"
  },
  {
    "errata_id": 6016,
    "doc-id": "RFC8555",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "7.3.5",
    "orig_text": "holder of the new key to take over the account form the holder of the",
    "correct_text": "holder of the new key to take over the account from the holder of the",
    "notes": "Should be \"from\" instead of \"form\"",
    "submit_date": "2020-03-13",
    "submitter_name": "Benjamin Wilson",
    "verifier_id": 159,
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2020-03-13 08:51:01"
  },
  {
    "errata_id": 6030,
    "doc-id": "RFC8555",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 7.2,
    "orig_text": "To get a fresh nonce, the client sends a HEAD request to the newNonce\r\nresource on the server.  The server's response MUST include a Replay-\r\nNonce header field containing a fresh nonce and SHOULD have status\r\ncode 200 (OK).  The server MUST also respond to GET requests for this\r\nresource, returning an empty body (while still providing a Replay-\r\nNonce header) with a status code of 204 (No Content).",
    "correct_text": "To get a fresh nonce, the client sends a HEAD request to the newNonce\r\nresource on the server.  The server's response MUST include a Replay-\r\nNonce header field containing a fresh nonce and SHOULD have status\r\ncode 204 (No Content).  The server MUST also respond to GET requests for this\r\nresource, returning an empty body (while still providing a Replay-\r\nNonce header) with a status code of 204 (No Content).",
    "notes": "RFC7321 s4.3.2, says \"The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request had been a GET\".  I can't see any rationale for violating this SHOULD in the discussion in the GH issue which introduced the discrepancy in response code between GET and HEAD (https://github.com/ietf-wg-acme/acme/pull/371), thus (IMHO) it violates the tenets of a SHOULD, as \"the full implications\" do not appear to have \"be[en] understood and carefully weighed before choosing a different course\" (RFC2119, of course).",
    "submit_date": "2020-03-25",
    "submitter_name": "Matt Palmer",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6103,
    "doc-id": "RFC8555",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7.1.",
    "orig_text": "   o  A \"newAccount\" resource (Section 7.3)\r\n\r\n   o  A \"newOrder\" resource (Section 7.4)",
    "correct_text": "   o  A \"newAccount\" resource (Section 7.3)\r\n\r\n   o  A \"newAuthz\" resource (Section 7.4)\r\n\r\n   o  A \"newOrder\" resource (Section 7.4)",
    "notes": "The item for the \"newAuthz\" resource is missing in the list of resources.",
    "submit_date": "2020-04-14",
    "submitter_name": "Theodor Nolte",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6104,
    "doc-id": "RFC8555",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "6.7.1",
    "orig_text": "   in the problem document.\r\n\r\nHTTP/1.1 403 Forbidden\r\nContent-Type: application/problem+json\r\nLink: <https://example.com/acme/directory>;rel=\"index\"\r\n\r\n{\r\n    \"type\": \"urn:ietf:params:acme:error:malformed\",\r\n    \"detail\": \"Some of the identifiers requested were rejected\",\r\n    \"subproblems\": [\r\n        {\r\n            \"type\": \"urn:ietf:params:acme:error:malformed\",\r\n            \"detail\": \"Invalid underscore in DNS name \\\"_example.org\\\"\",\r\n            \"identifier\": {\r\n                \"type\": \"dns\",\r\n                \"value\": \"_example.org\"\r\n            }\r\n        },\r\n        {\r\n            \"type\": \"urn:ietf:params:acme:error:rejectedIdentifier\",\r\n            \"detail\": \"This CA will not issue for \\\"example.net\\\"\",\r\n            \"identifier\": {\r\n                \"type\": \"dns\",\r\n                \"value\": \"example.net\"\r\n            }\r\n        }\r\n    ]\r\n}",
    "correct_text": "   in the problem document.\r\n\r\n   HTTP/1.1 403 Forbidden\r\n   Content-Type: application/problem+json\r\n   Link: <https://example.com/acme/directory>;rel=\"index\"\r\n\r\n   {\r\n       \"type\": \"urn:ietf:params:acme:error:malformed\",\r\n       \"detail\": \"Some of the identifiers requested were rejected\",\r\n       \"subproblems\": [\r\n           {\r\n               \"type\": \"urn:ietf:params:acme:error:malformed\",\r\n               \"detail\": \"Invalid underscore in DNS name \\\"_example.org\\\"\",\r\n               \"identifier\": {\r\n                   \"type\": \"dns\",\r\n                   \"value\": \"_example.org\"\r\n               }\r\n           },\r\n           {\r\n               \"type\": \"urn:ietf:params:acme:error:rejectedIdentifier\",\r\n               \"detail\": \"This CA will not issue for \\\"example.net\\\"\",\r\n               \"identifier\": {\r\n                   \"type\": \"dns\",\r\n                   \"value\": \"example.net\"\r\n               }\r\n           }\r\n       ]\r\n   }",
    "notes": "The code block of the HTTP reply is not aligned.",
    "submit_date": "2020-04-14",
    "submitter_name": "Theodor Nolte",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6276,
    "doc-id": "RFC8555",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 2,
    "orig_text": "   o  The CA verifies that the client controls the requested domain\r\n      name(s) by having the ACME client perform some action(s) that can\r\n      only be done with control of the domain name(s).  For example, the\r\n      CA might require a client requesting example.com to provision a\r\n      DNS record under example.com or an HTTP resource under\r\n      http://example.com.\r\n",
    "correct_text": "   o  The CA verifies that the client controls the requested domain\r\n      name(s) by having the ACME client perform some action(s) that can\r\n      only be done with control of the domain name(s).  For example, the\r\n      CA might require a client requesting example.org to provision a\r\n      DNS record under example.org or an HTTP resource under\r\n      http://example.org.\r\n",
    "notes": "The spec consistently uses example.com for an ACME CA server, and example.org for a site requesting a certificate -- except in this sentence.",
    "submit_date": "2020-09-03",
    "submitter_name": "James Manger",
    "verifier_id": 159,
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2020-09-03 18:15:40"
  },
  {
    "errata_id": 6317,
    "doc-id": "RFC8555",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7.5.1",
    "orig_text": "The server is said to \"finalize\" the authorization when it has\r\ncompleted one of the validations.",
    "correct_text": "The server is said to \"finalize\" the authorization when it has\r\nsuccessfully completed one of the validations or failed all of\r\nthem.",
    "notes": "The current handling of failed challenges is ambiguous, or at least inefficient.\r\n\r\nTo get a certificate, a client creates an Order. The client then has to validate all Authorizations (\"authzs\"). For each Authorization, the client needs to successfully complete one of the offered Challenges. One successful Challenge is sufficient to validate the authz. However, currently in practice, one failed Challenge is sufficient to invalidate the authz, and thus the entire Order. To try another Challenge, the client then has to first deactivate the other Authorizations (expensive) and create a new Order (also expensive), then repeat the whole process, remembering what was already tried.\r\n\r\nIt is proposed that an Authorization MUST NOT be finalized until all possible challenges have failed. The client could then simply try the next Challenge. In other words, a single failed Challenge should not invalidate an authz; an authz should be \"pending\" until all offered challenges have failed or one has succeeded.\r\n\r\nThe spec should be clear that a single failed challenge is not sufficient to finalize an authz which has multiple possible challenges.\r\n\r\nACME servers see many, many failed validations. ACME clients need to keep more state. This change will speed up ACME transactions, lower costs for CAs, reduce code complexity, and make ACME more reliable on the whole.\r\n\r\nReal-world experience: https://github.com/mholt/acmez/commit/80adb6d5e64a3d36a56c58c66965b131ea366b8c\r\nMailing list discussion: https://mailarchive.ietf.org/arch/msg/acme/wIHaqikTCZ59zrWsUUus8lZ4VSg/",
    "submit_date": "2020-10-23",
    "submitter_name": "Matthew Holt",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6364,
    "doc-id": "RFC8555",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7.1.4",
    "orig_text": "   wildcard (optional, boolean):  This field MUST be present and true\r\n      for authorizations created as a result of a newOrder request\r\n      containing a DNS identifier with a value that was a wildcard\r\n      domain name.  For other authorizations, it MUST be absent.\r\n      Wildcard domain names are described in Section 7.1.3.",
    "correct_text": "   wildcard (optional, boolean):  This field MUST be present and true\r\n      for authorizations created as a result of a newOrder request\r\n      containing a DNS identifier with a value that was a wildcard\r\n      domain name.  For other authorizations, it MUST be absent or\r\n      false.  For pre-authorizations, it MUST be absent or false.\r\n      Wildcard domain names are described in Section 7.1.3.",
    "notes": "This section states that the wildcard field must be absent for other authorizations, but the example in this section has an explicitly set wildcard field with value false. The proposed change allows both options, either omitting it or explicitly setting it to false. Also a sentence has been added to explicitly describe the behavior for pre-authorizations.",
    "submit_date": "2020-12-23",
    "submitter_name": "Evangelos Karatsiolis",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  }
]
