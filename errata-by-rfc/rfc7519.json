[
  {
    "errata_id": "5648",
    "doc-id": "RFC7519",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "1",
    "orig_text": "JSON Web Token (JWT) is a compact claims representation format\r\n   intended for space constrained environments such as HTTP\r\n   Authorization headers and URI query parameters.  JWTs encode claims\r\n   to be transmitted as a JSON [RFC7159] object that is used as the\r\n   payload of a JSON Web Signature (JWS) [JWS] structure or as the\r\n   plaintext of a JSON Web Encryption (JWE) [JWE] structure, enabling\r\n   the claims to be digitally signed or integrity protected with a\r\n   Message Authentication Code (MAC) and/or encrypted.  JWTs are always\r\n   represented using the JWS Compact Serialization or the JWE Compact\r\n   Serialization.\r\n\r\n   The suggested pronunciation of JWT is the same as the English word\r\n   \"jot\".\r\n\r\n",
    "correct_text": "JSON Web Token (JWT) is a compact claims representation format\r\n   intended for space constrained environments such as HTTP\r\n   Authorization headers and URI query parameters.  JWTs encode claims\r\n   to be transmitted as a JSON [RFC7159] object that is used as the\r\n   payload of a JSON Web Signature (JWS) [JWS] structure or as the\r\n   plaintext of a JSON Web Encryption (JWE) [JWE] structure, enabling\r\n   the claims to be digitally signed or integrity protected with a\r\n   Message Authentication Code (MAC) and/or encrypted.  JWTs are always\r\n   represented using the JWS Compact Serialization or the JWE Compact\r\n   Serialization.\r\n",
    "notes": "The suggested pronunciation is strange and confusing. It makes it hard to onboard new people verbally and always requires an explanation of the pronunciation. The standard already has a perfectly reasonable initialism of JWT that clearly refers to JSON Web Tokens. It is jarring to suggest a pronunciation that does not map to the letters of the spec, and in my experience often leads to confusion when used.\n --VERIFIER NOTES-- \nThis guidance was produced with the consensus of the WG.  Per https://www.ietf.org/about/groups/iesg/statements/processing-errata-ietf-stream/, \"Errata are items that were errors at the time the document was published\"",
    "submit_date": "2019-03-08",
    "submitter_name": "Andy Delcambre",
    "verifier_id": "162",
    "verifier_name": "Roman Danyliw",
    "update_date": "2024-01-11 18:53:29"
  },
  {
    "errata_id": "5906",
    "doc-id": "RFC7519",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7.2",
    "orig_text": "   Finally, note that it is an application decision which algorithms may\r\n   be used in a given context.  Even if a JWT can be successfully\r\n   validated, unless the algorithms used in the JWT are acceptable to\r\n   the application, it SHOULD reject the JWT.",
    "correct_text": "   Finally, note that it is an application decision which algorithms may\r\n   be used in a given context.  Even if a JWT can be successfully\r\n   validated, unless the algorithms used in the JWT are acceptable to\r\n   the application, it MUST reject the JWT.",
    "notes": "A vulnerability exists in certain implementations in the wild where applications simply look for valid JWT tokens which includes the \"none\" algorithm (https://medium.com/swlh/hacking-json-web-tokens-jwts-9122efe91e4a).  A fairly popular library is auth0's java-jwt and at verification (https://github.com/auth0/java-jwt/blob/master/lib/src/main/java/com/auth0/jwt/JWTVerifier.java) quite reasonably you cannot initialize the class without an algorithm.  Given all capital SHOULD may be interpreted as a recommendation and as this RFC dictates the algorithm \"none\" MUST be implemented as a default algorithm under Section 8, one could argue JWTVerifier in the example doesn't have to verifyAlgorithm leading to the vulnerability pointed out in the first article while still complying by the specification.  There is no good reason why an algorithm unacceptable to the application must not be rejected as it does more harm than good and all popular library implementations interpret it as such.",
    "submit_date": "2019-11-13",
    "submitter_name": "Erdem Memisyazici",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "6622",
    "doc-id": "RFC7519",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "11",
    "orig_text": "All the security considerations in the JWS specification also apply\r\n   to JWT, as do the JWE security considerations when encryption is\r\n   employed.  In particular, Sections <a href=\"#section-10.12\">10.12</a>",
    "correct_text": "All the security considerations in the JWS specification also apply\r\n   to JWT, as do the JWE security considerations when encryption is\r\n   employed.  In particular, Sections <a href=\"/doc/html/rfc7515#section-10.12\">10.12</a>",
    "notes": "The link appears to be broken. It is intended to point to rfc7515#section-10.12 whereas it is pointing to the non-existent section of the same document.\n --VERIFIER NOTES-- \nThe \"text\" publication format (the only official format for RFCs prior to 8650) does not include HTML links, so the \"original text\" section of this report does not match the version of the RFC that this tool is used for.  Accordingly, the submission has to be rejected as invalid.",
    "submit_date": "2021-06-25",
    "submitter_name": "Padmanarayanan SR",
    "verifier_id": "159",
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2021-07-03 17:54:53"
  },
  {
    "errata_id": "7720",
    "doc-id": "RFC7519",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.1.6",
    "orig_text": "4.1.6.  \"iat\" (Issued At) Claim\r\n\r\nThe \"iat\" (issued at) claim identifies the time at which the JWT was\r\nissued.  This claim can be used to determine the age of the JWT.  Its\r\nvalue MUST be a number containing a NumericDate value.  Use of this\r\nclaim is OPTIONAL.",
    "correct_text": "4.1.6.  \"iat\" (Issued At) Claim\r\n\r\nThe \"iat\" (issued at) claim identifies the time at which the JWT was\r\nissued.  This claim can be used to determine the age of the JWT.  Its\r\nvalue MUST be a number containing a NumericDate value.  Use of this\r\nclaim is OPTIONAL. Implementors MUST NOT reject otherwise-valid JWTs\r\nwith \"iat\" claims that appear to be from the future; token issuers\r\ndesiring this behavior may require it by including an \"nbf\" claim.",
    "notes": "There is substantial confusion and disagreement among JWT library implementors about whether to reject JWTs with `iat` claims that appear to be from the future due to clock drift. This confusion has led to over half a dozen Github issues & PRs over the years in libraries in many different ecosystems, and lots of strong disagreement among library developers and users.\r\n\r\nBased on a sample of the top Google search results for jwt client libraries in 11 different language ecosystems, the majority (7) of the libraries sampled do not reject future `iat` claims, while the remaining 4 *do* reject future `iat` claims by default. Of those 4 who do, *all* of them have had Github issues filed (by different unique users) in which the user was having a JWT unexpectedly rejected by a token validator using the library whose clock had drifted from that of the token issuer enough to trigger `iat`-based rejection.\r\n\r\nI propose we update the spec to explicitly prohibit rejection of future-`iat` JWTs (especially since token issuers have always been able to opt into this behavior using an `nbf` claim). Since this RFC has been published and cannot be edited, a new superseding RFC will have to be published and this one deprecated in order for the suggested change to make it out of the errata and into an actual RFC doc.\r\n\r\nI'm not sure if this merits a full RFC republish -- but as a data point for impact consideration, it's worth noting that this confusion has almost certainly wasted at least multiple hours per person (on average) of *dozens* of developers' time over the years, and led to at least half a dozen production bugs that I've seen mentioned. One of these bugs cropped up in my own organization on 2023-11-31 and has been observed previously but was misunderstood and not resolved; the 2023-11-31 occurence involved 10+ people in discussion. One Github issue I saw described an elongated full web server outage attributed to this confusion which cropped up during a leap-second-related clock drift issue. I'm filing this errata request on calendar day 3+ of discussing this issue in my organization (if you include past times this issue has cropped up).\r\n\r\nThanks for your consideration! I look forward to hearing back.",
    "submit_date": "2023-12-01",
    "submitter_name": "Timothy Vergenz",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "8060",
    "doc-id": "RFC7519",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "7.2",
    "orig_text": "   5.   Verify that the resulting JOSE Header includes only parameters\r\n        and values whose syntax and semantics are both understood and\r\n        supported or that are specified as being ignored when not\r\n        understood.",
    "correct_text": "   5.   Verify that the resulting JOSE Header according to RFC7515 or RFC7516.",
    "notes": "Validation step 5 in section 7.2 of RFC 7519 states that header parameters should only be ignored if they are explicitly specified as needing to be ignored. \r\n\r\nThis is contrary to step 7 in section 7.2 which requires that the processing rules of RFC 1515 be used if the JWT is a JWS (defined in RFC 1515). RFC 7515 does not include any special provisions for only ignoring header parameters if they are specified as being ignored, but instead requires all header parameters to be ignored if they are not understood (repeated below for convenience). \r\n\r\n\"Unless listed as a critical Header Parameter, per\r\n   Section 4.1.11, all Header Parameters not defined by this\r\n   specification MUST be ignored when not understood.\"\r\n\r\nA discussion with the authors at IETF 120 confirmed that all header parameters that are not understood must be ignored.\r\n\r\nThe proposed errata aims to clarify that if the JWT is a JWS, the processing rules of RFC 7151 should apply (including ignoring header parameters that are not understood). This is consistent with point 7.2, which requires that RFC 7515 [JWS] rules applies and avoids the impression that a new requirement on when parameters are ignored is being introduced in (i.e. the need to be explicitly defined as needing to be ignored).",
    "submit_date": "2024-07-31",
    "submitter_name": "Pieter Kasselman",
    "verifier_id": "179",
    "verifier_name": "Deb Cooley",
    "update_date": "2025-04-03 10:29:08"
  },
  {
    "errata_id": "8225",
    "doc-id": "RFC7519",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7.2",
    "orig_text": "   7.   Depending upon whether the JWT is a JWS or JWE, there are two\r\n        cases:\r\n\r\n        *  If the JWT is a JWS, follow the steps specified in [JWS] for\r\n           validating a JWS.  Let the Message be the result of base64url\r\n           decoding the JWS Payload.\r\n\r\n        *  Else, if the JWT is a JWE, follow the steps specified in\r\n           [JWE] for validating a JWE.  Let the Message be the resulting\r\n           plaintext.\r\n\r\n   8.   If the JOSE Header contains a \"cty\" (content type) value of\r\n        \"JWT\", then the Message is a JWT that was the subject of nested\r\n        signing or encryption operations.  In this case, return to Step\r\n        1, using the Message as the JWT.\r\n\r\n   9.   Otherwise, base64url decode the Message following the\r\n        restriction that no line breaks, whitespace, or other additional\r\n        characters have been used.\r\n\r\n   10.  Verify that the resulting octet sequence is a UTF-8-encoded\r\n        representation of a completely valid JSON object conforming to\r\n        RFC 7159 [RFC7159]; let the JWT Claims Set be this JSON object.",
    "correct_text": "   7.   Depending upon whether the JWT is a JWS or JWE, there are two\r\n        cases:\r\n\r\n        *  If the JWT is a JWS, follow the steps specified in [JWS] for\r\n           validating a JWS.  Let the Message be the result of base64url\r\n           decoding the JWS Payload.\r\n\r\n        *  Else, if the JWT is a JWE, follow the steps specified in\r\n           [JWE] for validating a JWE.  Let the Message be the resulting\r\n           plaintext.\r\n\r\n   8.   If the JOSE Header contains a \"cty\" (content type) value of\r\n        \"JWT\", then the Message is a JWT that was the subject of nested\r\n        signing or encryption operations.  In this case, return to Step\r\n        1, using the Message as the JWT.\r\n\r\n   9.   Verify that the resulting octet sequence is a UTF-8-encoded\r\n        representation of a completely valid JSON object conforming to\r\n        RFC 7159 [RFC7159]; let the JWT Claims Set be this JSON object.",
    "notes": "If the JWT is a JWS, then the Message, as defined in step (7), is already base64url decoded.\r\n\r\nIf the JWT is a JWE, then the Message, defined as the resulting plaintext in step (7) is not base64url encoded at all per [JWE].\r\n\r\nRepeating the base64url decode operation here would yield a bad octet sequence.\r\n\r\nThe decoding instructions regarding line breaks, whitespace, and other characters, are also already part of the validations steps in [JWS] and may be redundant here. Otherwise, they could be moved to the relevant passage about base64url decryption in step (7).",
    "submit_date": "2024-12-31",
    "submitter_name": "Alex Giannakakos",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "8388",
    "doc-id": "RFC7519",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "13.2",
    "orig_text": "   [POSIX.1]  IEEE, \"The Open Group Base Specifications Issue 7\", IEEE\r\n              Std 1003.1, 2013 Edition, 2013,\r\n              <http://pubs.opengroup.org/onlinepubs/9699919799/\r\n              basedefs/V1_chap04.html#tag_04_15>.\r\n",
    "correct_text": "   [POSIX.1]  IEEE, \"The Open Group Base Specifications Issue 7\", IEEE\r\n              Std 1003.1, 2013 Edition, 2013,\r\n              <https://pubs.opengroup.org/onlinepubs/9699919799.2013edition/\r\n              basedefs/V1_chap04.html#tag_04_15>.\r\n",
    "notes": "The link points to the 2018 edition \"4.15 Scheduling Policy\", in that edition the section number changed from 4.15 to 4.16.  But the reference text is for the 2013 edition.\r\n\r\nThe 2013 edition is in 4.15:\r\nhttps://pubs.opengroup.org/onlinepubs/9699919799.2013edition/basedefs/V1_chap04.html#tag_04_15\r\n\r\nThe 2018 edition is in 4.16:\r\nhttps://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16\r\n\r\nThe 2024 edition is in 4.19:\r\nhttps://pubs.opengroup.org/onlinepubs/9799919799/basedefs/V1_chap04.html#tag_04_19",
    "submit_date": "2025-04-21",
    "submitter_name": "Robert Wallis",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  }
]
