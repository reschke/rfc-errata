[
  {
    "errata_id": "5675",
    "doc-id": "RFC8439",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "2.5.1",
    "orig_text": "for i=1 upto ceil(msg length in bytes / 16)\r\n   n = le_bytes_to_num(msg[((i-1)*16)..(i*16)] | [0x01])\r\n   a += n\r\n   a = (r * a) % p\r\n   end",
    "correct_text": "for i=1 upto floor(msg length in bytes / 16)\r\n   j = min(i*16-1, msg length in bytes - 1)\r\n   n = le_bytes_to_num(msg[((i-1)*16)..j] | [0x01])\r\n   a += n\r\n   a = (r * a) % p\r\n   end\r\n",
    "notes": "Corection for lengths of msg blocks (full blocks are of size 16, NOT 17 and last blocks of size != 16 have to be treated separately).\n --VERIFIER NOTES-- \n   Rejected in favour of errata 5689.",
    "submit_date": "2019-03-25",
    "submitter_name": "Stefan Heiss",
    "verifier_id": "163",
    "verifier_name": "Colin Perkins",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5689",
    "doc-id": "RFC8439",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.5.1",
    "orig_text": "for i=1 upto ceil(msg length in bytes / 16)\r\n   n = le_bytes_to_num(msg[((i-1)*16)..(i*16)] | [0x01])\r\n   a += n\r\n   a = (r * a) % p\r\n   end\r\n",
    "correct_text": "for i=1 upto ceil(msg length in bytes / 16)\r\n   j = min(i*16-1, msg length in bytes - 1)\r\n   n = le_bytes_to_num(msg[((i-1)*16)..j] | [0x01])\r\n   a += n\r\n   a = (r * a) % p\r\n   end\r\n",
    "notes": "Correction of Errata 5675",
    "submit_date": "2019-04-11",
    "submitter_name": "Stefan Heiss",
    "verifier_id": "163",
    "verifier_name": "Colin Perkins",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5989",
    "doc-id": "RFC8439",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.4.1",
    "orig_text": "encrypted_message +=  block ^ key_stream\r\n...\r\nencrypted_message += (block^key_stream)[0..len(plaintext)%64]",
    "correct_text": "encrypted_message |= block ^ key_stream\r\n...\r\nencrypted_message |= (block^key_stream)[0..len(plaintext)%64]",
    "notes": "The encrypted_message is the result of concatenation of blocks.\r\n\"|\" and \"|=\" are used for concatenation elsewhere in the document, changing \"+=\" to \"|=\" will reduce ambiguity. ",
    "submit_date": "2020-02-26",
    "submitter_name": "Lê Minh Đăng",
    "verifier_id": "168",
    "verifier_name": "Stanislav Smyshlyaev",
    "update_date": "2021-04-28 06:48:23"
  },
  {
    "errata_id": "6025",
    "doc-id": "RFC8439",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "3",
    "orig_text": "A constant-time but not optimal approach would be to naively implement the arithmetic operations for 288-bit integers, because even a naive implementation will not exceed 2^288 in the multiplication of (acc+block) and r.\r\n",
    "correct_text": "It is possible to create a constant-time, but not optimal, implementation by implementing arithmetic operations for 256-bit integers, because even a naive implementation will not exceed 2^256 in the multiplication of (acc+block) and r (note that we have r < 2^124 because r is \"clamped\").\r\n",
    "notes": "There are two issues 1) 288 bits is too big, and 2) a naive implementation of 288 bit integer arithmetic isn't necessarily constant time.\r\n\r\n#1:  288 seems to be tied to the machine int size and assumes 32-bit integers (288 is nine 32-bit integers).  It is probably better to give a number independent of the machine int size. It is possible to compute Poly1305 using 255 bit arithmetic. Padded blocks of the message are in the range 2^8, 2^8 +1,..., 2^129 -1. Assuming that the partial reduction step always reduces the accumulator to 130 bits, we have acc < 2^130, so acc+block < 2^131. r is a 16 byte value, but some of its bits are \"clampled\", so we have r < 2^124. Thus (acc+block)*r < 2^255; so we can get by with 255 bit big-integer arithmetic (probably 256 bits is more convenient to work with). \r\n\r\n#2:  big-integer arithmetic can be implemented in constant time, but perhaps not in a obvious or naive way.  Keeping things constant time seems to depend on the characteristics of the underlying processor.",
    "submit_date": "2020-03-21",
    "submitter_name": "James Muir",
    "verifier_id": "168",
    "verifier_name": "Stanislav Smyshlyaev",
    "update_date": "2021-11-16 23:30:55"
  },
  {
    "errata_id": "6257",
    "doc-id": "RFC8439",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "2.5.2",
    "orig_text": "Adding s, we get this number, and serialize if to get the tag:",
    "correct_text": "Adding s, we get this number, and serialize it to get the tag:",
    "notes": "It's a trivial typo. Change \"if\" to \"it\".",
    "submit_date": "2020-08-18",
    "submitter_name": "Alan Presser",
    "verifier_id": "168",
    "verifier_name": "Stanislav Smyshlyaev",
    "update_date": "2021-04-13 05:22:08"
  },
  {
    "errata_id": "6569",
    "doc-id": "RFC8439",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "2.3",
    "orig_text": "o  A 32-bit block count parameter, treated as a 32-bit little-endian integer.",
    "correct_text": "o  A 32-bit block count parameter, treated as a 32-bit integer.",
    "notes": "The block count is not used as a little-endian integer. An example of this can be seen in the example test vector in section 2.3.2, where Block Count = 1, but the block count word of the initial state is 00000001.\r\n\r\n\r\nHold for document update.\r\n\r\nErrata 6569 clarifies that the 32-bit block count is not little-endian, as originally described, improving accuracy in the ChaCha20 and Poly1305 specifications. While minor, this clarification helps developers accurately interpret block counts. Low priority and held for document update. - CFRG co-chair",
    "submit_date": "2021-05-03",
    "submitter_name": "David Reed",
    "verifier_id": "182",
    "verifier_name": "Nick Sullivan",
    "update_date": "2025-01-18 10:56:43"
  },
  {
    "errata_id": "6989",
    "doc-id": "RFC8439",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "2.8.2",
    "orig_text": "Poly1305 r =  455e9a4057ab6080f47b42c052bac7b",
    "correct_text": "Poly1305 r = 8455e9a4057ab6080f47b42c052bac7b",
    "notes": "fist nibble of r appears to be missing",
    "submit_date": "2022-06-10",
    "submitter_name": "Mike Markowitz",
    "verifier_id": "2",
    "verifier_name": null,
    "update_date": "2022-06-13 16:36:28"
  },
  {
    "errata_id": "7880",
    "doc-id": "RFC8439",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "2.4.1",
    "orig_text": "encrypted_message |= (block^key_stream)[0..len(plaintext)%64]\r\n",
    "correct_text": "encrypted_message |= (block^key_stream)[0..(len(plaintext)%64)-1]",
    "notes": "If the plaintext size is not a multiple of 64 bytes, there is an off-by-one error in appending the final block of the encrypted message. In the original version, the encrypted message would always be one byte larger than the plaintext.\r\n\r\nThe corrected version ensures that the encrypted message size is always equal to the plaintext size.\r\n\r\nFor completeness: If the plaintext size is a multiple of 64 bytes, the second part of the code is skipped. Hence, this off-by-one error is not triggered in that specific case.\r\n\r\n(Non-)relation to correction 5989: The \"original text\", as quoted here, assumes that correction 5989 has already been applied. Correction 5989 deals with a different issue of this line of code, namely, the replacement of \"+=\" by \"|=\". This is completely orthogonal to the off-by-one error described here.",
    "submit_date": "2024-04-03",
    "submitter_name": "Volker Diels-Grabsch",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  }
]
