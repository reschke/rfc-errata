[
  {
    "errata_id": "3395",
    "doc-id": "RFC6386",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "20.16./p.239",
    "orig_text": "   void\r\n   vp8_dixie_tokens_process_row(struct vp8_decoder_ctx *ctx,\r\n                                unsigned int            partition,\r\n                                unsigned int            row,\r\n                                unsigned int            start_col,\r\n                                unsigned int            num_cols)\r\n   {\r\n       struct token_decoder *tokens = &ctx->tokens[partition];\r\n       short              coeffs = tokens->coeffs + 25 * 16 * start_col;",
    "correct_text": "   void\r\n   vp8_dixie_tokens_process_row(struct vp8_decoder_ctx *ctx,\r\n                                unsigned int            partition,\r\n                                unsigned int            row,\r\n                                unsigned int            start_col,\r\n                                unsigned int            num_cols)\r\n   {\r\n       struct token_decoder *tokens = &ctx->tokens[partition];\r\n       short              *coeffs = tokens->coeffs + 25 * 16 * start_col;",
    "notes": "It seems \"coeffs\" should be a pointer to a short instead of a short.",
    "submit_date": "2012-10-30",
    "submitter_name": "Thomas Butter",
    "verifier_id": "126",
    "verifier_name": "Nevil Brownlee",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5534",
    "doc-id": "RFC6386",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "19.1",
    "orig_text": "unsigned char *c = pbi->source;\r\nunsigned int tmp;\r\n\r\ntmp = (c[2] << 16) | (c[1] << 8) | c[0];\r\n\r\nkey_frame = tmp & 0x1;\r\nversion = (tmp >> 1) & 0x7;\r\nshow_frame = (tmp >> 4) & 0x1;\r\nfirst_part_size = (tmp >> 5) & 0x7FFFF;",
    "correct_text": "unsigned char *c = pbi->source;\r\nunsigned int tmp;\r\n\r\ntmp = (c[2] << 16) | (c[1] << 8) | c[0];\r\n\r\nkey_frame = !(tmp & 0x1);\r\nversion = (tmp >> 1) & 0x7;\r\nshow_frame = (tmp >> 4) & 0x1;\r\nfirst_part_size = (tmp >> 5) & 0x7FFFF;",
    "notes": "In section 9.1, where the frame tag is described, the field for the key frame is defined as \"A 1-bit frame type (0 for key frames, 1 for interframes).\"\r\n\r\nThe code block in section 19.1 interprets the bit in the opposite way: 1 for key frames and 0 for interframes.",
    "submit_date": "2018-10-18",
    "submitter_name": "Ard Oerlemans",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "7370",
    "doc-id": "RFC6386",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "19.1",
    "orig_text": "The start_code is a constant 3-byte pattern having value 0x9d012a.",
    "correct_text": "The start_code is a constant 3-byte pattern having value 0x2a019d.",
    "notes": "The bytes in the file are 9D 01 2A, but if they are read little-endian like `tmp = (c[2] << 16) | (c[1] << 8) | c[0];` as is done for frame_tag just before, then start_code will end up as 0x2a019d in an uint32_t.\r\n\r\nAlternatively, it could say \"...having value 0x9d 0x01 0x2a\".",
    "submit_date": "2023-02-25",
    "submitter_name": "Nico Weber",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7519",
    "doc-id": "RFC6386",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "9.3",
    "orig_text": "       a.  L(1), the mode of segment feature data\r\n           (segment_feature_mode), can be absolute-value mode (0) or\r\n           delta value mode (1).",
    "correct_text": "       a.  L(1), the mode of segment feature data\r\n           (segment_feature_mode), can be delta value mode (0) or\r\n           absolute-value mode (1).",
    "notes": "9.3 lists the meanings of the bits the wrong way round.\r\n\r\nSection 19.2 has it the right way round:\r\n\r\n\"\"\"\r\n   o  segment_feature_mode indicates the feature data update mode, 0 for\r\n      delta and 1 for the absolute value\r\n\"\"\"\r\n\r\nThat is, at the moment two sections in the spec directly contradict each other. Section 19.2 is right, section 9.3 is wrong from what I can tell.",
    "submit_date": "2023-05-22",
    "submitter_name": "Nico Weber",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7903",
    "doc-id": "RFC6386",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "13.2",
    "orig_text": " -dct_cat1, -dct_cat2, /* cat1 =  \"111100\",\r\n                                  cat2 = \"111101\" */\r\n        18, 20,\r\n         -dct_cat3, -dct_cat4, /* cat3 = \"1111100\",\r\n                                  cat4 = \"1111101\" */\r\n         -dct_cat5, -dct_cat6  /* cat4 = \"1111110\",\r\n                                  cat4 = \"1111111\" */",
    "correct_text": " -dct_cat1, -dct_cat2, /* cat1 =  \"111100\",\r\n                                  cat2 = \"111101\" */\r\n        18, 20,\r\n         -dct_cat3, -dct_cat4, /* cat3 = \"1111100\",\r\n                                  cat4 = \"1111101\" */\r\n         -dct_cat5, -dct_cat6  /* cat5 = \"1111110\",\r\n                                  cat6 = \"1111111\" */",
    "notes": "The last two bit strings are for categories 5 and 6; only the preceding one is for category 4.",
    "submit_date": "2024-04-21",
    "submitter_name": "Felix Pahl",
    "verifier_id": "157",
    "verifier_name": "Eliot Lear",
    "update_date": "2024-12-01 23:04:03"
  },
  {
    "errata_id": "7904",
    "doc-id": "RFC6386",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "19.2",
    "orig_text": " token_prob_update()                               | Type  |\r\n   | ------------------------------------------------- | ----- |\r\n   | for (i = 0; i < 4; i++) {                         |       |\r\n   |   for (j = 0; j < 8; j++) {                       |       |\r\n   |     for (k = 0; k < 3; k++) {                     |       |\r\n   |       for (l = 0; l < 11; l++) {                  |       |\r\n   |         coeff_prob_update_flag                    | L(1)  |\r\n   |         if (coeff_prob_update_flag)               |       |\r\n   |           coeff_prob                              | L(8)  |\r\n   |       }                                           |       |\r\n   |     }                                             |       |\r\n   |   }                                               |       |\r\n   | }                                                 |       |\r\n",
    "correct_text": " token_prob_update()                               | Type  |\r\n   | ------------------------------------------------- | ----- |\r\n   | for (i = 0; i < 4; i++) {                         |       |\r\n   |   for (j = 0; j < 8; j++) {                       |       |\r\n   |     for (k = 0; k < 3; k++) {                     |       |\r\n   |       for (l = 0; l < 11; l++) {                  |       |\r\n   |         coeff_prob_update_flag                    | B(p)  |\r\n   |         if (coeff_prob_update_flag)               |       |\r\n   |           coeff_prob                              | L(8)  |\r\n   |       }                                           |       |\r\n   |     }                                             |       |\r\n   |   }                                               |       |\r\n   | }                                                 |       |\r\n",
    "notes": "The type of the flag coeff_prob_update_flag is given as L(1), which, according to the table in Section 8 on p. 25, means that this is a single literal bit that should be read with a 50/50 probability coded as 128.\r\n\r\nBut other parts of the RFC say that these flags are actually read with predetermined probabilities other than 128: Section 13.4 (“Token Probability Updates”) on p. 68 specifies these probabilities in the array coeff_update_probs, and the function decode_entropy_header in the reference implementation (file dixie.c, p. 138/139) uses them (in the array k_coeff_entropy_update_probs) to decode these flags. The current version of libwebp follows the reference implementation and uses these predetermined probabilities.\r\n\r\n According to the table on p. 25, the type of such a flag should be specified as B(p), not as L(1).",
    "submit_date": "2024-04-21",
    "submitter_name": "Felix Pahl",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7950",
    "doc-id": "RFC6386",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "12.3",
    "orig_text": "B[2][0] = B[3][2] = svg2p(E + 1); /* ( 3/2, -1) */",
    "correct_text": "B[2][0] = B[3][2] = avg2p(E + 1); /* ( 3/2, -1) */",
    "notes": "This is a typo; the call to avg2p computes the desired value, and svg2p is not defined.",
    "submit_date": "2024-05-22",
    "submitter_name": "Felix Pahl",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "8717",
    "doc-id": "RFC6386",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "20.4",
    "orig_text": "           if (dqf->quant_idx != q || quant_hdr->delta_update)",
    "correct_text": "           /* if (dqf->quant_idx != q || quant_hdr->delta_update) */",
    "notes": "In the reference decoder as-provided, in the event that the decoder has previously decoded a frame with a given yac_qi (`vp8_quant_hdr.q_index` in the code) and non-zero deltas, and in the next frame, `yac_qi` remains the same, but all deltas are not provided or are 0, then `quant_idx` will equal q and `delta_update` will be 0, so the table update will not be applied, leading to the previously decoded deltas being used.\r\n\r\nlibvpx v1.15.2 `vp8/decoder/decodeframe.c` lines 1083 and following (and the equivalent location in the first commit of libvpx) handles a similar optimization; however, the delta values are compared to their previous values in the 'get_delta_q' function.\r\n\r\nI believe the error in the reference decoder stems from a misoptimization attempting to 'lay the groundwork' for the same prevention of rebuilding of optimized dequantization tables.\r\n\r\nThese tables do not exist in the reference decoder, so the code being guarded here is relatively trivial.\r\n\r\nI have tested this change on a personal stripped-down fork of the libvpx 'dixie' branch (the closest 'relative' to the reference decoder that can easily be compiled) in order to confirm it does not immediately break decoding, but my test vector library is not particularly extensive, and the bug is one that would likely have to be triggered by chance in a normal encoding.\r\nStill, I believe the evidence in libvpx points to this errata being correct.\r\n\r\nlibvpx's interpretation appears to better align with the specification (section 9.6. Dequantization Indices), but not with the reference code; as it is the major shipping implementation, and as the behaviour doesn't really make sense, I'm inclined to believe libvpx is correct.\r\n\r\nThe `get_delta_q` function's use and behaviour is present in the optimized decoder since the 'Initial WebM release' commit, which indicates that the 'non-sticky' behaviour appears to have superseded the reference decoder.\r\n\r\nPlease note that only removing/commenting this line creates unused code which would not be correctable without a deeper series of changes.\r\nThe effects of disabling this optimization in this decoder appear to be trivial (simple once-per-frame logic), but in the 'full' decoder the process is a little more expensive for what appears to be dequantizer optimization reasons.",
    "submit_date": "2026-01-23",
    "submitter_name": "20kdc",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  }
]
