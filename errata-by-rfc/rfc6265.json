[
  {
    "errata_id": 3430,
    "doc-id": "RFC6265",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "4.1.1",
    "orig_text": " max-age-av        = \"Max-Age=\" non-zero-digit *DIGIT\r\n                       ; In practice, both expires-av and max-age-av\r\n                       ; are limited to dates representable by the\r\n                       ; user agent.\r\n non-zero-digit    = %x31-39\r\n                       ; digits 1 through 9\r\n",
    "correct_text": " max-age-av        = \"Max-Age=\" 1*DIGIT\r\n                       ; In practice, both expires-av and max-age-av\r\n                       ; are limited to dates representable by the\r\n                       ; user agent.\r\n",
    "notes": "The current text forbids a server to send Max-Age=0.\n --VERIFIER NOTES-- \nThat is correct.  As noted in the introduction, what servers should do and what clients should do are not the same.  The ABNF in Section 4 limits the server intentionally, to maximize compatibility with deployed clients.  See this text in the Introduction:\r\n\r\n   To maximize interoperability with user agents, servers SHOULD limit\r\n   themselves to the well-behaved profile defined in Section 4 when\r\n   generating cookies.\r\n\r\n   User agents MUST implement the more liberal processing rules defined\r\n   in Section 5, in order to maximize interoperability with existing\r\n   servers that do not conform to the well-behaved profile defined in\r\n   Section 4.\r\n   ",
    "submit_date": "2012-12-13",
    "submitter_name": "Zhong Yu",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3444,
    "doc-id": "RFC6265",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.1.1",
    "orig_text": "path-value        = <any CHAR except CTLs or \";\">\r\nextension-av      = <any CHAR except CTLs or \";\">\r\n",
    "correct_text": "path-value        = * <any CHAR except CTLs or \";\">\r\nextension-av      = * <any CHAR except CTLs or \";\">\r\n",
    "notes": "A better correction could also be:\r\n\r\n   path-value        = *av-octet\r\n   extension-av      = *av-octet\r\n   av-octet          = %x20-3A / %x3C-7E\r\n                     ; any CHAR except CTLs or \";\"\r\n",
    "submit_date": "2013-01-06",
    "submitter_name": "Eran Hammer",
    "verifier_id": 127,
    "verifier_name": "Pete Resnick",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3663,
    "doc-id": "RFC6265",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "5.1.4",
    "orig_text": "A request-path path-matches a given cookie-path if at least one of\r\nthe following conditions holds:\r\n\r\no  The cookie-path and the request-path are identical.",
    "correct_text": "A request-path path-matches a given cookie-path if at least one of\r\nthe following conditions holds:\r\n\r\no  The cookie-path and the request-path are identical.  Note that this\r\n   differs from the rules in RFC 3986 for equivalence of the path\r\n   component, and hence two equivalent paths can have different\r\n   cookies.",
    "notes": "The \"identical\" rule differs from the URI equivalence rule(s) in RFC 3986\r\nsections 6.2 and 2.1 (e.g., \"If two URIs differ only in the case of hexadecimal\r\ndigits used in percent-encoded octets, they are equivalent.\")  The fact that\r\nequivalent URIs have different cookies arguably violates the principle of\r\nleast astonishment.  To avoid significant confusion and prevent such surprise,\r\nthis fact should be noted so that it is at least not unexpected.",
    "submit_date": "2013-06-17",
    "submitter_name": "Dave Thaler",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3765,
    "doc-id": "RFC6265",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "4.1.1",
    "orig_text": "Servers SHOULD NOT include more than one Set-Cookie header field in\r\nthe same response with the same cookie-name.  (See Section 5.2 for\r\nhow user agents handle this case.)\r\n\r\n",
    "correct_text": "Servers MUST NOT include more than one Set-Cookie header field in\r\nthe same response.",
    "notes": "The HTTP specification (RFC 2616) says in its section 4.2: \"Multiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e., #(values)]. [...]\"\r\n\r\nSince the mentioned condition is not fulfilled in the case of Set-Cookie headers, only one Set-Cookie header is permissible in an HTTP message.\r\n\r\nThis also applies to the third example in section 3.1, even though it is not clearly specified there whether or not the two Set-Cookies originate from the same server response.\r\n\r\nOn the internet many HTTP messages contain multiple Set-Cookie headers, and this seems to make sense in order to avoid additional roundtrips. This, however, (1) does not match the HTTP specification, see above, and therefore (2) cannot be used with implementations stating that they were HTTP compatible and consequently only allow a single Set-Cookie header per response. Clearly, this is not a defect of those implementations, but of the specifications which are at least mistakable (if not contradictory).\n --VERIFIER NOTES-- \nPart of the point of RFC 6265 is to document how cookies are actually\r\nused on the Internet.  As is noted in the introduction, existing use\r\ndoesn't always conform to what it should. Â In particular, we know that\r\nRFC 6265 doesn't always match up with RFC 2616, because the actual usage\r\nisn't always strictly correct.\r\n\r\nThe variation from RFC 2616 that this report notes is intentional,\r\ndocumenting the existing usage, and this errata report is rejected.",
    "submit_date": "2013-10-25",
    "submitter_name": "Johannes Knaupp",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3931,
    "doc-id": "RFC6265",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "5.1.1",
    "orig_text": "   The user agent MUST use an algorithm equivalent to the following\r\n   algorithm to parse a cookie-date.  Note that the various boolean\r\n   flags defined as a part of the algorithm (i.e., found-time, found-\r\n   day-of-month, found-month, found-year) are initially \"not set\".\r\n\r\n   1.  Using the grammar below, divide the cookie-date into date-tokens.\r\n\r\n   cookie-date     = *delimiter date-token-list *delimiter\r\n   date-token-list = date-token *( 1*delimiter date-token )\r\n   date-token      = 1*non-delimiter\r\n\r\n   delimiter       = %x09 / %x20-2F / %x3B-40 / %x5B-60 / %x7B-7E\r\n   non-delimiter   = %x00-08 / %x0A-1F / DIGIT / \":\" / ALPHA / %x7F-FF\r\n   non-digit       = %x00-2F / %x3A-FF\r\n\r\n   day-of-month    = 1*2DIGIT ( non-digit *OCTET )\r\n   month           = ( \"jan\" / \"feb\" / \"mar\" / \"apr\" /\r\n                       \"may\" / \"jun\" / \"jul\" / \"aug\" /\r\n                       \"sep\" / \"oct\" / \"nov\" / \"dec\" ) *OCTET\r\n   year            = 2*4DIGIT ( non-digit *OCTET )\r\n   time            = hms-time ( non-digit *OCTET )\r\n   hms-time        = time-field \":\" time-field \":\" time-field\r\n   time-field      = 1*2DIGIT\r\n\r\n   2.  Process each date-token sequentially in the order the date-tokens\r\n       appear in the cookie-date:\r\n\r\n       1.  If the found-time flag is not set and the token matches the\r\n           time production, set the found-time flag and set the hour-\r\n           value, minute-value, and second-value to the numbers denoted\r\n           by the digits in the date-token, respectively.  Skip the\r\n           remaining sub-steps and continue to the next date-token.\r\n\r\n       2.  If the found-day-of-month flag is not set and the date-token\r\n           matches the day-of-month production, set the found-day-of-\r\n           month flag and set the day-of-month-value to the number\r\n           denoted by the date-token.  Skip the remaining sub-steps and\r\n           continue to the next date-token.\r\n\r\n       3.  If the found-month flag is not set and the date-token matches\r\n           the month production, set the found-month flag and set the\r\n           month-value to the month denoted by the date-token.  Skip the\r\n           remaining sub-steps and continue to the next date-token.\r\n\r\n       4.  If the found-year flag is not set and the date-token matches\r\n           the year production, set the found-year flag and set the\r\n           year-value to the number denoted by the date-token.  Skip the\r\n           remaining sub-steps and continue to the next date-token.",
    "correct_text": "   The user agent MUST use an algorithm equivalent to the following\r\n   algorithm to parse a cookie-date.  Note that the various boolean\r\n   flags defined as a part of the algorithm (i.e., found-day-of-week,\r\n   found-time, found-day-of-month, found-month, found-year) are \r\n   initially \"not set\".\r\n\r\n   1.  Using the grammar below, divide the cookie-date into date-tokens.\r\n\r\n   cookie-date     = *delimiter date-token-list *delimiter\r\n   date-token-list = date-token *( 1*delimiter date-token )\r\n   date-token      = 1*non-delimiter\r\n\r\n   delimiter       = %x09 / %x20-2F / %x3B-40 / %x5B-60 / %x7B-7E\r\n   non-delimiter   = %x00-08 / %x0A-1F / DIGIT / \":\" / ALPHA / %x7F-FF\r\n   non-digit       = %x00-2F / %x3A-FF\r\n\r\n   day-of-week     = weekday / wkday\r\n   wkday           = \"mon\" / \"tue\" / \"wed\" / \"thu\" / \"fri\" / \"sat\" /\r\n                     \"sun\"\r\n   weekday         = \"monday\" / \"tuesday\" / \"wednesday\" / \"thursday\" /\r\n                     \"friday\" / \"saturday\" / \"sunday\"\r\n   day-of-month    = 1*2DIGIT ( non-digit *OCTET )\r\n   month           = ( \"jan\" / \"feb\" / \"mar\" / \"apr\" /\r\n                       \"may\" / \"jun\" / \"jul\" / \"aug\" /\r\n                       \"sep\" / \"oct\" / \"nov\" / \"dec\" ) *OCTET\r\n   year            = 2*4DIGIT ( non-digit *OCTET )\r\n   time            = hms-time ( non-digit *OCTET )\r\n   hms-time        = time-field \":\" time-field \":\" time-field\r\n   time-field      = 1*2DIGIT\r\n\r\n   2.  Process each date-token sequentially in the order the date-tokens\r\n       appear in the cookie-date:\r\n\r\n       1.  If the found-day-of-week flag is not set and the token \r\n           matches the day-of-week production, set found-day-of-week \r\n           flag. Skip the remaining steps and continue to the next \r\n           date-token.\r\n\r\n       2.  If the found-time flag is not set and the token matches the\r\n           time production, set the found-time flag and set the hour-\r\n           value, minute-value, and second-value to the numbers denoted\r\n           by the digits in the date-token, respectively.  Skip the\r\n           remaining sub-steps and continue to the next date-token.\r\n\r\n       3.  If the found-day-of-month flag is not set and the date-token\r\n           matches the day-of-month production, set the found-day-of-\r\n           month flag and set the day-of-month-value to the number\r\n           denoted by the date-token.  Skip the remaining sub-steps and\r\n           continue to the next date-token.\r\n\r\n       4.  If the found-month flag is not set and the date-token matches\r\n           the month production, set the found-month flag and set the\r\n           month-value to the month denoted by the date-token.  Skip the\r\n           remaining sub-steps and continue to the next date-token.\r\n\r\n       5.  If the found-year flag is not set and the date-token matches\r\n           the year production, set the found-year flag and set the\r\n           year-value to the number denoted by the date-token.  Skip the\r\n           remaining sub-steps and continue to the next date-token.",
    "notes": "4.1.1 defines \"sane-cookie-date\" as \"rfc1123-date, defined in [RFC2616], Section 3.3.1\". However, both RFC1123 and RFC2616 mandate that date starts with day of the week, and indeed, most servers send cookies where Expires starts with day of the week.\r\n\r\nIn this particular case (Expire field) the day-of-week part of the date is insignificant, and client MAY ignore it.\n --VERIFIER NOTES-- \nThe reporter misunderstood the algorithm at first, thinking that it would fail when it couldn't parse the weekday token.  In fact, the algorithm actually has the flexibility to ignore tokens it doesn't care about, and to handle tokens in any order.  So there's no error here.",
    "submit_date": "2014-03-24",
    "submitter_name": "Semyon Kholodnov",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4043,
    "doc-id": "RFC6265",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "5.1.4",
    "orig_text": "The user agent MUST use an algorithm equivalent to the following\r\nalgorithm to compute the default-path of a cookie:",
    "correct_text": "The user agent MUST use an algorithm equivalent to the following\r\nalgorithm to compute the default value for a cookie-path \r\n(and thereby matching the server-side semantics as defined in 4.1.2.4):",
    "notes": "The term \"default-path\" is not formally defined before and is quite misleading for the reader \r\n  A. going through the section 5.1.4 as it's only used there once and not again\r\n     until section 5.2.4 (once again) and 5.3 (once again).\r\n  B. not being a native English speaker\r\n\r\nFurthermore, the true meaning of the \"default-path\" only appears sometime after at section 5.2.4 where it's finally bound altogether. Therefore, my personal recommendation would be to also replace the other occurrences of the \"default-path\" terms by \"default cookie-path\"\n --VERIFIER NOTES-- \nThis report is actually an enhancement request.  The discussion of this report on the http-state mailing list should be reviewed if the document is ever revised.",
    "submit_date": "2014-07-06",
    "submitter_name": "Pierre Lepropre",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4044,
    "doc-id": "RFC6265",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 5.3,
    "orig_text": "Otherwise:\r\n\r\n   Set the cookie's persistent-flag to false.\r\n\r\n   Set the cookie's expiry-time to the latest representable\r\n   date.\r\n",
    "correct_text": "Otherwise:\r\n\r\n   Set the cookie's persistent-flag to false.\r\n\r\n   Set the cookie's expiry-time to the latest representable\r\n   date. This is a best-effort approach to ensure that the cookie \r\n   will effectively expire when \"the current session is over\" \r\n   (as defined by the user agent) and not anytime before.",
    "notes": "The second action item isn't necessarily obvious for an implementer/reader. If I got the intention right, then I believe it might improve the \"user-friendly\" rating of this document. Otherwise, it might still be beneficial to explicit a bit the reasoning behind that action.\n --VERIFIER NOTES-- \nThis report is actually an enhancement request.  The discussion of this report on the http-state mailing list should be reviewed if the document is ever revised.",
    "submit_date": "2014-07-06",
    "submitter_name": "Pierre Lepropre",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4148,
    "doc-id": "RFC6265",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "5.1.1",
    "orig_text": "   day-of-month    = 1*2DIGIT ( non-digit *OCTET )\r\n...\r\n   year            = 2*4DIGIT ( non-digit *OCTET )\r\n   time            = hms-time ( non-digit *OCTET )\r\n",
    "correct_text": "   day-of-month    = 1*2DIGIT [ non-digit *OCTET ]\r\n...\r\n   year            = 2*4DIGIT [ non-digit *OCTET ]\r\n   time            = hms-time [ non-digit *OCTET ]\r\n",
    "notes": "The trailing extra chars for these fields should be *optional*, not *required*.",
    "submit_date": "2014-10-28",
    "submitter_name": "Zhong Yu",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5518,
    "doc-id": "RFC6265",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "4.1.1",
    "orig_text": " cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\r\n                       ; US-ASCII characters excluding CTLs,\r\n                       ; whitespace DQUOTE, comma, semicolon,\r\n                       ; and backslash",
    "correct_text": " cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\r\n                       ; US-ASCII characters excluding CTLs,\r\n                       ; whitespace, DQUOTE, comma, semicolon,\r\n                       ; and backslash",
    "notes": "Missing comma separator between \"whitespace\" and \"DQUOTE\".",
    "submit_date": "2018-10-09",
    "submitter_name": "Peter Wu",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 6093,
    "doc-id": "RFC6265",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": 3,
    "orig_text": "Origin servers SHOULD NOT fold multiple Set-Cookie header fields into a single header field.  The usual mechanism for folding HTTP headers fields (i.e., as defined in [RFC2616]) might change the semantics of the Set-Cookie header field because the %x2C (\",\") character is used by Set-Cookie in a way that conflicts with such folding.\r\n\r\n",
    "correct_text": "Origin servers SHOULD NOT combine multiple Set-Cookie header fields into a single header field.  The usual mechanism for combining HTTP headers fields (i.e., as defined in [RFC2616]) might change the semantics of the Set-Cookie header field because the %x2C (\",\") character is used by Set-Cookie in a way that conflicts with such actions.",
    "notes": "RFC 6265 currently uses the verb \"folding\" when it refers to combining multiple header fields into one, which is ambiguous in the context of the HTTP/1 specs (both by RFC2616 and RFC 7230) where \"folding\" consistently refers to line folding, and the verb \"combine\" is used to describe merging same headers. Having a light HTTP knowledge, I naively started looking up \"folding\" in the HTTP specs, and was immediately confused by the results, others will probably be as well (especially is English is not their native tongue).\r\n\r\nExamples to prove this consistency:\r\n+ RFC 2616, Section 4.2, Message Headers, but searching for the for the word \"combine\" will bring up special cases.\r\n+ RFC 7230, Section 3.2.2, Field Order\r\n+ RFC 2616, Section 2.2, Basic Rules\r\n+ RFC 7230, Section 3.2.4, Field Parsing\r\n\r\nThank you!",
    "submit_date": "2020-04-12",
    "submitter_name": "Attila Gulyas",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  }
]
