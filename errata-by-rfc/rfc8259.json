[
  {
    "errata_id": "5210",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "GLOBAL",
    "orig_text": "Internet Engineering Task Force (IETF)                      T. Bray, Ed.\r\nRequest for Comments: 8259                                    Textuality\r\nObsoletes: 7159                                            December 2017\r\nCategory: Standards Track\r\nISSN: 2070-1721\r\n",
    "correct_text": "Internet Engineering Task Force (IETF)                      T. Bray, Ed.\r\nRequest for Comments: 8259                                    Textuality\r\nSTD: 90                                                    December 2017\r\nObsoletes: 7159\r\nCategory: Standards Track\r\nISSN: 2070-1721\r\n",
    "notes": "Missing \"STD\" entry in boilerplate.",
    "submit_date": "2017-12-16",
    "submitter_name": "Julian Reschke",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5218",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "12",
    "orig_text": "JSON is a subset of JavaScript",
    "correct_text": "JSON is nearly a subset of JavaScript",
    "notes": "JSON is not a subset of JavaScript: there are syntactically valid JSON texts that are not syntactically valid JavaScript. Namely, JSON strings can contain unescaped U+2028 LINE SEPARATOR or U+2029 PARAGRAPH SEPARATOR characters, while JavaScript string literals cannot. Thus, a sequence of characters U+0022 U+2028 U+0022 matches this RFC's 'string' production, but does not match ECMA-262's 'Expression' production.",
    "submit_date": "2017-12-28",
    "submitter_name": "Vasiliy Faronov",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5318",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "7",
    "orig_text": "      string = quotation-mark *char quotation-mark\r\n\r\n      char = unescaped /\r\n          escape (\r\n              %x22 /          ; \"    quotation mark  U+0022\r\n              %x5C /          ; \\    reverse solidus U+005C\r\n              %x2F /          ; /    solidus         U+002F\r\n              %x62 /          ; b    backspace       U+0008\r\n              %x66 /          ; f    form feed       U+000C\r\n              %x6E /          ; n    line feed       U+000A\r\n              %x72 /          ; r    carriage return U+000D\r\n              %x74 /          ; t    tab             U+0009\r\n              %x75 4HEXDIG )  ; uXXXX                U+XXXX\r\n\r\n      escape = %x5C              ; \\\r\n\r\n      quotation-mark = %x22      ; \"\r\n\r\n      unescaped = %x20-21 / %x23-5B / %x5D-10FFFF",
    "correct_text": "      string = quotation-mark *char quotation-mark\r\n\r\n      char = unescaped /\r\n          escape (\r\n              %x22 /          ; \"    quotation mark  U+0022\r\n              %x5C /          ; \\    reverse solidus U+005C\r\n              %x2F /          ; /    solidus         U+002F\r\n              %x62 /          ; b    backspace       U+0008\r\n              %x66 /          ; f    form feed       U+000C\r\n              %x6E /          ; n    line feed       U+000A\r\n              %x72 /          ; r    carriage return U+000D\r\n              %x74 /          ; t    tab             U+0009\r\n              %x75 4HEXDIG )  ; uXXXX                U+XXXX\r\n\r\n      escape = %x5C              ; \\\r\n\r\n      quotation-mark = %x22      ; \"\r\n\r\n      unescaped = %x20-21 / %x23-2E / %x30-5B / %x5D-10FFFF",
    "notes": "The solidus U+002F is listed as being escaped above, but is not excluded in the 'unescaped' sequence.",
    "submit_date": "2018-04-04",
    "submitter_name": "Joakim Erdfelt",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5853",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "11",
    "orig_text": "Note:  No \"charset\" parameter is defined for this registration.\r\n    Adding one really has no effect on compliant recipients.",
    "correct_text": "Note:  No \"charset\" parameter is defined for this registration.\r\n    JSON text is encoded as described in RFC 8259, Section 8.1.\r\n",
    "notes": "Last sentence of last note of section 11 should be amended, as it introduces confusion by going against other explicit statements, like the followings:\r\n * RFC8259 sect. 8.1 defines that inner encoding is UTF-8\r\n * RFC8259 sect. 11 defines no formal (optional/required) parameters for this registered type\r\n * RFC6838 sect. 4.2.1 defines the common usage of a \"charset\" parameter as a \"required\" one (which isn't the case here)\r\n * RFC6838 sect. 4.2.1 defines that \"charset\" should not be used if the inner payload already transports charset information (e.g. mandatory UTF-8, which is the case here)\r\n * RFC6838 sect. 4.2.1 defines a \"charset\" parameter only for subtypes of the \"text/*\" hierarchy (which isn't the case here)",
    "submit_date": "2019-09-05",
    "submitter_name": "Luca BRUNO",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "6208",
    "doc-id": "RFC8259",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "8.1",
    "orig_text": "In the interests of interoperability, implementations that parse JSON texts MAY ignore the presence of a byte order mark rather than treating it as an error.",
    "correct_text": "In the interests of interoperability, implementations that parse JSON texts MAY ignore the presence of a byte order mark or MAY interpret a byte order mark to indicate an alternate encoding rather than treating it as an error.",
    "notes": "The original line is copied from previous RFCs that specifically allowed alternate encodings.  In the context of a new, UTF-8 only restriction, interoperability provisions should also address interpreting legacy formats that predate the restriction.  By omission, readers may conclude that the *only* option for a BOM is to ignore or error.\n --VERIFIER NOTES-- \n   This is asking to revisit what we have consensus on, not a report of an error in the RFC.\r\nThe working group had extensive discussions on BOMs, and chose this particular working purposefully.",
    "submit_date": "2020-06-10",
    "submitter_name": "David Golden",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2020-06-10 07:38:37"
  },
  {
    "errata_id": "7307",
    "doc-id": "RFC8259",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "3",
    "orig_text": "      null  = %x6e.75.6c.6c      ; null ",
    "correct_text": "      null  = %x6e.75.6c.6c      ; null without quotation marks for numeric attributes and \"null\" for string attributes.",
    "notes": "It is not clear how to encode null values in JSON.\r\nSome are encoding all attributes as \"null\".\r\nSome are encoding all attributes as null without quotation marks\r\nSome are encoding string attributes as \"null\" and numeric attributes as null without quotation marks.\r\nhttps://json.org is mentioning \"null\". ECMA 262  is mentioning \"null\" for string and +0F for numeric attributes. However providing zero for a number instead of null is incorrect and provides wrong results (in BI).\n --VERIFIER NOTES-- \nThe original specification is clear as such, and this errata would make a change that breaks the format, and is against the original intent of the text.",
    "submit_date": "2023-01-13",
    "submitter_name": "Maxim Iurie",
    "verifier_id": "170",
    "verifier_name": "Francesca Palombini",
    "update_date": "2023-01-18 01:39:22"
  },
  {
    "errata_id": "7383",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "3.  Values",
    "orig_text": "      false = %x66.61.6c.73.65   ; false\r\n\r\n      null  = %x6e.75.6c.6c      ; null",
    "correct_text": "      false = %x66.61.6C.73.65   ; false\r\n\r\n      null  = %x6E.75.6C.6C      ; null",
    "notes": "Hex values should be capitalized https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1",
    "submit_date": "2023-03-12",
    "submitter_name": "Daniel Tegründe",
    "verifier_id": "2",
    "verifier_name": null,
    "update_date": "2023-04-27 16:24:06"
  },
  {
    "errata_id": "7600",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "6",
    "orig_text": "   The representation of numbers is similar to that used in most\r\n   programming languages.  A number is represented in base 10 using\r\n   decimal digits.  It contains an integer component that may be\r\n   prefixed with an optional minus sign, which may be followed by a\r\n   fraction part and/or an exponent part.  Leading zeros are not\r\n   allowed.",
    "correct_text": "   The representation of numbers is similar to that used in most\r\n   programming languages.  A number is represented in base 10 using\r\n   decimal digits.  It contains an integer component that may be\r\n   prefixed with an optional minus sign, which may be followed by a\r\n   fraction part and/or an exponent part.  Leading zeros in the\r\n   integer component beyond the units digit are not allowed.",
    "notes": "The original wording about leading zeros contradicts the documented ABNF grammar for JSON numbers in the following cases:\r\n- If the integer component is equal to 0 and the fractional component exists. (Examples: 0.1, 0.001)\r\n- In the exponent part, after the letter E or e or the optional sign. (Example: 1E01)",
    "submit_date": "2023-08-11",
    "submitter_name": "Guillaume Fortin-Debigaré",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7603",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "1",
    "orig_text": "   A string is a sequence of zero or more Unicode characters [UNICODE].",
    "correct_text": "   A string is a sequence of zero or more Unicode code points [UNICODE].",
    "notes": "Surrogate code points are not Unicode characters, as explained here: https://www.unicode.org/glossary/#surrogate_character\r\n\r\nHowever, a surrogate code point outside of a surrogate pair is allowed in JSON strings both in escaped and unescaped forms according to the ABNF grammar in section 7 and the warning in section 8.2, despite an UTF-8 incompatibility for the unescaped form. In addition, the original text contradicts ECMA-404 section 9, which states: \"A string is a sequence of Unicode code points wrapped with quotation marks (U+0022). All code points may be placed within the quotation marks except for the code points that must be escaped: quotation mark (U+0022), reverse solidus (U+005C), and the control characters U+0000 to U+001F. \"",
    "submit_date": "2023-08-13",
    "submitter_name": "Guillaume Fortin-Debigaré",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7617",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "6",
    "orig_text": "   Note that when such software is used, numbers that are integers and\r\n   are in the range [-(2**53)+1, (2**53)-1] are interoperable in the\r\n   sense that implementations will agree exactly on their numeric\r\n   values.",
    "correct_text": "   Note that when such software parses numbers as rational numbers in\r\n   decimal or scientific notation, they are interoperable in the sense\r\n   that implementations will agree exactly on their numeric values. In\r\n   particular, when such software is used, numbers that are integers and\r\n   are in the range [-(2**53)+1, (2**53)-1] are interoperable in that\r\n   sense.",
    "notes": "IEEE 754 does not consider negative zero and positive zero to be the same numeric value, even though it considers them equal. Despite this, JavaScript serializes negative zero as the JSON text \"0\", which contradicts the original text.\r\n\r\nMy suggested correction mentions \"rational numbers in decimal or scientific notation\" since it's never explicitly mentioned in the document how a number should be interpreted when parsed to maximize interoperability. This version addresses that concern at the same time.",
    "submit_date": "2023-08-25",
    "submitter_name": "Guillaume Fortin-Debigaré",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7650",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7",
    "orig_text": "      string = quotation-mark *char quotation-mark\r\n\r\n      char = unescaped /\r\n          escape (\r\n              %x22 /          ; \"    quotation mark  U+0022\r\n              %x5C /          ; \\    reverse solidus U+005C\r\n              %x2F /          ; /    solidus         U+002F\r\n              %x62 /          ; b    backspace       U+0008\r\n              %x66 /          ; f    form feed       U+000C\r\n              %x6E /          ; n    line feed       U+000A\r\n              %x72 /          ; r    carriage return U+000D\r\n              %x74 /          ; t    tab             U+0009\r\n              %x75 4HEXDIG )  ; uXXXX                U+XXXX",
    "correct_text": "      string = quotation-mark *json-char quotation-mark\r\n\r\n      json-char = unescaped /\r\n          escape (\r\n              %x22 /          ; \"    quotation mark  U+0022\r\n              %x5C /          ; \\    reverse solidus U+005C\r\n              %x2F /          ; /    solidus         U+002F\r\n              %x62 /          ; b    backspace       U+0008\r\n              %x66 /          ; f    form feed       U+000C\r\n              %x6E /          ; n    line feed       U+000A\r\n              %x72 /          ; r    carriage return U+000D\r\n              %x74 /          ; t    tab             U+0009\r\n              %x75 4HEXDIG )  ; uXXXX                U+XXXX",
    "notes": "RFC 5234 Section 2.1 \"Rule Naming\" notes that \"rule names are case insensitive\". It is explained that literal text strings enclosed in quotation marks are case insensitive, and have later been clarified by RFC 7405.\r\nIn RFC 5234 Appendix B, Section B.1 \"Core Rules\", the rule \"CHAR\" is already defined such that it constitutes the core of ABNF, thus no grammar can use those names regarding the previous explanation.\r\n\r\nThe goal of this errata is to propose an alternative for the \"char\" rule such that RFC 8259 can provide a valid grammar regarding the ABNF RFCs.",
    "submit_date": "2023-09-20",
    "submitter_name": "Lucas Tesson",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7673",
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7",
    "orig_text": "The representation of strings is similar to conventions used in the C family\r\nof programming languages.  A string begins and ends with quotation marks. All\r\nUnicode characters may be placed within the quotation marks, except for the\r\ncharacters that MUST be escaped: quotation mark, reverse solidus, and the\r\ncontrol characters (U+0000 through U+001F).",
    "correct_text": "The representation of strings is similar to conventions used in the C family\r\nof programming languages.  A string begins and ends with quotation marks.  All\r\nUnicode characters may be placed within the quotation marks, except for the\r\ncharacters that MUST be escaped: quotation mark, reverse solidus, and the\r\ncontrol characters (U+0000 through U+001F, U+007F, and U+0080 through\r\nU+009F).\r\n",
    "notes": "There are 33 7-bit control characters, but the JSON RFC only listed 32 by\r\nomitting the inclusion of the last control character in the 7-bit ASCII range,\r\n'del.'  However, JSON is not limited to 7-bit ASCII; it is Unicode.  Unicode\r\nencompasses 65 control characters from U+0080 to U+009F, totaling an additional\r\n32 characters.  The section that currently reads \"U+0000 through U+001F\" should\r\ninclude these additional control characters reading as \"U+0000 through U+001F,\r\nU+007F, and U+0080 through U+009F\"",
    "submit_date": "2023-10-11",
    "submitter_name": "Zachary Collier (Zamicol)",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "8438",
    "doc-id": "RFC8259",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "14.1",
    "orig_text": "14.1.  Normative References\r\n\r\n   [ECMA-404] Ecma International, \"The JSON Data Interchange Format\",\r\n              Standard ECMA-404,\r\n              <http://www.ecma-international.org/publications/\r\n              standards/Ecma-404.htm>.",
    "correct_text": "14.1.  Normative References\r\n\r\n   [ECMA-404] Ecma International, \"The JSON Data Interchange Format\",\r\n              Standard ECMA-404,\r\n              <https://ecma-international.org/publications-and-standards/\r\n              standards/ecma-404/>.",
    "notes": "Link to ECMA-404 should be updated",
    "submit_date": "2025-05-28",
    "submitter_name": "vitya-ne",
    "verifier_id": "183",
    "verifier_name": "Andy Newton",
    "update_date": "2025-05-29 12:10:14"
  }
]
