[
  {
    "errata_id": 5210,
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "GLOBAL",
    "orig_text": "Internet Engineering Task Force (IETF)                      T. Bray, Ed.\r\nRequest for Comments: 8259                                    Textuality\r\nObsoletes: 7159                                            December 2017\r\nCategory: Standards Track\r\nISSN: 2070-1721\r\n",
    "correct_text": "Internet Engineering Task Force (IETF)                      T. Bray, Ed.\r\nRequest for Comments: 8259                                    Textuality\r\nSTD: 90                                                    December 2017\r\nObsoletes: 7159\r\nCategory: Standards Track\r\nISSN: 2070-1721\r\n",
    "notes": "Missing \"STD\" entry in boilerplate.",
    "submit_date": "2017-12-16",
    "submitter_name": "Julian Reschke",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5218,
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 12,
    "orig_text": "JSON is a subset of JavaScript",
    "correct_text": "JSON is nearly a subset of JavaScript",
    "notes": "JSON is not a subset of JavaScript: there are syntactically valid JSON texts that are not syntactically valid JavaScript. Namely, JSON strings can contain unescaped U+2028 LINE SEPARATOR or U+2029 PARAGRAPH SEPARATOR characters, while JavaScript string literals cannot. Thus, a sequence of characters U+0022 U+2028 U+0022 matches this RFC's 'string' production, but does not match ECMA-262's 'Expression' production.",
    "submit_date": "2017-12-28",
    "submitter_name": "Vasiliy Faronov",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5318,
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": 7,
    "orig_text": "      string = quotation-mark *char quotation-mark\r\n\r\n      char = unescaped /\r\n          escape (\r\n              %x22 /          ; \"    quotation mark  U+0022\r\n              %x5C /          ; \\    reverse solidus U+005C\r\n              %x2F /          ; /    solidus         U+002F\r\n              %x62 /          ; b    backspace       U+0008\r\n              %x66 /          ; f    form feed       U+000C\r\n              %x6E /          ; n    line feed       U+000A\r\n              %x72 /          ; r    carriage return U+000D\r\n              %x74 /          ; t    tab             U+0009\r\n              %x75 4HEXDIG )  ; uXXXX                U+XXXX\r\n\r\n      escape = %x5C              ; \\\r\n\r\n      quotation-mark = %x22      ; \"\r\n\r\n      unescaped = %x20-21 / %x23-5B / %x5D-10FFFF",
    "correct_text": "      string = quotation-mark *char quotation-mark\r\n\r\n      char = unescaped /\r\n          escape (\r\n              %x22 /          ; \"    quotation mark  U+0022\r\n              %x5C /          ; \\    reverse solidus U+005C\r\n              %x2F /          ; /    solidus         U+002F\r\n              %x62 /          ; b    backspace       U+0008\r\n              %x66 /          ; f    form feed       U+000C\r\n              %x6E /          ; n    line feed       U+000A\r\n              %x72 /          ; r    carriage return U+000D\r\n              %x74 /          ; t    tab             U+0009\r\n              %x75 4HEXDIG )  ; uXXXX                U+XXXX\r\n\r\n      escape = %x5C              ; \\\r\n\r\n      quotation-mark = %x22      ; \"\r\n\r\n      unescaped = %x20-21 / %x23-2E / %x30-5B / %x5D-10FFFF",
    "notes": "The solidus U+002F is listed as being escaped above, but is not excluded in the 'unescaped' sequence.",
    "submit_date": "2018-04-04",
    "submitter_name": "Joakim Erdfelt",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5355,
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 6,
    "orig_text": "Note that when such software is used, numbers that are integers and\r\nare in the range [-(2**53)+1, (2**53)-1] are interoperable in the\r\nsense that implementations will agree exactly on their numeric\r\nvalues.",
    "correct_text": "Note that when such software is used, numbers that are integers and\r\nare in the range [-(2**53), (2**53)] are interoperable in the\r\nsense that implementations will agree exactly on their numeric\r\nvalues.",
    "notes": "The limit is presumably derived from ECMAScript which says:\r\n\r\n\"The value of Number.MAX_SAFE_INTEGER is the largest integer n such that n and n + 1 are both exactly representable as a Number value\"\r\n\r\nHowever, Number.MAX_SAFE_INTEGER is 9007199254740991 ((2*53)-1) making n+1 (2**53) the largest exactly representable Number value",
    "submit_date": "2018-05-10",
    "submitter_name": "Anders Rundgren",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5853,
    "doc-id": "RFC8259",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 11,
    "orig_text": "Note:  No \"charset\" parameter is defined for this registration.\r\n    Adding one really has no effect on compliant recipients.",
    "correct_text": "Note:  No \"charset\" parameter is defined for this registration.\r\n    JSON text is encoded as described in RFC 8259, Section 8.1.\r\n",
    "notes": "Last sentence of last note of section 11 should be amended, as it introduces confusion by going against other explicit statements, like the followings:\r\n * RFC8259 sect. 8.1 defines that inner encoding is UTF-8\r\n * RFC8259 sect. 11 defines no formal (optional/required) parameters for this registered type\r\n * RFC6838 sect. 4.2.1 defines the common usage of a \"charset\" parameter as a \"required\" one (which isn't the case here)\r\n * RFC6838 sect. 4.2.1 defines that \"charset\" should not be used if the inner payload already transports charset information (e.g. mandatory UTF-8, which is the case here)\r\n * RFC6838 sect. 4.2.1 defines a \"charset\" parameter only for subtypes of the \"text/*\" hierarchy (which isn't the case here)",
    "submit_date": "2019-09-05",
    "submitter_name": "Luca BRUNO",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 6208,
    "doc-id": "RFC8259",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 8.1,
    "orig_text": "In the interests of interoperability, implementations that parse JSON texts MAY ignore the presence of a byte order mark rather than treating it as an error.",
    "correct_text": "In the interests of interoperability, implementations that parse JSON texts MAY ignore the presence of a byte order mark or MAY interpret a byte order mark to indicate an alternate encoding rather than treating it as an error.",
    "notes": "The original line is copied from previous RFCs that specifically allowed alternate encodings.  In the context of a new, UTF-8 only restriction, interoperability provisions should also address interpreting legacy formats that predate the restriction.  By omission, readers may conclude that the *only* option for a BOM is to ignore or error.\n --VERIFIER NOTES-- \n   This is asking to revisit what we have consensus on, not a report of an error in the RFC.\r\nThe working group had extensive discussions on BOMs, and chose this particular working purposefully.",
    "submit_date": "2020-06-10",
    "submitter_name": "David Golden",
    "verifier_id": 130,
    "verifier_name": "Barry Leiba",
    "update_date": "2020-06-10 07:38:37"
  }
]
