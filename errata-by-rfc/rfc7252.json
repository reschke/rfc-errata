[
  {
    "errata_id": "4895",
    "doc-id": "RFC7252",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "6.4",
    "orig_text": "Note that these rules completely resolve any percent-encoding.",
    "correct_text": "Note that these rules completely resolve any percent-encoding. Also \r\nnote that a trailing slash character in the <path> component represents\r\na separate, zero-character path segment (see [RFC3986] Section 3.3 \r\nABNF) and therefore it is encoded using a Uri-Path Option of zero\r\nlength.",
    "notes": "The current specification for decomposing a URI into CoAP Options (Section 6.4) is correct; however the text may still be unclear to implementers who may think that the phrase \"not including the delimiting slash characters\" means simply omitting a trailing slash character in the URI path. This is incorrect. See the discussion outcome in email thread https://www.ietf.org/mail-archive/web/core/current/msg08223.html . Therefore, a minor clarification is proposed in the notes after the parsing steps.",
    "submit_date": "2016-12-23",
    "submitter_name": "Esko Dijk",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4946",
    "doc-id": "RFC7252",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "6.1",
    "orig_text": "coap-URI = \"coap:\" \"//\" host [ \":\" port ] path-abempty [ \"?\" query ]",
    "correct_text": "coap-URI = \"coap:\" \"//\" host [ \":\" port ] path-abempty [ \"?\" query ]\r\n               [ \"#\" fragment ]",
    "notes": "The optional fragment component allows for indirect identification of a secondary resource, as defined in Section 3.5 of RFC 3986. The fragment identifier is separated from the rest of the URI prior to a dereference; fragment identifiers are processed client-side and are not included in CoAP requests. The original text shows the syntax of coap:// URIs _after_ separating the fragment identifier, which leaves ambiguity as to whether fragment identifiers are supported or not. The corrected text shows the syntax of CoAP URIs _before_ separating the fragment identifier, which makes clear that fragment identifiers are supported.",
    "submit_date": "2017-02-22",
    "submitter_name": "Klaus Hartke",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4947",
    "doc-id": "RFC7252",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "6.2",
    "orig_text": "coaps-URI = \"coaps:\" \"//\" host [ \":\" port ] path-abempty\r\n               [ \"?\" query ]",
    "correct_text": "coaps-URI = \"coaps:\" \"//\" host [ \":\" port ] path-abempty\r\n               [ \"?\" query ] [ \"#\" fragment ]",
    "notes": "The optional fragment component allows for indirect identification of a secondary resource, as defined in Section 3.5 of RFC 3986. The fragment identifier is separated from the rest of the URI prior to a dereference; fragment identifiers are processed client-side and are not included in CoAP requests. The original text shows the syntax of coaps:// URIs _after_ separating the fragment identifier, which leaves ambiguity as to whether fragment identifiers are supported or not. The corrected text shows the syntax of CoAP URIs _before_ separating the fragment identifier, which makes clear that fragment identifiers are supported.",
    "submit_date": "2017-02-22",
    "submitter_name": "Klaus Hartke",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4948",
    "doc-id": "RFC7252",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "5.6",
    "orig_text": "For a presented request, a CoAP endpoint MUST NOT use a stored\r\nresponse, unless:\r\n\r\no  the presented request method and that used to obtain the stored\r\n   response match,\r\n\r\no  all options match between those in the presented request and those\r\n   of the request used to obtain the stored response (which includes\r\n   the request URI), except that there is no need for a match of any\r\n   request options marked as NoCacheKey (Section 5.4) or recognized\r\n   by the Cache and fully interpreted with respect to its specified\r\n   cache behavior (such as the ETag request option described in\r\n   Section 5.10.6; see also Section 5.4.2), and\r\n\r\no  the stored response is either fresh or successfully validated as\r\n   defined below.\r\n\r\nThe set of request options that is used for matching the cache entry\r\nis also collectively referred to as the \"Cache-Key\".",
    "correct_text": "For a presented request, a CoAP endpoint MUST NOT use a stored\r\nresponse, unless:\r\n\r\no  [...]\r\n\r\no  [...]\r\n\r\no  the payload of the presented request and the payload of the\r\n   request used to obtain the stored response match, and\r\n\r\no  [...]\r\n\r\nThe set of request options that is used for matching the cache entry\r\nplus (if applicable) the request payload are also collectively referred\r\nto as the \"Cache-Key\".",
    "notes": "CoAP servers may return error responses in reply to requests that are invalid at the CoAP level (e.g., 4.02 Bad Option if the client includes an unrecognized option) or at the application level above (e.g., 4.00 Bad Request if the client includes a malformed payload according to application semantics).\r\n\r\nIf the error response does not depend on the request payload, then it is desirable that repeated requests that differ only in the payload can be satisfied with the same cached response. E.g., repeated requests for a non-existing resource should result in a cached 4.04 Not Found response as often as possible, regardless of the payload, rather than hit the server every time.\r\n\r\nIf the error response depends on the request payload, then it is not desirable that cached responses are reused for repeated requests that differ only in the payload. E.g., a client should not receive an error response for a valid request payload because another client sent an identical request but with a malformed request payload. In this case, including the request payload in the Cache-Key would give the expected result.\r\n\r\nThe original text does not include the request in the Cache-Key, which may lead to unexpected results. The corrected text changes that.\r\n\r\nSince CoAP does not provide any indication in responses to distinguish between the two cases, caches generally cannot determine whether the response depends on the request payload or not and thus must always include the request payload in the Cache-Key to give the expected result. (As an exception, a cache at an origin server may be able to determine whether a cached response depends on the request payload or not, and thus can reuse responses accordingly. This already applies to responses that do not depend on the request method.)",
    "submit_date": "2017-02-22",
    "submitter_name": "Klaus Hartke",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4949",
    "doc-id": "RFC7252",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "5.10.7",
    "orig_text": "If any\r\nof these reserved option numbers occurs in addition to Location-Path\r\nand/or Location-Query and are not supported, then a 4.02 (Bad Option)\r\nerror MUST be returned.",
    "correct_text": "If any\r\nof these reserved option numbers occurs in addition to Location-Path\r\nand/or Location-Query and are not supported, then the response MUST\r\nbe rejected (Sections 4.2 and 4.3).",
    "notes": "The Location-* options are used in responses. A client cannot return a 4.02 (Bad Option) response in reply to a response. The correct behavior is to reject the response.",
    "submit_date": "2017-02-22",
    "submitter_name": "Klaus Hartke",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4954",
    "doc-id": "RFC7252",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "12.3",
    "orig_text": "CoAP does not include a separate way to convey content-encoding\r\ninformation with a request or response, and for that reason the\r\ncontent-encoding is also specified for each identifier (if any).  If\r\nmultiple content-encodings will be used with a media type, then a\r\nseparate Content-Format identifier for each is to be registered.\r\nSimilarly, other parameters related to an Internet media type, such\r\nas level, can be defined for a CoAP Content-Format entry.\r\n\r\n+--------------------------+----------+----+------------------------+\r\n| Media type               | Encoding | ID | Reference              |\r\n+--------------------------+----------+----+------------------------+\r\n",
    "correct_text": "CoAP does not include a separate way to convey content-coding\r\ninformation with a request or response, and for that reason the\r\ncontent-coding is also specified for each identifier (if any).  If\r\nmultiple content-codings will be used with a media type, then a\r\nseparate Content-Format identifier for each is to be registered.\r\nSimilarly, other parameters related to an Internet media type, such\r\nas level, can be defined for a CoAP Content-Format entry.\r\n\r\n+--------------------------+----------------+----+------------------+\r\n| Media type               | Content coding | ID | Reference        |\r\n+--------------------------+----------------+----+------------------+\r\n",
    "notes": "A CoAP Content-Format is the combination of an Internet Media Type with an HTTP Content Coding, as correctly explained in the first paragraphs of Section 12.3. However, the next paragraph (the original text above) incorrectly uses the term \"content-encoding\". The correct term is \"content-coding\", as shown in the corrected text.\r\n\r\nExamples for _valid_ CoAP Content-Format registrations:\r\n\r\n- media type \"text/plain; charset=iso-8859-1\" with content-coding \"deflate\"\r\n\r\n- media type \"image/png\" with content-coding \"\" (no content-coding)\r\n\r\n- media type \"image/png\" with content-coding \"identity\" (same as previous, no content-coding)\r\n\r\n- media type \"application/example+xml\" with content-coding \"exi\"\r\n\r\nExamples for _invalid_ CoAP Content-Format registrations:\r\n\r\n- media type \"application/coap-group+json\" with content-coding \"UTF-8\" (UTF-8 is a character encoding, not a content-coding; should be media type \"application/coap-group+json; charset=utf-8\" with content-coding \"identity\")\r\n\r\n- media type \"audio/opus\" with content-coding \"identity\" (\"audio/opus\" has a required parameter \"rate\"; should be media type \"audio/opus; rate=48000\" with content-coding \"identity\")\r\n\r\n- media type \"application/example+xml\" with content-coding \"identity, exi\" (too many content-codings; should be media type \"application/example+xml\" with content-coding \"identity\" and, separately, media type \"application/example+xml\" with content-coding \"exi\")\r\n\r\n- media type \"application/example+exi\" with content-coding \"identity\" (\"+exi\" is not a registered structured syntax suffix at the time of writing of this erratum)\r\n\r\n- media type \"video/ogg\" with content-coding \"exi\" (EXI is a content-coding for XML information)",
    "submit_date": "2017-02-28",
    "submitter_name": "Klaus Hartke",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5078",
    "doc-id": "RFC7252",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7.2.1",
    "orig_text": "The Content-Format code\r\nattribute MAY include a space-separated sequence of Content-Format\r\ncodes, indicating that multiple content-formats are available.  The\r\nsyntax of the attribute value is summarized in the production \"ct-\r\nvalue\" in Figure 12, where \"cardinal\", \"SP\", and \"DQUOTE\" are defined\r\nas in [RFC6690].",
    "correct_text": "The Content-Format code\r\nattribute MAY include a space-separated sequence of Content-Format\r\ncodes, indicating that multiple content-formats are available.\r\nThe Content-Format code attribute MUST NOT appear more than once in a \r\nlink.  The syntax of the attribute value is summarized in the \r\nproduction \"ct-value\" in Figure 12, where \"cardinal\", \"SP\", and \r\n\"DQUOTE\" are defined as in [RFC6690].",
    "notes": "Insert a sentence that says that the code MUST NOT appear more than once.  This appears to be what was intended, but not stated, by the authors since it supports the space separated values to appear in a single attribute value.",
    "submit_date": "2017-08-07",
    "submitter_name": "Jim Schaad",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5284",
    "doc-id": "RFC7252",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "5.3.1",
    "orig_text": "The client SHOULD generate tokens in such a way that tokens currently\r\nin use for a given source/destination endpoint pair are unique.",
    "correct_text": "The client SHOULD generate tokens in such a way that tokens currently\r\nin use for a given source/destination endpoint pair are unique per\r\nrequest.",
    "notes": "Multiple requests may be active for a given source/destination\r\nendpoint pair.  The OLD text is thus broken.\r\n\r\nThe NEW text is aligned with the definition of the Token:\r\n\r\n  A token is intended for use as a client-local identifier for\r\n  differentiating between concurrent requests (see Section 5.3); it\r\n  could have been called a \"request ID\".\r\n\r\nFurther, using the same token for a given source/destination endpoint\r\npair have some implications, for example, for applications which\r\nrequire the support of multiple observe queries because RFC7641\r\nstates the following:\r\n\r\n   The entry in the list of observers is keyed by the client endpoint\r\n    and the token specified by the client in the request.  If an entry\r\n    with a matching endpoint/token pair is already present in the list\r\n    (which, for example, happens when the client wishes to reinforce\r\n    its interest in a resource), the server MUST NOT add a new entry\r\n    but MUST replace or update the existing one.",
    "submit_date": "2018-03-09",
    "submitter_name": "Mohamed Boucadair",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5429",
    "doc-id": "RFC7252",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.4",
    "orig_text": "An Acknowledgement or Reset message is related to a Confirmable\r\nmessage or Non-confirmable message by means of a Message ID along\r\nwith additional address information of the corresponding endpoint.\r\nThe Message ID is a 16-bit unsigned integer that is generated by the\r\nsender of a Confirmable or Non-confirmable message and included in\r\nthe CoAP header.  The Message ID MUST be echoed in the\r\nAcknowledgement or Reset message by the recipient.\r\n\r\nThe same Message ID MUST NOT be reused (in communicating with the\r\nsame endpoint) within the EXCHANGE_LIFETIME (Section 4.8.2).\r\n\r\nImplementation Note:  Several implementation strategies can be\r\n  employed for generating Message IDs.  In the simplest case, a CoAP\r\n  endpoint generates Message IDs by keeping a single Message ID\r\n  variable, which is changed each time a new Confirmable or Non-\r\n  confirmable message is sent, regardless of the destination address\r\n  or port.  Endpoints dealing with large numbers of transactions\r\n  could keep multiple Message ID variables, for example, per prefix\r\n  or destination address.  (Note that some receiving endpoints may\r\n  not be able to distinguish unicast and multicast packets addressed\r\n  to it, so endpoints generating Message IDs need to make sure these\r\n  do not overlap.)  It is strongly recommended that the initial\r\n  value of the variable (e.g., on startup) be randomized, in order\r\n  to make successful off-path attacks on the protocol less likely.",
    "correct_text": "An Acknowledgement or Reset message is related to a Confirmable\r\nmessage or Non-confirmable message by means of a Message ID along\r\nwith additional address information of the corresponding endpoint.\r\nThe Message ID is a 16-bit unsigned integer that is generated by the\r\nsender of a Confirmable or Non-confirmable message and included in\r\nthe CoAP header.  Message IDs of subsequence messages send to the\r\nsame endpoint within EXCHANGE_LIFETIME MUST be strictly ascending\r\n(wrapping around at a value of 65535).  Additionally, two\r\nsubsequently send Message IDs to the same endpoint SHOULD have a\r\ndifference of at most 16.  The Message ID MUST be echoed in the\r\nAcknowledgement or Reset message by the recipient.\r\n\r\nThe same Message ID MUST NOT be reused (in communicating with the\r\nsame endpoint) within the EXCHANGE_LIFETIME (Section 4.8.2).\r\n\r\nImplementation Note:  Several implementation strategies can be\r\n  employed for generating Message IDs.  In the simplest case, a CoAP\r\n  endpoint generates Message IDs by keeping a single Message ID\r\n  variable, which is incremented each time a new Confirmable or Non-\r\n  confirmable message is sent, regardless of the destination address\r\n  or port.  Endpoints dealing with large numbers of transactions\r\n  could keep multiple Message ID variables, for example, per prefix\r\n  or destination address.  (Note that some receiving endpoints may\r\n  not be able to distinguish unicast and multicast packets addressed\r\n  to it, so endpoints generating Message IDs need to make sure these\r\n  do not overlap.)  It is strongly recommended that the initial\r\n  value of the variable (e.g., on startup) be randomized, in order\r\n  to make successful off-path attacks on the protocol less likely.",
    "notes": "Without any restrictions on how Message IDs are generated, an implementation of CoAP duplication detection must be prepared to receive a random sequence of Message IDs.\r\nOne simple implementation strategy would be to store the received Message IDs along with a timestamp when they were received.\r\nIf a 16 bit time stamp would be used, 4 Bytes per tracked Message ID would be required.\r\nIf additionaly a CoAP server expects requests to be received at a rate of 1 message per second, at least 247 * 4 Byte or approximately 1 KiB have to be allocated per client.\r\nA class 1 (see RFC 7228 Section 3) server could handle at most 10 clients in parallel, if anything apart duplicate detection could be implemented without using any memory at all.\r\n\r\nIf instead Message IDs have to be generated by incrementing a (global or per endpoint/network prefix/...) counter variable, duplicate detection can be implemented in a time and memory efficient way without limiting the rate of the message exchange between to nodes.",
    "submit_date": "2018-07-18",
    "submitter_name": "Marian Buschsieweke",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  }
]
