[
  {
    "errata_id": "5762",
    "doc-id": "RFC8519",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "4.1",
    "orig_text": "leaf type {\r\ntype acl-type;\r\ndescription\r\n  \"Type of ACL.  Indicates the primary intended\r\n   type of match criteria (e.g., Ethernet, \r\n   IPv4, IPv6, mixed, etc.) used in the list\r\n   instance.\";\r\n}",
    "correct_text": "leaf type {\r\ntype acl-type;\r\ndefault \"ipv4-acl-type\";\r\ndescription\r\n  \"Type of ACL.  Indicates the primary intended\r\n   type of match criteria (e.g., Ethernet, \r\n   IPv4, IPv6, mixed, etc.) used in the list\r\n   instance.\";\r\n}",
    "notes": "I am wondering why not  set default value for acl-type,e.g., set default value as \"ipv4-acl-type\" otherwise, how to determine which field under which choice will be matched upon and which action should be taken on them if the opetional parameter type under acl list is not set.\r\n\r\nAlso I want to better understand why acl type is removed from key indexes of access list and keep it as optional parameter under acl list. One case I am thinking in my mind is we add a mixed Ethernet, IPv4, and IPv6 ACL entry when we already have Ethernet ACL entry,IPv4 ACL entry , we don't need to remove existing ethernet entry and existing IPv4 entry in the list (\"aces\") and create a new entry with mixed ethernet, IPv4, IPv6 ACL, instead, we just add a new identity called mixed-eth-ipv4-ipv6-acl-type and add a new IPv6 entry.\n --VERIFIER NOTES-- \n   \r\nMahesh Jethanandani replied:\r\n\r\nThis errata should be rejected for the following reason.\r\n\r\nThe whole idea of defining the identities for acl-type was to allow vendors to specify what capabilities their box is capable of supporting and then to specify what capabilities the vendors want to support. As such there is no â€œdefault capability\" for every vendor. Besides, if a device advertises a mixed-eth-ipv4 feature, it is because it can only support Ethernet and IPv4 ACL combinations, and it cannot support IPv6 ACL matches. You do not add a capability of IPv6 match on the fly. It either has it, or it does not. If it does, advertise mixed-eth-ipv4-ipv6 capability to begin with.\r\n\r\nThe errata proposes a change to the standard and is not correcting an error in the document.  additionaly it not clear why it would be appraise to set a default acl type.\r\n\r\nThe errata is declined.\r\n",
    "submit_date": "2019-06-24",
    "submitter_name": "Qin WU",
    "verifier_id": "135",
    "verifier_name": "Joel Jaeggli",
    "update_date": "2019-09-23 23:37:31"
  },
  {
    "errata_id": "5908",
    "doc-id": "RFC8519",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "section-4.1",
    "orig_text": "choice l2 {\r\n              container eth {\r\n                when \"derived-from-or-self(/acls/acl/type, \"\r\n                   + \"'acl:eth-acl-type')\";\r\n                if-feature \"match-on-eth\";\r\n                uses pf:acl-eth-header-fields;\r\n                description\r\n                  \"Rule set that matches Ethernet headers.\";\r\n              }\r\n              description\r\n                \"Match Layer 2 headers, for example, Ethernet\r\n                 header fields.\";\r\n            }\r\n\r\n            choice l3 {\r\n              container ipv4 {\r\n                when \"derived-from-or-self(/acls/acl/type, \"\r\n                   + \"'acl:ipv4-acl-type')\";\r\n                if-feature \"match-on-ipv4\";\r\n                uses pf:acl-ip-header-fields;\r\n                uses pf:acl-ipv4-header-fields;\r\n                description\r\n                  \"Rule set that matches IPv4 headers.\";\r\n              }\r\n\r\n              container ipv6 {\r\n                when \"derived-from-or-self(/acls/acl/type, \"\r\n                   + \"'acl:ipv6-acl-type')\";\r\n                if-feature \"match-on-ipv6\";\r\n                uses pf:acl-ip-header-fields;\r\n                uses pf:acl-ipv6-header-fields;\r\n                description\r\n                  \"Rule set that matches IPv6 headers.\";\r\n              }\r\n              description\r\n                \"Choice of either IPv4 or IPv6 headers\";\r\n            }",
    "correct_text": "choice l2 {\r\n              container eth {\r\n                when \"derived-from-or-self(../../../../type, \"\r\n                   + \"'acl:eth-acl-type')\";\r\n                if-feature \"match-on-eth\";\r\n                uses pf:acl-eth-header-fields;\r\n                description\r\n                  \"Rule set that matches Ethernet headers.\";\r\n              }\r\n              description\r\n                \"Match Layer 2 headers, for example, Ethernet\r\n                 header fields.\";\r\n            }\r\n\r\n            choice l3 {\r\n              container ipv4 {\r\n                when \"derived-from-or-self(../../../../type, \"\r\n                   + \"'acl:ipv4-acl-type')\";\r\n                if-feature \"match-on-ipv4\";\r\n                uses pf:acl-ip-header-fields;\r\n                uses pf:acl-ipv4-header-fields;\r\n                description\r\n                  \"Rule set that matches IPv4 headers.\";\r\n              }\r\n\r\n              container ipv6 {\r\n                when \"derived-from-or-self(../../../../type, \"\r\n                   + \"'acl:ipv6-acl-type')\";\r\n                if-feature \"match-on-ipv6\";\r\n                uses pf:acl-ip-header-fields;\r\n                uses pf:acl-ipv6-header-fields;\r\n                description\r\n                  \"Rule set that matches IPv6 headers.\";\r\n              }\r\n              description\r\n                \"Choice of either IPv4 or IPv6 headers\";\r\n            }",
    "notes": "In access-list-control yang definition, the absolute path was used in when derived-from-or-self. This mean it will check all the type in configured acl lists one by one the return the first matched result (If there is any). For examples, I have acls acl acl_test1 configured, and type is set to ipv4-acl-type. Then if I create acl_test2 with ipv6-acl-type, when choice happened in acl_test2, it starts from acl_test1 because it's the first entry for acl list. Choice found there is ipv4-acl-type, then it chooses containter ipv4 rather than ipv6. This is not the correct behivour, it should choose ipv6 container because current acl type is ipv6-acl-type.\r\nI think it should only check the current acl type not the whole acl list. So I changed it to relevant path only match the type field in current acl.\r\nPlease review my change and corret me if my understanding is not match your design.\r\nIf you need more information, please contact me directly.\r\n\r\nAD Note: I agree that the errata is valid, but we cannot update a YANG module revision through the errata process, hence I've moved this errata to \"Held for Document Update\" so that it can be fixed by publishing a new revision of the YANG module.",
    "submit_date": "2019-11-14",
    "submitter_name": "Fanqiang Kong",
    "verifier_id": "166",
    "verifier_name": "Robert Wilton",
    "update_date": "2024-01-12 06:30:32"
  },
  {
    "errata_id": "7312",
    "doc-id": "RFC8519",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "A.1",
    "orig_text": "   The \"example-newco-acl\" module is an example of a company's\r\n   proprietary model that augments the \"ietf-acl\" module.  It shows how\r\n   to use 'augment' with an XML Path Language (XPath) expression to add\r\n   additional match criteria, actions, and default actions for when no\r\n   ACE matches are found.  All these are company proprietary extensions\r\n   or system feature extensions.  \"example-newco-acl\" is just an\r\n   example, and it is expected that vendors will create their own\r\n   proprietary models.",
    "correct_text": "   The \"example-newco-acl\" module is an example of a company's\r\n   proprietary model that augments the \"ietf-access-control-list\" module.  It shows how\r\n   to use 'augment' with an XML Path Language (XPath) expression to add\r\n   additional match criteria, actions, and default actions for when no\r\n   ACE matches are found.  All these are company proprietary extensions\r\n   or system feature extensions.  \"example-newco-acl\" is just an\r\n   example, and it is expected that vendors will create their own\r\n   proprietary models.",
    "notes": "There is no \"ietf-acl\" module in the document.",
    "submit_date": "2023-01-18",
    "submitter_name": "Mohamed Boucadair",
    "verifier_id": "166",
    "verifier_name": "Robert Wilton",
    "update_date": "2024-01-12 06:26:49"
  },
  {
    "errata_id": "7313",
    "doc-id": "RFC8519",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "A.1",
    "orig_text": "   The following figure is the tree diagram of example-newco-acl.  In\r\n   this example, /ietf-acl:acls/ietf-acl:acl/ietf-acl:aces/ietf-acl:ace/\r\n   ietf-acl:matches are augmented with two new choices: protocol-\r\n   payload-choice and metadata.  The protocol-payload-choice uses a\r\n   grouping with an enumeration of all supported protocol values.\r\n   Metadata matches apply to fields associated with the packet, that are\r\n   not in the packet header, such as overall packet length.  In another\r\n   example, /ietf-acl:acls/ietf-acl:acl/ietf-acl:aces/ietf-acl:ace/\r\n   ietf-acl:actions are augmented with a new choice of actions.",
    "correct_text": "   The following figure is the tree diagram of example-newco-acl.  In\r\n   this example, /acl:acls/acl:acl/acl:aces/acl:ace/acl:matches\r\n   are augmented with two new choices: protocol-payload-choice and\r\n   metadata.  The protocol-payload-choice uses a\r\n   grouping with an enumeration of all supported protocol values.\r\n   Metadata matches apply to fields associated with the packet, that are\r\n   not in the packet header, such as overall packet length.  In another\r\n   example, /acl:acls/acl:acl/acl:aces/acl:ace/acl:actions \r\n   are augmented with a new choice of actions.",
    "notes": "The prefix is \"acl\" not \"ietf-acl\"\r\n\r\n==\r\nmodule ietf-access-control-list {\r\n  yang-version 1.1;\r\n  namespace \"urn:ietf:params:xml:ns:yang:ietf-access-control-list\";\r\n  prefix acl;\r\n  ...\r\n==",
    "submit_date": "2023-01-18",
    "submitter_name": "Mohamed Boucadair",
    "verifier_id": "166",
    "verifier_name": "Robert Wilton",
    "update_date": "2024-01-12 06:28:11"
  },
  {
    "errata_id": "8350",
    "doc-id": "RFC8519",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.1",
    "orig_text": "      \"The source and destination port range definitions\r\n       can be further qualified using an operator.  An\r\n       operator is needed only if the lower-port is specified\r\n       and the upper-port is not specified.  The operator\r\n       therefore further qualifies the lower-port only.\";",
    "correct_text": "      \"A port number definition can be further qualified\r\n       using an operator.\";",
    "notes": "The operator isn't used with port-ranges because these are defined in distinct cases:\r\n\r\n===\r\n        |        |  |  |     |     +--:(range-or-operator)\r\n        |        |  |  |     |        +--rw (port-range-or-operator)?\r\n        |        |  |  |     |           +--:(range)\r\n        |        |  |  |     |           |  +--rw lower-port\r\n        |        |  |  |     |           |  |       inet:port-number\r\n        |        |  |  |     |           |  +--rw upper-port\r\n        |        |  |  |     |           |          inet:port-number\r\n        |        |  |  |     |           +--:(operator)\r\n        |        |  |  |     |              +--rw operator?     operator\r\n        |        |  |  |     |              +--rw port\r\n==",
    "submit_date": "2025-03-27",
    "submitter_name": "Mohamed BOUCADAIR",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  }
]
