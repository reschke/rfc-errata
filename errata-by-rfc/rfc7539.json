[
  {
    "errata_id": 4371,
    "doc-id": "RFC7539",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.8.1",
    "orig_text": "         mac_data |= num_to_4_le_bytes(aad.length)\r\n         mac_data |= num_to_4_le_bytes(ciphertext.length)\r\n",
    "correct_text": "         mac_data |= num_to_8_le_bytes(aad.length)\r\n         mac_data |= num_to_8_le_bytes(ciphertext.length)\r\n",
    "notes": "Per section 2.8 the lengths should be 64-bit (8 bytes), not 4.\r\n\r\nAfter this change the pseudo-code output matches the test vectors shown in 2.8.2.",
    "submit_date": "2015-05-21",
    "submitter_name": "Adam Eijdenberg",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4372,
    "doc-id": "RFC7539",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "2.5.1",
    "orig_text": "accumulator = 0",
    "correct_text": "a = 0",
    "notes": "This variable goes by both \"accumulator\" and \"a\" in the pseudo-code.  Renaming this line allows the pseudo-code to pseudo-compile.",
    "submit_date": "2015-05-21",
    "submitter_name": "Adam Eijdenberg",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4373,
    "doc-id": "RFC7539",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "2.5.1",
    "orig_text": "s = le_num(key[16..31])",
    "correct_text": "s = le_bytes_to_num(key[16..31])",
    "notes": "Other usages in the same pseudo-code example call the function le_bytes_to_num to perform what appears to be the same task.",
    "submit_date": "2015-05-21",
    "submitter_name": "Adam Eijdenberg",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4434,
    "doc-id": "RFC7539",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": 2.6,
    "orig_text": "We take\r\nthe first 256 bits or the serialized state, and use those as the one-\r\ntime Poly1305 key: the first 128 bits are clamped and form \"r\", while\r\nthe next 128 bits become \"s\".",
    "correct_text": "We take\r\nthe first 256 bits of the serialized state, and use those as the one-\r\ntime Poly1305 key: the first 128 bits are clamped and form \"r\", while\r\nthe next 128 bits become \"s\".",
    "notes": "“We take the first 256 **or** the serialized state”. Should be **of**. ",
    "submit_date": "2015-08-05",
    "submitter_name": "Lukasz Stelmach",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4700,
    "doc-id": "RFC7539",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": 2.8,
    "orig_text": "    The output from the AEAD is twofold:\r\n\r\n   o  A ciphertext of the same length as the plaintext.\r\n   o  A 128-bit tag, which is the output of the Poly1305 function.",
    "correct_text": "    The output from the AEAD is the concatenation of:\r\n\r\n   o  A ciphertext of the same length as the plaintext.\r\n   o  A 128-bit tag, which is the output of the Poly1305 function.",
    "notes": "Section 2.1 of RFC 5116 defines the AEAD interface, and that interface produces a single output, C (or an error).",
    "submit_date": "2016-05-24",
    "submitter_name": "Martin Thomson",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4858,
    "doc-id": "RFC7539",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.8.",
    "orig_text": " 1.  The amount of encrypted data possible in a single invocation is\r\n     2^32-1 blocks of 64 bytes each, because of the size of the block\r\n     counter field in the ChaCha20 block function.  This gives a total\r\n     of 247,877,906,880 bytes, or nearly 256 GB.",
    "correct_text": " 1.  The amount of encrypted data possible in a single invocation is\r\n     2^32-1 blocks of 64 bytes each, because of the size of the block\r\n     counter field in the ChaCha20 block function.  This gives a total\r\n     of 274,877,906,880 bytes, or nearly 256 GB.",
    "notes": "There is an error in the result of the P_MAX = ((2^32) - 1) * 64  calculation.\r\nThe correct value is 2_74_,877,906,880 while the document states 2_47_,877,906,880.\r\nThis error has already been adopted by multiple implementations as P_MAX value.",
    "submit_date": "2016-11-10",
    "submitter_name": "Timm Korte",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4861,
    "doc-id": "RFC7539",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.8.",
    "orig_text": "   o  C_MAX = P_MAX + tag length = 247,877,906,896 octets.\r\n",
    "correct_text": "   o  C_MAX = P_MAX + tag length = 274,877,906,896 octets.\r\n",
    "notes": "When reviewing errata 4858, Adam Langely and Yoav Nir identified that this text should also be changed.\r\n\r\n(This errata was created by duplicating 4858 in the system by Lars Eggert.)",
    "submit_date": "2016-11-10",
    "submitter_name": "Timm Korte",
    "verifier_id": 113,
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  }
]
