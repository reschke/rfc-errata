[
  {
    "errata_id": "4371",
    "doc-id": "RFC7539",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.8.1",
    "orig_text": "         mac_data |= num_to_4_le_bytes(aad.length)\r\n         mac_data |= num_to_4_le_bytes(ciphertext.length)\r\n",
    "correct_text": "         mac_data |= num_to_8_le_bytes(aad.length)\r\n         mac_data |= num_to_8_le_bytes(ciphertext.length)\r\n",
    "notes": "Per section 2.8 the lengths should be 64-bit (8 bytes), not 4.\r\n\r\nAfter this change the pseudo-code output matches the test vectors shown in 2.8.2.",
    "submit_date": "2015-05-21",
    "submitter_name": "Adam Eijdenberg",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4372",
    "doc-id": "RFC7539",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "2.5.1",
    "orig_text": "accumulator = 0",
    "correct_text": "a = 0",
    "notes": "This variable goes by both \"accumulator\" and \"a\" in the pseudo-code.  Renaming this line allows the pseudo-code to pseudo-compile.",
    "submit_date": "2015-05-21",
    "submitter_name": "Adam Eijdenberg",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4373",
    "doc-id": "RFC7539",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "2.5.1",
    "orig_text": "s = le_num(key[16..31])",
    "correct_text": "s = le_bytes_to_num(key[16..31])",
    "notes": "Other usages in the same pseudo-code example call the function le_bytes_to_num to perform what appears to be the same task.",
    "submit_date": "2015-05-21",
    "submitter_name": "Adam Eijdenberg",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4434",
    "doc-id": "RFC7539",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "2.6",
    "orig_text": "We take\r\nthe first 256 bits or the serialized state, and use those as the one-\r\ntime Poly1305 key: the first 128 bits are clamped and form \"r\", while\r\nthe next 128 bits become \"s\".",
    "correct_text": "We take\r\nthe first 256 bits of the serialized state, and use those as the one-\r\ntime Poly1305 key: the first 128 bits are clamped and form \"r\", while\r\nthe next 128 bits become \"s\".",
    "notes": "“We take the first 256 **or** the serialized state”. Should be **of**. ",
    "submit_date": "2015-08-05",
    "submitter_name": "Lukasz Stelmach",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4700",
    "doc-id": "RFC7539",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.8",
    "orig_text": "    The output from the AEAD is twofold:\r\n\r\n   o  A ciphertext of the same length as the plaintext.\r\n   o  A 128-bit tag, which is the output of the Poly1305 function.",
    "correct_text": "    The output from the AEAD is the concatenation of:\r\n\r\n   o  A ciphertext of the same length as the plaintext.\r\n   o  A 128-bit tag, which is the output of the Poly1305 function.",
    "notes": "Section 2.1 of RFC 5116 defines the AEAD interface, and that interface produces a single output, C (or an error).",
    "submit_date": "2016-05-24",
    "submitter_name": "Martin Thomson",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4858",
    "doc-id": "RFC7539",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.8.",
    "orig_text": " 1.  The amount of encrypted data possible in a single invocation is\r\n     2^32-1 blocks of 64 bytes each, because of the size of the block\r\n     counter field in the ChaCha20 block function.  This gives a total\r\n     of 247,877,906,880 bytes, or nearly 256 GB.",
    "correct_text": " 1.  The amount of encrypted data possible in a single invocation is\r\n     2^32-1 blocks of 64 bytes each, because of the size of the block\r\n     counter field in the ChaCha20 block function.  This gives a total\r\n     of 274,877,906,880 bytes, or nearly 256 GB.",
    "notes": "There is an error in the result of the P_MAX = ((2^32) - 1) * 64  calculation.\r\nThe correct value is 2_74_,877,906,880 while the document states 2_47_,877,906,880.\r\nThis error has already been adopted by multiple implementations as P_MAX value.",
    "submit_date": "2016-11-10",
    "submitter_name": "Timm Korte",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4861",
    "doc-id": "RFC7539",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.8.",
    "orig_text": "   o  C_MAX = P_MAX + tag length = 247,877,906,896 octets.\r\n",
    "correct_text": "   o  C_MAX = P_MAX + tag length = 274,877,906,896 octets.\r\n",
    "notes": "When reviewing errata 4858, Adam Langely and Yoav Nir identified that this text should also be changed.\r\n\r\n(This errata was created by duplicating 4858 in the system by Lars Eggert.)",
    "submit_date": "2016-11-10",
    "submitter_name": "Timm Korte",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "8274",
    "doc-id": "RFC7539",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "2.3.2",
    "orig_text": " ChaCha state with the key setup.\r\n\r\n       61707865  3320646e  79622d32  6b206574\r\n       03020100  07060504  0b0a0908  0f0e0d0c\r\n       13121110  17161514  1b1a1918  1f1e1d1c\r\n       00000001  09000000  4a000000  00000000",
    "correct_text": " ChaCha state with the key setup.\r\n\r\n       61707865  3320646e  79622d32  6b206574\r\n       03020100  07060504  0b0a0908  0f0e0d0c\r\n       13121110  17161514  1b1a1918  1f1e1d1c\r\n       01000000  09000000  4a000000  00000000",
    "notes": "Section 2.3 says: \"A 32-bit block count parameter, treated as a 32-bit little-endian integer\". In Section 2.3.2 the initial block counter is set to 1 which is 00000001 in big-endian hex. So I think, the corresponding entry in the state matrix (index 12) should be 01000000.",
    "submit_date": "2025-01-30",
    "submitter_name": "Alina Obst",
    "verifier_id": "2",
    "verifier_name": null,
    "update_date": "2025-02-06 10:49:03"
  }
]
