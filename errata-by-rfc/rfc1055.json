[
  {
    "errata_id": "4619",
    "doc-id": "RFC1055",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "ABSTRACT",
    "orig_text": "The TCP/IP protocol family runs over a variety of network media:\r\nIEEE 802.3 (ethernet) and 802.5 (token ring) LAN's, X.25 lines,\r\nsatellite links, and serial lines.  There are standard encapsulations\r\nfor IP packets defined for many of these networks, but there is no\r\nstandard for serial lines.  SLIP, Serial Line IP, is a currently a de\r\nfacto standard, commonly used for point-to-point serial connections\r\nrunning TCP/IP.  It is not an Internet standard.  Distribution of\r\nthis memo is unlimited.",
    "correct_text": "The TCP/IP protocol family runs over a variety of network media:\r\nIEEE 802.3 (ethernet) and 802.5 (token ring) LAN's, X.25 lines,\r\nsatellite links, and serial lines.  There are standard encapsulations\r\nfor IP packets defined for many of these networks.  SLIP, Serial\r\nLine IP, is commonly used for point-to-point serial connections\r\nrunning TCP/IP. Distribution of this memo is unlimited.",
    "notes": "Status is INTERNET STANDARD however the title says it's non-standard and the abstract says \"not a standard\".\r\n\r\nAn update could also refer to PPP as a standard... I've removed the line saying there is no standard for serial lines.",
    "submit_date": "2016-02-16",
    "submitter_name": "John Bradshaw",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "8562",
    "doc-id": "RFC1055",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "GLOBAL",
    "orig_text": "                   /* if it's the same code as an ESC character, wait\r\n                    * and get another character and then figure out\r\n                    * what to store in the packet based on that.\r\n                    */\r\n                   case ESC:\r\n                           c = recv_char();\r\n\r\n                           /* if \"c\" is not one of these two, then we\r\n                            * have a protocol violation.  The best bet\r\n                            * seems to be to leave the byte alone and\r\n                            * just stuff it into the packet\r\n                            */\r\n                           switch(c) {\r\n                           case ESC_END:\r\n                                   c = END;\r\n                                   break;\r\n                           case ESC_ESC:\r\n                                   c = ESC;\r\n                                   break;\r\n                                   }",
    "correct_text": "                   /* if it's the same code as an ESC character, wait\r\n                    * and get another character and then figure out\r\n                    * what to store in the packet based on that.\r\n                    */\r\n                   case ESC:\r\n                           c = recv_char();\r\n\r\n                           /* if \"c\" is not one of these two, then we\r\n                            * have a protocol violation.  The best bet\r\n                            * seems to be to leave the byte alone and\r\n                            * just stuff it into the packet. If \"c\" is\r\n                            * an END character, the packet must end.\r\n                            * The proper way to escape an END character\r\n                            * is to prepend an ESC_END byte with an ESC.\r\n                            */\r\n                           switch(c) {\r\n                           case ESC_END:\r\n                                   c = END;\r\n                                   break;\r\n                           case ESC_ESC:\r\n                                   c = ESC;\r\n                                   break;\r\n                           case END:\r\n                                   return received;\r\n                                   }",
    "notes": "The example implementation (function recv_packet()) would fail to terminate the packet if an ESC END (0333 0300) sequence were received. While the RFC doesn't address such a sequence, leaving its meaning ambiguous, this behavior ought to be considered erroneous, as the proper way to escape an END character is to produce an ESC ESC_END (0333 0334) sequence. An END character is used exclusively to terminate a packet; this behavior has a higher importance for the protocol than a non-standard way to escape an END byte.\r\n\r\nInspection of a relevant implementation of SLIP in the Linux kernel (see slip_unesc() in drivers/net/slip/slip.c as of commit e6b9dce0aeeb91dfc0974ab87f02454e24566182) shows the expected behavior, supporting this interpretation.\r\n\r\nI am unaware of any implementation that encodes an escaped END byte sequence as ESC END.\r\n\r\nIn view of this, I have modified the example implementation of the protocol in the SLIP DRIVERS sections to handle this erroneous sequence correctly. This should help prevent bugs in any future implementations written based on the example in the RFC.\r\n\r\nNote: A modern revision of the SLIP specification should explicitly address invalid escape sequences. While there is no consensus on handling improperly escaped arbitrary bytes (other than ESC_END, ESC_ESC, and END), handling ESC END as described is obvious and widely implemented.\r\n\r\nNote to RFC Editor: I tried to input \"SLIP DRIVERS\" into the Section field on this erratum, but the editor didn't accept it. RFC 1055 doesn't have numbered sections.\r\n",
    "submit_date": "2025-09-03",
    "submitter_name": "Michał K. Kłosowski",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2025-09-03 22:49:04"
  }
]
