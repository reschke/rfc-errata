[
  {
    "errata_id": 7086,
    "doc-id": "RFC7363",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "Global",
    "orig_text": "Server implementations of this specification MAY accept OAuth2.0\r\nclients that do not implement this extension.  If the \"code_verifier\"\r\nis not received from the client in the Authorization Request, servers\r\nsupporting backwards compatibility revert to the OAuth 2.0 [RFC6749]\r\nprotocol without this extension.\r\n\r\nAs the OAuth 2.0 [RFC6749] server responses are unchanged by this\r\nspecification, client implementations of this specification do not\r\nneed to know if the server has implemented this specification or not\r\nand SHOULD send the additional parameters as defined in Section 4 to\r\nall servers.\r\n",
    "correct_text": "Server implementations of this specification MAY accept OAuth2.0\r\nclients that do not implement this extension.  If the \"code_challenge\"\r\nis not received from the client in the Authorization Request, servers\r\nsupporting backwards compatibility revert to the OAuth 2.0 [RFC6749]\r\nprotocol without this extension.\r\n\r\nAs the OAuth 2.0 [RFC6749] server responses are unchanged by this\r\nspecification, client implementations of this specification do not\r\nneed to know if the server has implemented this specification or not\r\nand SHOULD send the additional parameters as defined in Section 4 to\r\nall servers.\r\n",
    "notes": "The code_verifier is not sent in the authorization request.",
    "submit_date": "2022-08-15",
    "submitter_name": "Keepn",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 7087,
    "doc-id": "RFC7363",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 7.3,
    "orig_text": " Salting the code_challenge\r\n\r\n   To reduce implementation complexity, salting is not used in the\r\n   production of the code challenge, as the code verifier contains\r\n   sufficient entropy to prevent brute-force attacks.  Concatenating a\r\n   publicly known value to a code verifier (containing 256 bits of\r\n   entropy) and then hashing it with SHA256 to produce a code challenge\r\n   would not increase the number of attempts necessary to brute force a\r\n   valid value for code verifier.\r\n\r\n   While the \"S256\" transformation is like hashing a password, there are\r\n   important differences.  Passwords tend to be relatively low-entropy\r\n   words that can be hashed offline and the hash looked up in a\r\n   dictionary.  By concatenating a unique though public value to each\r\n   password prior to hashing, the dictionary space that an attacker\r\n   needs to search is greatly expanded.\r\n\r\n   Modern graphics processors now allow attackers to calculate hashes in\r\n   real time faster than they could be looked up from a disk.  This\r\n   eliminates the value of the salt in increasing the complexity of a\r\n   brute-force attack for even low-entropy passwords.",
    "correct_text": " Salting the code_challenge\r\n\r\n   To reduce implementation complexity, salting is not used in the\r\n   production of the code challenge, as the code verifier contains\r\n   sufficient entropy to prevent brute-force attacks.  Concatenating a\r\n   publicly known value to a code verifier (containing 256 bits of\r\n   entropy) and then hashing it with SHA256 to produce a code challenge\r\n   would not increase the number of attempts necessary to brute force a\r\n   valid value for code verifier.\r\n\r\n   While the \"S256\" transformation is like hashing a password, there are\r\n   important differences.  Passwords tend to be relatively low-entropy\r\n   words that can be hashed offline and the hash looked up in a\r\n   dictionary.  By concatenating a unique though public value to each\r\n   password prior to hashing, the dictionary space that an attacker\r\n   needs to search is greatly expanded.\r\n\r\n   Modern graphics processors now allow attackers to calculate hashes in\r\n   real time faster than they could be looked up from a disk.  This\r\n   eliminates the value of the salt in increasing the complexity of a\r\n   brute-force attack for even low-entropy passwords.",
    "notes": "The section misrepresents the information about \"salting\" and the whole idea\r\nof \"salting\" is not applicable to a standalone hash. I suggest to drop the entire\r\nsection as irrelevant to the rest of the standard.\r\n\r\nFor some reason the section implies that \"salting\" is protecting and increasing\r\nentropy of a single hash, which is not what \"salting\" is about and is not the\r\nreason for the technique. The section is also making a speculative assumptions\r\nabout the low-entropy tendency in password hashes and makes an incorrect\r\nconclusion on the benefits of \"salting\" for a password hash.\r\n\r\nOne could argue that the entropy and the complexity required to bruteforce a hash\r\nand a salted hash for the same password (where the same hashing algorithm is\r\napplied) are approximately the same in most cases (or just slightly more\r\ncomplex for the salted version if the producer of the hash used a non-standard\r\nroutine in relation of mixing in the salt, e.g. instead of appending the salt\r\nit inserts in in the middle of the password to be hashed). In any case, that\r\npublic data is already known to the attacker and it is just a matter of the\r\nconfiguration for the bruteforcing tool (such as JohnTheRipper) to incorporate\r\nthe knowledge.\r\n\r\nJust as an illustration: consider an example password ('abc'), an example salt\r\n('123'), and that the hash is generated using a concatinated version of these\r\ntwo (e.g. HASH('abc123')). Since the salt is included with the hash in plain\r\ntext, the bruteforcer would just need to set their tool up with the \"^.*123$\"\r\npattern making the salt essentially a string terminator which is not affecting\r\nthe bruteforce effort in any way).\r\n\r\nMore and more people I meet are confused about the problem area the \"salting\"\r\ntechnique was invented to address: it is to increase the entropy of a set of\r\npasswords, so the same password would not result in the same hash value, with\r\nthe primary goal is to prevent attackers to be able to re-use pre-calculated\r\nhashes (e.g. rainbow hash tables) or, in the early stages of the attack, to\r\nmake it impossible to quickly assess what hashes the attacker should focus on\r\n(e.g. when you have 1000 hashes and without salts you can easily spot that\r\nsome hashes are the same, which means breaking these one would gain much more\r\nin comparison to unique hashes in the same set).\r\n\r\nThis being said, I am suggesting to drop section 7.3 completely as irrelevant,\r\nsince what we currently have is very confusing and seeds unnecessary and\r\nwrong ideas that \"salting\" can improve the security of a single hash by itself.",
    "submit_date": "2022-08-15",
    "submitter_name": "Keepn",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 7088,
    "doc-id": "RFC7363",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 7.1,
    "orig_text": "The client SHOULD create a \"code_verifier\" with a minimum of 256 bits\r\nof entropy.  This can be done by having a suitable random number\r\ngenerator create a 32-octet sequence.  The octet sequence can then be\r\nbase64url-encoded to produce a 43-octet URL safe string to use as a\r\n\"code_challenge\" that has the required entropy.",
    "correct_text": "The client SHOULD create a \"code_verifier\" with a minimum of 256 bits\r\nof entropy.  This can be done by having a suitable random number\r\ngenerator create a 32-octet sequence.  The octet sequence can then be\r\nbase64url-encoded to produce a 43-octet URL safe string to use as a\r\n\"code_verifier\" that has the required entropy.",
    "notes": "The \"32-octet sequence\" referenced in the original text seems to be inconsistent with Section 4.1, which states that the minimum length of the code_verifier is 43 characters. It would be consistent by changing \"code_challenge\" to \"code_verifier\".",
    "submit_date": "2022-08-15",
    "submitter_name": "Keepn",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  }
]
