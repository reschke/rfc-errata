[
  {
    "errata_id": "7925",
    "doc-id": "RFC9497",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "4.3",
    "orig_text": "HashToScalar():  Use hash_to_field from [RFC9380] using L = 48,\r\n         expand_message_xmd with SHA-256, DST = \"HashToScalar-\" ||\r\n         contextString, and a prime modulus equal to Group.Order().",
    "correct_text": "HashToScalar():  Compute uniform_bytes using expand_message =\r\n         expand_message_xmd, DST = \"HashToScalar-\" || contextString, and\r\n         an output length of 48 bytes, interpret uniform_bytes as a\r\n         384-bit integer in little-endian order, and reduce the integer\r\n         modulo Group.Order().",
    "notes": "It is incorrect to refer to the hash_to_filed operation of RFC 9380 because the implementation of hash_to_field, as described in section 5.2 of RFC 9380 reduces the result integer mod Field order (not Group order).\r\n\r\n 7.     e_j = OS2IP(tv) mod p\r\n\r\nWhere p is the characteristic of field F.\r\n\r\nThe current text imply that the existing hash_to_field implementation for P-256 can be used. But using this will cause a false result due to the mod field order operation.\r\n\r\nThe a better, and accurate way to describe this is by using the same explanation as for other curve types and specify the use of expand_message_xmd directly modulus Group.Order().\n --VERIFIER NOTES-- \nDiscussed on CFRG list. The original text is correct, see https://mailarchive.ietf.org/arch/msg/cfrg/YLqRy76LFlVzeOofGyQiYeDhAuM/",
    "submit_date": "2024-05-07",
    "submitter_name": "Stefan Santesson",
    "verifier_id": "163",
    "verifier_name": "Colin Perkins",
    "update_date": "2024-05-20 15:51:25"
  },
  {
    "errata_id": "7999",
    "doc-id": "RFC9497",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "3.3.3",
    "orig_text": "evaluatedElement = G.ScalarInverse(t) * blindedElement\r\n",
    "correct_text": "evaluatedElement = t * blindedElement\r\n",
    "notes": "This appears in def BlindEvaluate(skS, blindedElement, info). It seems that the evaluatedElement=t * blindedElement, which is consistent with tweakedKey = t * G.Generator()\r\n\r\n\r\nVerified on CFRG list by co-author with note: I would also change \"0\" to \"seq = 0\"\r\n\n --VERIFIER NOTES-- \nNo change needed. RFC 9497 defines GenerateProof(k, A, B, C, D) to prove k*A = B and k*C[i] = D[i] (Section 2.2.1). In POPRF BlindEvaluate (Section 3.3.3) the proof is generated as GenerateProof(t, G.Generator(), tweakedKey, evaluatedElements, blindedElements), so the element relation being proven is t*evaluatedElement = blindedElement. This is consistent with evaluatedElement being defined as ScalarInverse(t) * blindedElement, since t*(ScalarInverse(t)*blindedElement) = blindedElement. The likely source of confusion is comparing with VOPRF, where the proof wiring uses the opposite direction for the element lists.",
    "submit_date": "2024-06-24",
    "submitter_name": "Quanwei Cai",
    "verifier_id": "182",
    "verifier_name": "Nick Sullivan",
    "update_date": "2026-01-27 13:40:39"
  },
  {
    "errata_id": "8392",
    "doc-id": "RFC9497",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4",
    "orig_text": "RandomScalar():  Implemented by returning a uniformly random\r\n         Scalar in the range [0, G.Order() - 1].",
    "correct_text": "RandomScalar():  Implemented by returning a uniformly random\r\n         Scalar in the range [1, G.Order() - 1].",
    "notes": "Section 2.1 (https://www.rfc-editor.org/rfc/rfc9497#section-2.1-4.12) states:\r\n> Chooses at random a nonzero element in GF(p).\r\n\r\nSo `RandomScalar()` implementations can't return 0.\r\n\r\n--VERIFIER NOTE--\r\nVerified. Section 2.1 requires nonzero; this fix aligns Section 4 with that requirement. EID 8393 addresses related Section 4.7 implementation guidance (held pending fix text revision).",
    "submit_date": "2025-04-25",
    "submitter_name": "daxpedda",
    "verifier_id": "182",
    "verifier_name": "Nick Sullivan",
    "update_date": "2026-01-27 12:38:25"
  },
  {
    "errata_id": "8393",
    "doc-id": "RFC9497",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "4.7",
    "orig_text": "4.7.1.  Rejection Sampling\r\n\r\n   Generate a random byte array with Ns bytes and attempt to map to a\r\n   Scalar by calling DeserializeScalar in constant time.\r\n   ...\r\n\r\n4.7.2.  Random Number Generation Using Extra Random Bits\r\n\r\n   Generate a random byte array with L = ceil(((3 *\r\n   ceil(log2(G.Order()))) / 2) / 8) bytes, and interpret it as an\r\n   integer; reduce the integer modulo G.Order(), and return the result.",
    "correct_text": "4.7.1.  Rejection Sampling\r\n\r\n   Generate a random byte array with Ns bytes and attempt to map to a\r\n   Scalar by calling DeserializeScalar and checking for a nonzero Scalar\r\n   in constant time.\r\n   ...\r\n\r\n4.7.2.  Random Number Generation Using Extra Random Bits\r\n\r\n   Generate a random byte array with L = ceil(((3 *\r\n   ceil(log2(G.Order()))) / 2) / 8) bytes, and interpret it as an\r\n   integer; reduce the integer modulo G.Order() - 1, 1, and return the\r\n   result.",
    "notes": "Section 2.1 states: \"Chooses at random a nonzero element\r\nin GF(p).\" So RandomScalar() implementations can't return 0.\r\n\r\nFor rejection sampling I recommend changing DeserializeScalar()\r\nto check for nonzero Scalar and decline those. My suggested\r\nerrata is a compromise to keep the change specific.\r\n\r\nFor \"Random Number Generation Using Extra Random Bits\" my\r\nsuggestion follows FIPS 186-5 A.2.1.\r\n\r\n--VERIFIER NOTE--\r\nHeld for document update. The underlying issue (RandomScalar\r\nmust exclude zero) is valid and addressed by EID 8392, which\r\nfixes the Section 4 range to [1, G.Order()-1]. This erratum's\r\nproposed text for Section 4.7 is unclear (\"modulo G.Order() -\r\n1, 1\"). For implementers: the correct approach per FIPS 186-5\r\nA.2.1 is (random mod (G.Order()-1)) + 1, producing scalars in\r\n[1, G.Order()-1].",
    "submit_date": "2025-04-25",
    "submitter_name": "daxpedda",
    "verifier_id": "182",
    "verifier_name": "Nick Sullivan",
    "update_date": "2026-01-27 12:47:35"
  },
  {
    "errata_id": "8575",
    "doc-id": "RFC9497",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "Appendix A",
    "orig_text": "\"EvaluatedElement\":  The evaluated element output by BlindEvaluate(),\r\n      a serialized Element of Ne bytes long.",
    "correct_text": "\"EvaluationElement\":  The evaluated element output by BlindEvaluate(),\r\n      a serialized Element of Ne bytes long.",
    "notes": "To match the identifier used in all subsequent test vectors. There is still a slight inconsistency, as \"EvaluatedElement\" is used throughout the RFC and \"EvaluationElement\" is used uniquely in \"Appendix A. Test Vectors\".\n --VERIFIER NOTES-- \nRejected. The proposed fix changes the header definition to match the test vector data, but the data itself is inconsistent with the RFC body, which uses \"evaluatedElement\" throughout the protocol specification. The correct fix is to change the test vector field names from \"EvaluationElement\" to \"EvaluatedElement\" to align with the protocol specification. A new erratum will be filed with the correct fix.",
    "submit_date": "2025-09-12",
    "submitter_name": "Charles Edward Gagnon",
    "verifier_id": "182",
    "verifier_name": "Nick Sullivan",
    "update_date": "2026-01-27 09:44:27"
  },
  {
    "errata_id": "8720",
    "doc-id": "RFC9497",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "Appendix A",
    "orig_text": "EvaluationElement",
    "correct_text": "EvaluatedElement",
    "notes": "The test vector field name \"EvaluationElement\" is inconsistent with the RFC body, which uses \"evaluatedElement\" throughout (Sections 3.3.1-3.3.3). The Appendix A header correctly defines \"EvaluatedElement\" but the test vector data entries use \"EvaluationElement\" instead.\r\n\r\nAffected locations (all within Appendix A test vectors):\r\n- A.1.1.1, A.1.1.2 (ristretto255-SHA512 OPRF): 2 occurrences\r\n- A.1.2.1, A.1.2.2, A.1.2.3 (ristretto255-SHA512 VOPRF): 4 occurrences\r\n- A.1.3.1, A.1.3.2, A.1.3.3 (ristretto255-SHA512 POPRF): 3 occurrences\r\n- A.2.1.1, A.2.1.2 (decaf448-SHAKE256 OPRF): 2 occurrences\r\n- A.2.2.1, A.2.2.2, A.2.2.3 (decaf448-SHAKE256 VOPRF): 4 occurrences\r\n- A.2.3.1, A.2.3.2, A.2.3.3 (decaf448-SHAKE256 POPRF): 3 occurrences\r\n- A.3.1.1, A.3.1.2 (P256-SHA256 OPRF): 2 occurrences\r\n- A.3.2.1, A.3.2.2, A.3.2.3 (P256-SHA256 VOPRF): 4 occurrences\r\n- A.3.3.1, A.3.3.2, A.3.3.3 (P256-SHA256 POPRF): 3 occurrences\r\n- A.4.1.1, A.4.1.2 (P384-SHA384 OPRF): 2 occurrences\r\n- A.4.2.1, A.4.2.2, A.4.2.3 (P384-SHA384 VOPRF): 4 occurrences\r\n- A.4.3.1, A.4.3.2, A.4.3.3 (P384-SHA384 POPRF): 3 occurrences\r\n- A.5.1.1, A.5.1.2 (P521-SHA512 OPRF): 2 occurrences\r\n- A.5.2.1, A.5.2.2, A.5.2.3 (P521-SHA512 VOPRF): 4 occurrences\r\n- A.5.3.1, A.5.3.2, A.5.3.3 (P521-SHA512 POPRF): 3 occurrences\r\n\r\nTotal: 45 occurrences across all test vectors.\r\n\r\nSupersedes EID 8575 (rejected) which proposed fixing the header instead of the data.\r\n\r\n--VERIFIER NOTE--\r\nVerified. Test vector field names should match RFC body terminology.",
    "submit_date": "2026-01-27",
    "submitter_name": "Nick Sullivan",
    "verifier_id": "182",
    "verifier_name": "Nick Sullivan",
    "update_date": "2026-01-27 20:10:56"
  }
]
