[
  {
    "errata_id": "3732",
    "doc-id": "RFC7011",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "1.1",
    "orig_text": "A new Section 5.2 has been added to address wraparound of these\r\n     timestamp data types after they overflow in the years 2032-2038.\r\n",
    "correct_text": "A new Section 5.2 has been added to address wraparound of these\r\n    timestamp data types after they overflow.",
    "notes": "Since dateTimeSeconds is encoded in an _unsigned_ integer, it will wraparound in 2106 (as written correctly in section 5.2), not 2038.",
    "submit_date": "2013-09-21",
    "submitter_name": "Stéphane Bortzmeyer",
    "verifier_id": "132",
    "verifier_name": "Benoit Claise",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4216",
    "doc-id": "RFC7011",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "3.4.2.2",
    "orig_text": "   Scope Field Count\r\n\r\n      Number of scope fields in this Options Template Record.  The Scope\r\n      Fields are normal Fields, except that they are interpreted as\r\n      scope at the Collector.  A scope field count of N specifies that\r\n      the first N Field Specifiers in the Template Record are Scope\r\n      Fields.  The Scope Field Count MUST NOT be zero.",
    "correct_text": "   Scope Field\r\n\r\n      Scope Fields are normal Fields, except that they are interpreted\r\n      as scope at the Collector.\r\n\r\n   Scope Field Count\r\n\r\n      Number of scope fields in this Options Template Record.\r\n      A scope field count of N specifies that\r\n      the first N Field Specifiers in the Template Record are Scope\r\n      Fields.  The Scope Field Count MUST NOT be zero.",
    "notes": "Separate out the \"Scope Field\" definition from \"Scope Field Count\", since \"Scope Field\" is used as a defined term throughout the document without a formal definition.",
    "submit_date": "2014-12-31",
    "submitter_name": "Paul Aitken",
    "verifier_id": "132",
    "verifier_name": "Benoit Claise",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4396",
    "doc-id": "RFC7011",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "3.1",
    "orig_text": "Incremental sequence counter modulo 2^32 of all IPFIX Data Records\r\nsent in the current stream from the current Observation Domain by\r\nthe Exporting Process.",
    "correct_text": "Incremental sequence counter modulo 2^32 of all IPFIX Data Records\r\nsent in the current stream from the current Observation Domain by\r\nthe Exporting Process, prior to the receipt of this IPFIX Message.",
    "notes": "The original specification can be interpreted in two ways:\r\n\r\n(1) Incremental sequence counter modulo 2^32 of all IPFIX Data Records sent in the current stream from the current Observation Domain by the Exporting Process *up to* this Message.\r\n(2) Incremental sequence counter modulo 2^32 of all IPFIX Data Records sent in the current stream from the current Observation Domain by the Exporting Process *up to and including* this Message.\r\n\r\nIt seems that only Section 10.3.2 — Reliability explains which of the two interpretations is right: In the case of UDP, the IPFIX Sequence Number contains the total number of IPFIX Data Records sent for the Transport Session *prior* to the receipt of this IPFIX Message, modulo 2^32.\r\n\r\nIn my opinion, it would be good to clarify the use of sequence numbers in Message headers already in the definition of sequence numbers in RFC 7011, namely in Section 3.1.\r\n\r\nDiscussed here: https://mailarchive.ietf.org/arch/msg/ipfix/AQKObQ2WA_zIXgRzdxRsDrIWjx0",
    "submit_date": "2015-06-19",
    "submitter_name": "Rick Hofstede",
    "verifier_id": "132",
    "verifier_name": "Benoit Claise",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "7413",
    "doc-id": "RFC7011",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "3.4.1",
    "orig_text": "Field Count\r\n\r\n      Number of fields in this Template Record.",
    "correct_text": "Field Count\r\n\r\nNumber of fields in this Template Record. The Field Count MUST NOT be zero, unless used in a Template Withdrawal.",
    "notes": "If the size of data record corresponding to a template can ever be zero, then  the only valid size for such a data set is the size of the set header.  For normal cases any size greater than that of the set header is a valid size, since records are read from a set until the number of octets remaining is less than the smallest possible record size for that set.  If a record size can be zero, then any number of bytes past the header cannot be padding (is not smaller than the smallest record), and a conforming implementation might return an infinite number of zero-sized records.  As this could cause a denial of service situation, rejecting templates that define zero-sized records seems to be the simplest solution.\r\n\r\nSimilar text may be necessary for Option Template records, though the fact that the scope count MUST be non-zero may negate the necessity.\r\n\r\n---\r\nWK: See thread https://mailarchive.ietf.org/arch/msg/ipfix/AkCZr1jObLt_x9cyQ73qXBlKC2w/ for more info.\r\nWK -  2023-04-26: Update from the original reporter (Michael) and confirmations from authors (Brian and Benoit) that Field Count can be zero in the case of Template Withdrawal. Changing the state from Verified to HFDU, so that this can be better clarified in any future updates. ",
    "submit_date": "2023-04-02",
    "submitter_name": "Michael Duggan",
    "verifier_id": "155",
    "verifier_name": "Wa",
    "update_date": "2023-04-26 12:02:34"
  },
  {
    "errata_id": "7875",
    "doc-id": "RFC7011",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "6.2",
    "orig_text": "   Reduced-size encoding MAY be applied to the following integer types:\r\n   unsigned64, signed64, unsigned32, signed32, unsigned16, and signed16.\r\n   The signed versus unsigned property of the reported value MUST be\r\n   preserved.  The reduction in size can be to any number of octets\r\n   smaller than the original type if the data value still fits, i.e., so\r\n   that only leading zeroes are dropped.  For example, an unsigned64 can\r\n   be reduced in size to 7, 6, 5, 4, 3, 2, or 1 octet(s).",
    "correct_text": "   Reduced-size encoding MAY be applied to the following integer types:\r\n   unsigned64, signed64, unsigned32, signed32, unsigned16, and signed16.\r\n   The signed versus unsigned property of the reported value MUST be\r\n   preserved. The reduction in size can be to any number of octets\r\n   smaller than the original type if the data value still fits, i.e., so\r\n   that only leading zeroes are dropped (Or, in the case of negative\r\n   signed values, so that only leading ones are dropped). For example,\r\n   an unsigned64 can be reduced in size to 7, 6, 5, 4, 3, 2, or 1 octet(s).",
    "notes": "As written, the specification suggests that integer values may only be encoded using a reduced-size encoding if they have a run of zeroes at the beginning. However, the specification also describes being able to use reduced-size encoding for signed integer values—and only non-negative values of signed integers have a representation that begins with zeroes.\r\n\r\nEither the text should clarify that negative values may never be expressed using a reduced-size encoding (which is what the strictest reading of the current text would suggest), or it should specify that leading ones may also be dropped for signed values, which makes it clear that they should be interpreted via sign extension of the high bit.\r\n\r\nA quick survey of existing IPFIX implementations suggests that those which decode reduced-size encoding of integers at all produce the semantic equivalent of sign extension when they encounter a reduced-size encoding of a signed integer value.\r\n\r\n-- \r\nWK: Thread (for posterity): https://mailarchive.ietf.org/arch/msg/ipfix/sBsLy-XYH8sQCEjnPSGoEKsRL9Y/\r\n",
    "submit_date": "2024-03-28",
    "submitter_name": "Katherine Prevost",
    "verifier_id": "155",
    "verifier_name": "Warren Kumari (Ops AD)",
    "update_date": "2024-04-04 06:39:34"
  },
  {
    "errata_id": "8313",
    "doc-id": "RFC7011",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "3.2",
    "orig_text": "   E\r\n\r\n      Enterprise bit.  This is the first bit of the Field Specifier.  If\r\n      this bit is zero, the Information Element identifier identifies an\r\n      Information Element in [IANA-IPFIX], and the four-octet Enterprise\r\n      Number field MUST NOT be present.  If this bit is one, the\r\n      Information Element identifier identifies an enterprise-specific\r\n      Information Element, and the Enterprise Number field MUST be\r\n      present.\r\n\r\n   Information Element identifier\r\n\r\n      A numeric value that represents the Information Element.  Refer to\r\n      [IANA-IPFIX].",
    "correct_text": "   E\r\n\r\n      Enterprise bit.  This is the first bit of the Field Specifier.  If\r\n      this bit is zero, the Information Element identifier identifies an\r\n      Information Element in [IANA-IPFIX], and the four-octet Enterprise\r\n      Number field MUST NOT be present.  If this bit is one, the\r\n      Information Element identifier identifies an enterprise-specific\r\n      Information Element, and the Enterprise Number field MUST be\r\n      present.\r\n\r\n   Information Element identifier\r\n\r\n      A numeric value that represents the Information Element. This field\r\n      takes a value in [IANA-IPFIX] when the E bit is set to zero.",
    "notes": "Makes it explicit that the values in [IANA-IPFIX] only applies when the is E-bit is unset. \r\n\r\nAn alternative would be to simply delete \"Refer to [IANA-IPFIX].\" as the exact behavior is already mentioned under the E bit description.",
    "submit_date": "2025-02-25",
    "submitter_name": "Mohamed Boucadair",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  }
]
