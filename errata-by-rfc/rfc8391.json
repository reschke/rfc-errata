[
  {
    "errata_id": "5572",
    "doc-id": "RFC8391",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.1.5",
    "orig_text": "Input: WOTS+ public key pk, address ADRS, seed SEED",
    "correct_text": "Input: WOTS+ public key pk, seed SEED, address ADRS",
    "notes": "ltree is called twice as ltree(pk, seed, adr).",
    "submit_date": "2018-12-10",
    "submitter_name": "Franziskus Kiefer",
    "verifier_id": "163",
    "verifier_name": "Colin Perkins",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5573",
    "doc-id": "RFC8391",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.1.6",
    "orig_text": "Output: n-byte root node - top node on Stack",
    "correct_text": "Output: n-byte root node - top node on Stack or -1",
    "notes": "The algorithm can fail and might return -1 instead of a root node",
    "submit_date": "2018-12-10",
    "submitter_name": "Franziskus Kiefer",
    "verifier_id": "163",
    "verifier_name": "Colin Perkins",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "6024",
    "doc-id": "RFC8391",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "5",
    "orig_text": "This section provides basic parameter sets that are assumed to cover most relevant applications.  Parameter sets for two classical security levels are defined.  Parameters with n = 32 provide a classical security level of 256 bits.  Parameters with n = 64 provide a classical security level of 512 bits.  Considering quantum-computer-aided attacks, these output sizes yield post-quantum security of 128 and 256 bits, respectively.",
    "correct_text": "This section provides basic parameter sets that are assumed to cover most relevant applications. Parameter sets for two classical security levels are defined using the cryptographic functions SHA2 and SHAKE.  Parameters with SHA2 and n = 32 provide a classical security level of 256 bits. Parameters with SHA2 and n = 64 provide a classical security level of 512 bits.  Considering quantum-computer-aided attacks, these parameters yield post-quantum security of 128 and 256 bits, respectively. Parameters with SHAKE and n = 32 provide a classical security level of 128 bits.  Parameters with SHAKE and n = 64 provide a classical security level of 256 bits.  Considering quantum-computer-aided attacks, these parameters yield post-quantum security of 86 and 170 bits, respectively. ",
    "notes": "Traditionally, a hash function with n-bit outputs is assumed to have n-bit security against classical preimage and second-preimage attacks, and n/2-bit security against classical collision attacks. For adversaries with access to a quantum computer, these bounds change to n/2 and n/3 bits when only counting queries to the hash function. This also applies to SHA2 and SHA3. In contrast, SHAKE follows a different reasoning. SHAKE with an internal state of n bits and an output length of n bits achieves n/2 bit security against classical preimage, second-preimage and collision attacks. For quantum attacks security changes to n/3 bits. The reason is that SHAKE allows for meet-in-the-middle preimage attacks that reduce to a collision search on the internal state. \r\n   \r\n In consequence, SHAKE-128 cannot provide more security than NIST post-quantum security level II.\r\n\r\n(Errata submitted by Andreas Hülsing; notes slightly revised after Crypto Forum review by Scott Fluhrer; verified by CFRG Chairs and IRTF Chair)",
    "submit_date": "2020-03-18",
    "submitter_name": "Andreas Hülsing",
    "verifier_id": "163",
    "verifier_name": "Colin Perkins",
    "update_date": "2020-06-23 01:16:29"
  },
  {
    "errata_id": "6352",
    "doc-id": "RFC8391",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "Appendix A",
    "orig_text": "The WOTS+ signature and public key formats are formally defined using\r\nXDR [RFC4506] in order to provide an unambiguous, machine readable\r\ndefinition. ",
    "correct_text": "The WOTS+ signature and public key formats are defined in a syntax similar to XDR [RFC4506].",
    "notes": "The definition is not machine readable, e.g. github.com/stellar/xdrgen fails. \r\nReason:\r\n- some Identifiers contain \"/\" and \"-\", RFC4506 allows only letter, digits and underbars\r\n- some enum bodies end with  \",}\", RFC4506 requests \"}\" here\r\n- some discriminated union definitions have incomplete declarations in the case-spec, e.g. the union xmss_ots_signature refers to the wotsp-sha2_256 without giving a type. \r\n- The encoding of some unions in the reference implementation is different to the encoding specified in RFC4506. The 4-byte discriminant is missing.\r\n\r\n\r\nHold for document update.\r\n\r\nCFRG co-chair: Errata 6352 addresses XDR syntax alignment for WOTS+ format definitions in Appendix A of RFC 8391. While it does not impact cryptographic functionality, this adjustment clarifies encoding for automated implementations, benefiting future document versions.\r\nBas Westerbaan on CFRG list: changes the text, but doesn't propose to change the format.",
    "submit_date": "2020-12-09",
    "submitter_name": "Andreas Kretschmer",
    "verifier_id": "182",
    "verifier_name": "Nick Sullivan",
    "update_date": "2025-01-18 10:51:48"
  },
  {
    "errata_id": "6821",
    "doc-id": "RFC8391",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "3.1.5",
    "orig_text": "\"Note that the checksum may reach a maximum integer value of len_1 * (w - 1) * 2^8\"",
    "correct_text": "\"Note that the checksum may reach a maximum integer value of len_1 * (w - 1)\"",
    "notes": "The \"* 2^8\" appears to be a mistake. If the checksum integers could reach those values, the checksum field would overflow, which would potentially allow an attacker to forge a message.\r\n\r\nIn reality, the correct maximum is just \"len_1 * (w - 1)\"\r\n\r\n\r\nVerified on CFRG list by Bas Westerbaan.",
    "submit_date": "2022-01-24",
    "submitter_name": "Peter Gordon",
    "verifier_id": "182",
    "verifier_name": "Nick Sullivan",
    "update_date": "2025-01-18 10:52:27"
  },
  {
    "errata_id": "7412",
    "doc-id": "RFC8391",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.6 (Algorithm 1)",
    "orig_text": "bits += 8;",
    "correct_text": "bits = 8;",
    "notes": "\"bits += 8;\" is misleading and results in one useless addition. \r\n\r\nThis is true because this instruction appears after the program ensured that \"bits == 0\".\r\n\r\nTherefore, \"bits = 8;\" is the actual instruction that should be executed here.",
    "submit_date": "2023-04-02",
    "submitter_name": "Rafael Misoczki",
    "verifier_id": "163",
    "verifier_name": "Colin Perkins",
    "update_date": "2023-04-10 10:11:14"
  },
  {
    "errata_id": "7420",
    "doc-id": "RFC8391",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.2.2",
    "orig_text": "// Generate reduced XMSS private keys\r\n     ADRS = toByte(0, 32);\r\n     for ( layer = 0; layer < d; layer++ ) {\r\n        ADRS.setLayerAddress(layer);\r\n        for ( tree = 0; tree <\r\n              (1 << ((d - 1 - layer) * (h / d)));\r\n              tree++ ) {\r\n           ADRS.setTreeAddress(tree);\r\n           for ( i = 0; i < 2^(h / d); i++ ) {\r\n             wots_sk[i] = WOTS_genSK();\r\n           }\r\n           setXMSS_SK(SK_MT, wots_sk, tree, layer);\r\n        }\r\n     }",
    "correct_text": "// Generate reduced XMSS private keys\r\n     ADRS = toByte(0, 32);\r\n     for ( layer = 0; layer < d; layer++ ) {\r\n        ADRS.setLayerAddress(layer);\r\n        for ( tree = 0; tree <\r\n              (1 << ((d - 1 - layer) * (h / d)));\r\n              tree++ ) {\r\n           ADRS.setTreeAddress(tree);\r\n           for ( i = 0; i < 2^(h / d); i++ ) {\r\n             wots_sk[i] = WOTS_genSK();\r\n           }\r\n           setXMSS_SK(SK_MT, wots_sk, tree, layer, ADRS);\r\n        }\r\n     }",
    "notes": "The ADRS variable is created and configured (layer address and tree address fields set) but it is not used anywhere in the for-loop. \r\n\r\nIt would be more precise if the setXMSS_SK function receives the ADRS variable so that implementers understand that both layer address and tree address fields must be set as defined in this for-loop in order to generate the correct XMSS private key in each iteration of this loop.",
    "submit_date": "2023-04-11",
    "submitter_name": "Rafael Misoczki",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7900",
    "doc-id": "RFC8391",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "4.1.",
    "orig_text": "An XMSS private key SK contains 2^h WOTS+ private keys, the leaf\r\nindex idx of the next WOTS+ private key that has not yet been used,\r\nSK_PRF (an n-byte key to generate pseudorandom values for randomized\r\nmessage hashing), the n-byte value root (which is the root node of\r\nthe tree and SEED), and the n-byte public seed used to pseudorandomly\r\ngenerate bitmasks and hash function keys.",
    "correct_text": "An XMSS private key SK contains 2^h WOTS+ private keys, the leaf\r\nindex idx of the next WOTS+ private key that has not yet been used,\r\nSK_PRF (an n-byte key to generate pseudorandom values for randomized\r\nmessage hashing), the n-byte value root (which is the root node of\r\nthe tree), and SEED (the n-byte public seed used to pseudorandomly\r\ngenerate bitmasks and hash function keys).",
    "notes": "SEED appearing in the parenthesis explaining the root value is confusing. It has to be paired with the explanation of it that follows.\r\n\r\nErrata verified by Andreas Hülsing, 2024-04-22",
    "submit_date": "2024-04-18",
    "submitter_name": "Çağdaş Çalık",
    "verifier_id": "163",
    "verifier_name": "Colin Perkins",
    "update_date": "2024-04-22 15:01:25"
  },
  {
    "errata_id": "8382",
    "doc-id": "RFC8391",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "3.1.4",
    "orig_text": "Input: WOTS+ private key sk, address ADRS, seed SEED",
    "correct_text": "Input: WOTS+ private key sk, seed SEED, address ADRS",
    "notes": "When `WOTS_genPK` is called in `treeHash`, it is called as `WOTS_genPK (getWOTS_SK(SK, s + i), SEED, ADRS)`. By swapping the `SEED` and `ADRS` arguments in `WOTS_genPK` this aligns with the API change from Errata ID 5572.",
    "submit_date": "2025-04-16",
    "submitter_name": "Alex J Malozemoff",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "8383",
    "doc-id": "RFC8391",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "3.1.5",
    "orig_text": "Input: Message M, WOTS+ private key sk, address ADRS, seed SEED",
    "correct_text": "Input: private key sk, Message M, WOTS+ seed SEED, address ADRS",
    "notes": "When used in Algorithm 11 it is called as `WOTS_sign(getWOTS_SK(SK, idx_sig), M', getSEED(SK), ADRS);` that is, the secret key comes first, then the message, then the seed, then finally the address.",
    "submit_date": "2025-04-16",
    "submitter_name": "Alex J Malozemoff",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "8396",
    "doc-id": "RFC8391",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.1.10",
    "orig_text": "pk_ots = WOTS_pkFromSig(sig_ots, M', SEED, ADRS);",
    "correct_text": "pk_ots = WOTS_pkFromSig(M', sig_ots, ADRS, SEED);",
    "notes": "The call to `WOTS_pkFromSig` in `XMSS_rootFromSig` does not match the signature of Algorithm 6 (Section 3.1.6).",
    "submit_date": "2025-04-28",
    "submitter_name": "Alex J Malozemoff",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "8424",
    "doc-id": "RFC8391",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.1.3",
    "orig_text": "An XMSS private key SK contains 2^h WOTS+ private keys, ...",
    "correct_text": "An XMSS private key SK contains an algorithm OID, 2^h WOTS+ private keys, ...",
    "notes": "Section 4.1.3 makes no mention of an OID; however, the reference spec includes one with the following comment: \"For an implementation that uses runtime parameters, it is crucial that the OID is part of the secret key as well; i.e. not just for interoperability, but also for internal use.\"\r\n\r\nThis would suggest that an OID should be included as part of the private key in Section 4.1.3.",
    "submit_date": "2025-05-19",
    "submitter_name": "Alex J Malozemoff",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "8534",
    "doc-id": "RFC8391",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "3.1.1",
    "orig_text": "Choices of w are limited to the values 4 and 16 since these values yield optimal trade-offs and easy implementation.",
    "correct_text": "Choices of w are limited to the values 4 and 16 since these values yield optimal trade-offs and easy implementation.\r\n\r\nNOTE: Instantiating w and n with values not specified here may require changes to the algorithms as they are described in this RFC, for correctness and security. In particular, Algorithm 1 (Section 2.6) is incorrect for values of w larger than 256. Algorithms 5 and 6 (Sections 3.1.5 and 3.1.6) yield an insecure signature scheme when instantiated with parameters n and w such that len_2 * lg(w) is divisible by 8 (for example, with w = 256 and any value of n).",
    "notes": "This additional note aims at future-proofing the RFC against unchecked extensions to the parameter set.\r\n\r\nAlgorithm 1 when w > 256 may lead to an insecure instantiation.\r\n\r\nInstantiating Algorithms 5 and 6 with w = 256 (and any value of n) or some other (n, w) pair such that len_2 * lg(w) is divisible by 8 leads to immediate forgery attacks: the value of csum gets multiplied by 2^8 (shifted left by 8), but its big-endian encoding (with toByte) does not take this into account and drops the most significant base w word(s) of the checksum.",
    "submit_date": "2025-08-19",
    "submitter_name": "François Dupressoir",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  }
]
