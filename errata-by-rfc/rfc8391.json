[
  {
    "errata_id": "5572",
    "doc-id": "RFC8391",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.1.5",
    "orig_text": "Input: WOTS+ public key pk, address ADRS, seed SEED",
    "correct_text": "Input: WOTS+ public key pk, seed SEED, address ADRS",
    "notes": "ltree is called twice as ltree(pk, seed, adr).",
    "submit_date": "2018-12-10",
    "submitter_name": "Franziskus Kiefer",
    "verifier_id": "163",
    "verifier_name": "Colin Perkins",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5573",
    "doc-id": "RFC8391",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.1.6",
    "orig_text": "Output: n-byte root node - top node on Stack",
    "correct_text": "Output: n-byte root node - top node on Stack or -1",
    "notes": "The algorithm can fail and might return -1 instead of a root node",
    "submit_date": "2018-12-10",
    "submitter_name": "Franziskus Kiefer",
    "verifier_id": "163",
    "verifier_name": "Colin Perkins",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "6024",
    "doc-id": "RFC8391",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "5",
    "orig_text": "This section provides basic parameter sets that are assumed to cover most relevant applications.  Parameter sets for two classical security levels are defined.  Parameters with n = 32 provide a classical security level of 256 bits.  Parameters with n = 64 provide a classical security level of 512 bits.  Considering quantum-computer-aided attacks, these output sizes yield post-quantum security of 128 and 256 bits, respectively.",
    "correct_text": "This section provides basic parameter sets that are assumed to cover most relevant applications. Parameter sets for two classical security levels are defined using the cryptographic functions SHA2 and SHAKE.  Parameters with SHA2 and n = 32 provide a classical security level of 256 bits. Parameters with SHA2 and n = 64 provide a classical security level of 512 bits.  Considering quantum-computer-aided attacks, these parameters yield post-quantum security of 128 and 256 bits, respectively. Parameters with SHAKE and n = 32 provide a classical security level of 128 bits.  Parameters with SHAKE and n = 64 provide a classical security level of 256 bits.  Considering quantum-computer-aided attacks, these parameters yield post-quantum security of 86 and 170 bits, respectively. ",
    "notes": "Traditionally, a hash function with n-bit outputs is assumed to have n-bit security against classical preimage and second-preimage attacks, and n/2-bit security against classical collision attacks. For adversaries with access to a quantum computer, these bounds change to n/2 and n/3 bits when only counting queries to the hash function. This also applies to SHA2 and SHA3. In contrast, SHAKE follows a different reasoning. SHAKE with an internal state of n bits and an output length of n bits achieves n/2 bit security against classical preimage, second-preimage and collision attacks. For quantum attacks security changes to n/3 bits. The reason is that SHAKE allows for meet-in-the-middle preimage attacks that reduce to a collision search on the internal state. \r\n   \r\n In consequence, SHAKE-128 cannot provide more security than NIST post-quantum security level II.\r\n\r\n(Errata submitted by Andreas Hülsing; notes slightly revised after Crypto Forum review by Scott Fluhrer; verified by CFRG Chairs and IRTF Chair)",
    "submit_date": "2020-03-18",
    "submitter_name": "Andreas Hülsing",
    "verifier_id": "163",
    "verifier_name": "Colin Perkins",
    "update_date": "2020-06-23 01:16:29"
  },
  {
    "errata_id": "6352",
    "doc-id": "RFC8391",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "Appendix A",
    "orig_text": "The WOTS+ signature and public key formats are formally defined using\r\nXDR [RFC4506] in order to provide an unambiguous, machine readable\r\ndefinition. ",
    "correct_text": "The WOTS+ signature and public key formats are defined in a syntax similar to XDR [RFC4506].",
    "notes": "The definition is not machine readable, e.g. github.com/stellar/xdrgen fails. \r\nReason:\r\n- some Identifiers contain \"/\" and \"-\", RFC4506 allows only letter, digits and underbars\r\n- some enum bodies end with  \",}\", RFC4506 requests \"}\" here\r\n- some discriminated union definitions have incomplete declarations in the case-spec, e.g. the union xmss_ots_signature refers to the wotsp-sha2_256 without giving a type. \r\n- The encoding of some unions in the reference implementation is different to the encoding specified in RFC4506. The 4-byte discriminant is missing.",
    "submit_date": "2020-12-09",
    "submitter_name": "Andreas Kretschmer",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "6821",
    "doc-id": "RFC8391",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "3.1.5",
    "orig_text": "\"Note that the checksum may reach a maximum integer value of len_1 * (w - 1) * 2^8\"",
    "correct_text": "\"Note that the checksum may reach a maximum integer value of len_1 * (w - 1)\"",
    "notes": "The \"* 2^8\" appears to be a mistake. If the checksum integers could reach those values, the checksum field would overflow, which would potentially allow an attacker to forge a message.\r\n\r\nIn reality, the correct maximum is just \"len_1 * (w - 1)\"",
    "submit_date": "2022-01-24",
    "submitter_name": "Peter Gordon",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7412",
    "doc-id": "RFC8391",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2.6 (Algorithm 1)",
    "orig_text": "bits += 8;",
    "correct_text": "bits = 8;",
    "notes": "\"bits += 8;\" is misleading and results in one useless addition. \r\n\r\nThis is true because this instruction appears after the program ensured that \"bits == 0\".\r\n\r\nTherefore, \"bits = 8;\" is the actual instruction that should be executed here.",
    "submit_date": "2023-04-02",
    "submitter_name": "Rafael Misoczki",
    "verifier_id": "163",
    "verifier_name": "Colin Perkins",
    "update_date": "2023-04-10 10:11:14"
  },
  {
    "errata_id": "7420",
    "doc-id": "RFC8391",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.2.2",
    "orig_text": "// Generate reduced XMSS private keys\r\n     ADRS = toByte(0, 32);\r\n     for ( layer = 0; layer < d; layer++ ) {\r\n        ADRS.setLayerAddress(layer);\r\n        for ( tree = 0; tree <\r\n              (1 << ((d - 1 - layer) * (h / d)));\r\n              tree++ ) {\r\n           ADRS.setTreeAddress(tree);\r\n           for ( i = 0; i < 2^(h / d); i++ ) {\r\n             wots_sk[i] = WOTS_genSK();\r\n           }\r\n           setXMSS_SK(SK_MT, wots_sk, tree, layer);\r\n        }\r\n     }",
    "correct_text": "// Generate reduced XMSS private keys\r\n     ADRS = toByte(0, 32);\r\n     for ( layer = 0; layer < d; layer++ ) {\r\n        ADRS.setLayerAddress(layer);\r\n        for ( tree = 0; tree <\r\n              (1 << ((d - 1 - layer) * (h / d)));\r\n              tree++ ) {\r\n           ADRS.setTreeAddress(tree);\r\n           for ( i = 0; i < 2^(h / d); i++ ) {\r\n             wots_sk[i] = WOTS_genSK();\r\n           }\r\n           setXMSS_SK(SK_MT, wots_sk, tree, layer, ADRS);\r\n        }\r\n     }",
    "notes": "The ADRS variable is created and configured (layer address and tree address fields set) but it is not used anywhere in the for-loop. \r\n\r\nIt would be more precise if the setXMSS_SK function receives the ADRS variable so that implementers understand that both layer address and tree address fields must be set as defined in this for-loop in order to generate the correct XMSS private key in each iteration of this loop.",
    "submit_date": "2023-04-11",
    "submitter_name": "Rafael Misoczki",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7900",
    "doc-id": "RFC8391",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "4.1.",
    "orig_text": "An XMSS private key SK contains 2^h WOTS+ private keys, the leaf\r\nindex idx of the next WOTS+ private key that has not yet been used,\r\nSK_PRF (an n-byte key to generate pseudorandom values for randomized\r\nmessage hashing), the n-byte value root (which is the root node of\r\nthe tree and SEED), and the n-byte public seed used to pseudorandomly\r\ngenerate bitmasks and hash function keys.",
    "correct_text": "An XMSS private key SK contains 2^h WOTS+ private keys, the leaf\r\nindex idx of the next WOTS+ private key that has not yet been used,\r\nSK_PRF (an n-byte key to generate pseudorandom values for randomized\r\nmessage hashing), the n-byte value root (which is the root node of\r\nthe tree), and SEED (the n-byte public seed used to pseudorandomly\r\ngenerate bitmasks and hash function keys).",
    "notes": "SEED appearing in the parenthesis explaining the root value is confusing. It has to be paired with the explanation of it that follows.\r\n\r\nErrata verified by Andreas Hülsing, 2024-04-22",
    "submit_date": "2024-04-18",
    "submitter_name": "Çağdaş Çalık",
    "verifier_id": "163",
    "verifier_name": "Colin Perkins",
    "update_date": "2024-04-22 15:01:25"
  }
]
