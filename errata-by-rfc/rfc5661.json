[
  {
    "errata_id": "2005",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "15.1.11.3",
    "orig_text": "The highest_slot argument in a Sequence operation exceeds the replier's enforced\r\nhighest_slotid.",
    "correct_text": "The highest_slot argument in a Sequence operation exceeds the replier's enforced\r\nhighest_slotid. Also, the rsa_target_highest_slotid argument in a CB_RECALL_SLOT\r\noperation exceeds maximum enforced slot ID of the session's fore channel.",
    "notes": "The NFSv4.1 specification permits the client to return NFS4ERR_BAD_HIGH_SLOT in\r\nthe event rsa_target_highest_slotid is higher the highest slot ID of the\r\nsession's fore channel. Arguably this is an unnecessary complication; the client\r\ncan return NFS4_OK to sucvh a CB_RECALL_SLOT operation, and then send a\r\nSEQUENCE operation with an sa_highest_slotid argument that is less than or\r\nequal to rsa_target_highest_slotid. NFSv4.2 should specify this simplification.",
    "submit_date": "2010-01-17",
    "submitter_name": "Michael Eisler",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2006",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "15.1.1.3",
    "orig_text": "For any of a number of reasons, the replier could not process this\r\n   operation in what was deemed a reasonable time.  The client should\r\n   wait and then try the request with a new slot and sequence value.\r\n\r\n   Some examples of scenarios that might lead to this situation:\r\n\r\n   o  A server that supports hierarchical storage receives a request to\r\n      process a file that had been migrated.\r\n\r\n   o  An operation requires a delegation recall to proceed, and waiting\r\n      for this delegation recall makes processing this request in a\r\n      timely fashion impossible.\r\n\r\n   In such cases, the error NFS4ERR_DELAY allows these preparatory\r\n   operations to proceed without holding up client resources such as a\r\n   session slot.  After delaying for period of time, the client can then\r\n   re-send the operation in question (but not with the same slot ID and\r\n   sequence ID; one or both MUST be different on the re-send).\r\n\r\n   Note that without the ability to return NFS4ERR_DELAY and the\r\n   client's willingness to re-send when receiving it, deadlock might\r\n   result.  For example, if a recall is done, and if the delegation\r\n   return or operations preparatory to delegation return are held up by\r\n   other operations that need the delegation to be returned, session\r\n   slots might not be available.  The result could be deadlock.",
    "correct_text": "For any of a number of reasons, the replier could not process this\r\n   operation in what was deemed a reasonable time.  The requester should\r\n   wait and then try the request with a new slot and sequence value.\r\n\r\n   Some examples of scenarios that might lead to this situation:\r\n\r\n   o  A server that supports hierarchical storage receives a request to\r\n      process a file that had been migrated.\r\n\r\n   o  An operation requires a delegation recall to proceed, and waiting\r\n      for this delegation recall makes processing this request in a\r\n      timely fashion impossible.\r\n\r\n   In such cases, the error NFS4ERR_DELAY allows these preparatory\r\n   operations to proceed without holding up requester resources such as a\r\n   session slot.  After delaying for period of time, the requester can then\r\n   re-send the operation in question. If the operation that returned\r\n   NFS4ERR_DELAY was not a Sequence operation, the initial, preceding \r\n   Sequence operation of the Compound request MUST NOT be re-sent with same \r\n   slot ID and sequence ID; one or both MUST be different on the re-send. If\r\n   the operation that returned NFS4ERR_DELAY was a Sequence operation, then\r\n   the Sequence MUST be re-sent with the same slot ID and sequence ID.\r\n\r\n   Note that without the ability to return NFS4ERR_DELAY and the\r\n   requester's willingness to re-send when receiving it, deadlock might\r\n   result.  For example, if a recall is done, and if the delegation\r\n   return or operations preparatory to delegation return are held up by\r\n   other operations that need the delegation to be returned, session\r\n   slots might not be available.  The result could be deadlock.",
    "notes": "This errata is correcting two problems:\r\n\r\n(1) The use of term \"requester\" instead of \"client\" since NFS4ERR_DELAY\r\n    is applicable for both the backchannel and fore channel.\r\n\r\n(2) Clarification that NFS4ERR_DELAY from a Sequence operation is handled \r\n    differently from non-Sequence operations.",
    "submit_date": "2010-01-17",
    "submitter_name": "Michael Eisler",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2062",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "2.10.6.1.3",
    "orig_text": "A reply that consists only of the Sequence operation with the error NFS4ERR_FALSE_RETRY.\r\n\r\nWhen the replier detects a false retry, it is permitted (but not always obligated) to return NFS4ERR_FALSE_RETRY...\r\n\r\nIf the replier determines the users are different between the original request and a retry, then the replier MUST return NFS4ERR_FALSE_RETRY.\r\n\r\n...current minor version (e.g., SETCLIENTID), the replier MAY return NFS4ERR_FALSE_RETRY...\r\n\r\nThe difference is due to NFS4ERR_FALSE_RETRY being a valid error for only Sequence operations...",
    "correct_text": "A reply that consists only of the Sequence operation with the error NFS4ERR_SEQ_FALSE_RETRY.\r\n\r\nWhen the replier detects a false retry, it is permitted (but not always obligated) to return NFS4ERR_SEQ_FALSE_RETRY...\r\n\r\nIf the replier determines the users are different between the original request and a retry, then the replier MUST return NFS4ERR_SEQ_FALSE_RETRY.\r\n\r\n...current minor version (e.g., SETCLIENTID), the replier MAY return NFS4ERR_SEQ_FALSE_RETRY...\r\n\r\nThe difference is due to NFS4ERR_SEQ_FALSE_RETRY being a valid error for only Sequence operations...",
    "notes": "References to NFS4ERR_FALSE_RETRY instead of NFS4ERR_SEQ_FALSE_RETRY",
    "submit_date": "2010-03-04",
    "submitter_name": "Peter Varga",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2249",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "12.5.5.2.1.5",
    "orig_text": "   Once a CB_LAYOUTRECALL of LAYOUTRECALL4_FSID is sent, the server MUST\r\n   NOT allow the client to use any layout stateid that refers to a file\r\n   with the specified fsid except for LAYOUTCOMMIT operations.  Once the\r\n   client receives a CB_LAYOUTRECALL of LAYOUTRECALL4_ALL, it MUST NOT\r\n   use any layout stateid that refers to a file with the specified fsid\r\n   except for LAYOUTCOMMIT operations.",
    "correct_text": "   Once a CB_LAYOUTRECALL of LAYOUTRECALL4_FSID is sent, the server MUST\r\n   NOT allow the client to use any layout stateid that refers to a file\r\n   with the specified fsid except for LAYOUTCOMMIT operations.  Once the\r\n   client receives a CB_LAYOUTRECALL of LAYOUTRECALL4_FSID, it MUST NOT\r\n   use any layout stateid that refers to a file with the specified fsid\r\n   except for LAYOUTCOMMIT operations.",
    "notes": "Copy/paste error from the previous paragraph. s/_ALL/_FSID/ in the second sentence of the corrected paragraph.",
    "submit_date": "2010-05-10",
    "submitter_name": "Michael Eisler",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2280",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "10.4",
    "orig_text": "   OPEN_DELEGATE_READ delegations may be outstanding simultaneously and\r\n   do not conflict.  An OPEN_DELEGATE_WRITE delegation allows the client\r\n   to handle, on its own, all opens.  Only OPEN_DELEGATE_WRITE\r\n   delegation may exist for a given file at a given time, and it is\r\n   inconsistent with any OPEN_DELEGATE_READ delegations.",
    "correct_text": "   OPEN_DELEGATE_READ delegations may be outstanding simultaneously and\r\n   do not conflict.  An OPEN_DELEGATE_WRITE delegation allows the client\r\n   to handle, on its own, all opens.  Only one OPEN_DELEGATE_WRITE\r\n   delegation may exist for a given file at a given time, and it is\r\n   inconsistent with any OPEN_DELEGATE_READ delegations.",
    "notes": null,
    "submit_date": "2010-05-20",
    "submitter_name": "Paul J Gilliam",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2291",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "18.36.3.",
    "orig_text": "      The server\r\n      MUST specify an ONC RPC program number equal to csa_cb_program and\r\n      an ONC RPC version number equal to 4 in callbacks sent to the\r\n      client.",
    "correct_text": "      The server\r\n      MUST specify an ONC RPC program number equal to csa_cb_program and\r\n      an ONC RPC version number equal to 1 in callbacks sent to the\r\n      client.",
    "notes": "RFC5661 disagrees with RFC5662. The latter specifies a version number of 1.",
    "submit_date": "2010-05-27",
    "submitter_name": "Michael Eisler",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2299",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "18.45.3.",
    "orig_text": "If SECINFO_STYLE4_PARENT is passed, then\r\n   SECINFO_NO_NAME is querying for the required security of the current\r\n   filehandle's parent",
    "correct_text": "If SECINFO_STYLE4_PARENT is passed, then\r\n   SECINFO_NO_NAME is querying for the required security of the current\r\n   filehandle's parent, where the current filehandle MUST be that of directory (an object of type NF4DIR).",
    "notes": null,
    "submit_date": "2010-06-03",
    "submitter_name": "Michael Eisler",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2324",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "2.10.6.2",
    "orig_text": "A retry might be sent while the original request is still in progress\r\non the replier.  The replier SHOULD deal with the issue by returning\r\nNFS4ERR_DELAY as the reply to SEQUENCE or CB_SEQUENCE operation, but\r\nimplementations MAY return NFS4ERR_MISORDERED.",
    "correct_text": "A retry might be sent while the original request is still in progress\r\non the replier.  The replier SHOULD deal with the issue by returning\r\nNFS4ERR_DELAY as the reply to SEQUENCE or CB_SEQUENCE operation, but\r\nimplementations MAY return NFS4ERR_SEQ_MISORDERED.",
    "notes": null,
    "submit_date": "2010-07-12",
    "submitter_name": "Trond Myklebust",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2326",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "15.1.16.3",
    "orig_text": "NFS4ERR_NXIO (Error Code 5) ",
    "correct_text": "NFS4ERR_NXIO (Error Code 6) ",
    "notes": null,
    "submit_date": "2010-07-13",
    "submitter_name": "Tom Haynes",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2327",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "6.4.3.1",
    "orig_text": "   If the object being created is not a directory, the inherited ACL\r\n   SHOULD NOT inherit ACEs from the parent directory ACL unless the\r\n   ACE4_FILE_INHERIT_FLAG is set.",
    "correct_text": "   If the object being created is not a directory, the inherited ACL\r\n   SHOULD NOT inherit ACEs from the parent directory ACL unless the\r\n   ACE4_FILE_INHERIT_ACE is set.",
    "notes": null,
    "submit_date": "2010-07-13",
    "submitter_name": "Tom Haynes",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2328",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "15.1.16",
    "orig_text": null,
    "correct_text": null,
    "notes": "From 3530:\r\n\r\n  NFS4ERR_RESOURCE  For the processing of the COMPOUND procedure, the server may exhaust available resources and can not continue processing operations within the COMPOUND procedure.  This error will be returned from the server in those instances of resource exhaustion related to the processing of the COMPOUND procedure.\r\n\r\nSince it is not used by 5661, shouldn't it appear in Section 15.1.16 Obsoleted Errors?",
    "submit_date": "2010-07-13",
    "submitter_name": "Tom Haynes",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2330",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "3.3.7",
    "orig_text": "   0            1\r\n   +-----------+-----------+-----------+--\r\n   |  count    | 31  ..  0 | 63  .. 32 |\r\n   +-----------+-----------+-----------+--",
    "correct_text": "                     0            1\r\n   +-----------+-----------+-----------+--\r\n   |  count    | 31  ..  0 | 63  .. 32 |\r\n   +-----------+-----------+-----------+--",
    "notes": null,
    "submit_date": "2010-07-14",
    "submitter_name": "Tom Haynes",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2505",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "12.5.4.",
    "orig_text": "   Because of this inconsistency, it is necessary to resynchronize the\r\n   client with the metadata server and its storage devices and make any\r\n   potential changes available to other clients. \r\n\r\nAND\r\n\r\n   For file-based layouts, synchronization of\r\n   attributes between the metadata and storage devices, primarily the\r\n   size attribute, is required.\r\n",
    "correct_text": "   Because of this inconsistency, in general, it is necessary to resynchronize the\r\n   client with the metadata server and its storage devices and make any\r\n   potential changes available to other clients. \r\n\r\nAND\r\n\r\n   For file-based layouts, synchronization of\r\n   attributes between the metadata and storage devices, primarily the\r\n   size attribute, is not required, but the use of LAYOUTCOMMIT provides \r\n   a way to optimize the synchronization. Indeed, if a LAYOUT4_NFSV4_1_FILES\r\n   layout is ever revoked, the metadata server MUST direct all data servers to\r\n   commit any modified data of the file to stable storage, and synchronize \r\n   the file's size and time_modify attributes on the metadata server\r\n   with the those on the data server.\r\n",
    "notes": "Without this correction, the implication is that a file could be truncated if a  LAYOUT4_NFSV4_1_FILES layout was revoked before LAYOUTCOMMIT, which would then mean that every append operation to a data server would require a LAYOUTCOMMIT, which is an absurd consequence.",
    "submit_date": "2010-08-31",
    "submitter_name": "Michael Eisler",
    "verifier_id": "114",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2019-10-25 01:27:28"
  },
  {
    "errata_id": "2548",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "18.36.3",
    "orig_text": "csa_fore_chan_attrs, csa_fore_chan_attrs:",
    "correct_text": "csa_fore_chan_attrs, csa_back_chan_attrs:",
    "notes": null,
    "submit_date": "2010-10-11",
    "submitter_name": "J. Bruce Fields",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2722",
    "doc-id": "RFC5661",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "15.2",
    "orig_text": "   | ILLEGAL              | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL         |\r\n   | LAYOUTCOMMIT         | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,     |",
    "correct_text": "   |                      | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL         |\r\n   | LAYOUTCOMMIT         | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,     |",
    "notes": "ILLEGAL is not an operation.  The errors belong to GETFH, the previous operation listed.\n --VERIFIER NOTES-- \nSubmitter wishes to retract the errata.   ",
    "submit_date": "2011-02-15",
    "submitter_name": "Ricardo Labiaga",
    "verifier_id": "113",
    "verifier_name": "Lars Eggert",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2751",
    "doc-id": "RFC5661",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "GLOBAL",
    "orig_text": null,
    "correct_text": "12.5.4.1.  LAYOUTCOMMIT and change/time_modify\r\nbecomes\r\n12.5.4.2.  LAYOUTCOMMIT and change/time_modify\r\n\r\n\r\n12.5.4.2.  LAYOUTCOMMIT and size\r\nbecomes\r\n12.5.4.3.  LAYOUTCOMMIT and size\r\n\r\n\r\n12.5.4.3.  LAYOUTCOMMIT and layoutupdate\r\nbecomes\r\n12.5.4.4.  LAYOUTCOMMIT and layoutupdate\r\n\r\n\r\nAdd new Section \r\n12.5.4.1 Implications of LAYOUTCOMMIT on file layouts\r\nFor file layouts, WRITEs to a Data Server that return a stable_how4 value of \r\nFILE_SYNC4 guarantee that data and file system metadata are on stable \r\nstorage.  This means that a LAYOUTCOMMIT is not needed in order to make the \r\ndata and metadata visible to the metadata server and other clients.\r\n\r\nFor file layouts, when WRITE to the data server returns UNSTABLE4 or \r\nDATA_SYNC4  and the NFL4_UFLG_COMMIT_THRU_MDS flag is set, the client MUST \r\nsend the COMMIT to the metadata server.  A successful COMMIT to the metadata \r\nserver guarantees that data and file system metadata are on stable storage.  \r\nTherefore, any time that NFS4_UFLG_COMMIT_THRU_MDS is set, a LAYOUTCOMMIT (of \r\nthe byte range specified by the layout) is not needed.\r\n\r\nFor file layouts, when NFL4_UFLG_COMMIT_THRU_MDS flag is not set, and WRITE or \r\nCOMMIT to the data server return DATA_SYNC4, the client MUST send the \r\nLAYOUTCOMMIT to the metadata server in order to synchronize file metadata.  \r\n\r\nThe following table summarizes the rules when a LAYOUTCOMMIT is needed, and \r\nthe effects of a COMMIT to a data server and metadata server.  \r\n\r\n+------------+------------+------------+------------+----------+\r\n| NFL4_UFLG_ | WRITE to   | Meaning of | Meaning    | LAYOUT   |\r\n| COMMIT_    | DS returns | COMMIT to  | of COMMIT  | COMMIT   | \r\n| THRU_MDS   |            | DS         | to MDS     | required |            \r\n+------------+------------+------------+------------+----------+\r\n| Not Set    | UNSTABLE4  | DATA_SYNC4 | Nothing    | Yes      |\r\n| Not Set    | DATA_SYNC4 | Nothing    | Nothing    | Yes      |\r\n| Not Set    | FILE_SYNC4 | Nothing    | Nothing    | NO       |\r\n| Set        | UNSTABLE4  | Nothing    | FILE_SYNC4 | NO       |\r\n| Set        | DATA_SYNC4 | Nothing    | FILE_SYNC4 | NO       |\r\n| Set        | FILE_SYNC4 | Nothing    | Nothing    | NO       |\r\n+------------+------------+------------+------------+----------+\r\n\r\nNote that a client can always demand FILE_SYNC4 or DATA_SYNC4 in WRITE's \r\narguments.  Also note that specifying these stability levels may adversely \r\nimpact performance.\r\n\r\nIf a LAYOUTCOMMIT is required, it should be sent before CLOSE to maintain \r\nclose-to-open semantics.  If required, it should be sent before LOCKU, \r\nOPEN_DOWNGRADE, LAYOUTRETURN, and when the application issues fsync() [25].  \r\nAgain, if LAYOUTCOMMIT is required, it should be sent periodically to keep the \r\nfile size and modification time synchronized.  This allows use cases like \r\ntail -f [56] which copies its input file to the standard output and updates \r\nthe output as new lines become available in the input file.  It is up to the \r\nclient implementation to determine how frequently LAYOUTCOMMIT is issued.  \r\nPossible policies include every N'th COMMIT to a data server, every N'th unit \r\nof time, or after writing a stripe to a set of data servers.\r\n\r\nEven if a required LAYOUTCOMMIT is not issued by the client, the data server \r\nand metadata servers have a set of responsibilities to fulfill in order to \r\nguarantee data consistency:\r\n1) Data servers MUST commit data and synchronize modification and size \r\nattributes with the metadata server before a layout is revoked as described in \r\nsection 12.5.4.\r\n2) Data servers SHOULD commit data and synchronize modification and size \r\nattributes with the metadata server after the metadata server reboots.  In \r\ntheory the client should commit the data, but this avoids the problem where \r\nboth the client and metadata server crash at the same time.\r\n3) The metadata server MAY periodically poll data servers to synchronize \r\nmodification and size attributes.\r\n\r\n\r\nSection 13.9.2.3 says:\r\n   For the NFSv4.1-based data storage protocol, it is  necessary to re-\r\nsynchronize state such as the size attribute, and  the setting of \r\nmtime/change/atime.\r\n\r\nShould say:\r\n   For the NFSv4.1-based data storage protocol, it may be necessary to re-\r\nsynchronize state such as the size attribute, and the setting of \r\nmtime/change/atime.\r\n\r\n\r\nSection 13.10 says:\r\n   For the case above, this means that a LAYOUTCOMMIT will be done at close \r\n(along with the data WRITEs) and will update the file's size and change \r\nattribute.\r\n\r\nShould say:\r\n   For the case above, this means that, if necessary, a LAYOUTCOMMIT will be \r\ndone at close (along with the data WRITEs) and will update the file's size and \r\nchange attribute.\r\n\r\n\r\nSection 18.3.4 says:\r\n   The COMMIT operation is similar in operation and semantics to the POSIX \r\nfsync() [25] system interface that synchronizes a file's state with the disk \r\n(file data and metadata is flushed to disk or stable storage).  COMMIT \r\nperforms the same operation for a client, flushing any unsynchronized data and \r\nmetadata on the server to the server's disk or stable storage for the \r\nspecified file.\r\n\r\nShould say:\r\n   The COMMIT operation is similar in operation and semantics to the POSIX \r\nfsync() [25] system interface that synchronizes a file's state with the disk \r\n(file data and metadata is flushed to disk or stable storage).  COMMIT \r\nperforms the same operation for a client, flushing any unsynchronized data and \r\nmetadata on the server to the server's disk or stable storage for the \r\nspecified file.  When using pNFS, if a WRITE returned UNSTABLE4 and \r\nNFL4_UFLG_COMMIT_THRU_MDS is not set, then the client MUST COMMIT to the data \r\nserver.  The COMMIT may result in flushing the data but not the metadata.  In \r\nthis case, the metadata MUST be flushed with a subsequent LAYOUTCOMMIT to the \r\nmetadata server.  A complete set of pNFS rules for flushing data and metadata \r\nis described in section 12.5.4.1.\r\n\r\n\r\nSection 18.3.4 says:\r\n   The above description applies to page-cache-based systems as well as buffer-\r\ncache-based systems.  In the former systems, the virtual memory system will \r\nneed to be modified instead of the buffer cache.\r\n\r\nShould say:\r\n   The above description applies to page-cache-based systems as well as buffer-\r\ncache-based systems.  In the former systems, the virtual memory system will \r\nneed to be modified instead of the buffer cache.\r\n\r\n   Refer to Section 12.5.4.1 for a discussion of the effects of data stability \r\nlevels on data servers or metadata servers.\r\n\r\n\r\nSection 18.32.4 says:\r\n   However, since it is possible for a WRITE to be done with a special \r\nstateid, the server needs to check for this case even though the client should \r\nhave done an OPEN previously.\r\n\r\nShould say:\r\n   However, since it is possible for a WRITE to be done with a special \r\nstateid, the server needs to check for this case even though the client should \r\nhave done an OPEN previously.\r\n\r\n   Refer to Section 12.5.4.1 for a discussion of the effects of data stability \r\nlevels on data servers or metadata servers.\r\n\r\n\r\nSection 20.3.4 says:\r\n   In the case of modified data being written while the layout is held, the \r\nclient must use LAYOUTCOMMIT operations at the appropriate time; as required \r\nLAYOUTCOMMIT must be done before the LAYOUTRETURN.\r\n\r\nShould say:\r\n   In the case of modified data being written while the layout is held, the \r\nclient may be required to use LAYOUTCOMMIT operations at the appropriate time; \r\nif LAYOUTCOMMIT is required, it must be done before the LAYOUTRETURN.\r\n\r\n\r\nAdd new informative reference to Section 23.2\r\n[56] The Open Group, \"section 'tail' of The Open Group Base Specifications \r\nIssue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), \r\nISBN 1931624453, 2004.\r\n\r\n",
    "notes": "A new section describing the implications of LAYOUTCOMMIT on file layouts is \r\ndefined in this errata, along with updates to existing sections of the spec.  \r\nThe technical details in this errata were agreed upon at the IETF Interim \r\nMeeting in Sunnyvale, CA on Feb 18-19, 2011.\n --VERIFIER NOTES-- \n This errata was rejected based on formal process grounds that Errata is not allowed to change the WG consensus at the time of publication, and also is very extensive. This issue do need to be addressed in an update to the RFC. ",
    "submit_date": "2011-03-21",
    "submitter_name": "Ricardo Labiaga",
    "verifier_id": "114",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2019-10-25 01:26:44"
  },
  {
    "errata_id": "3064",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "12.5.4",
    "orig_text": "   The LAYOUTCOMMIT operation is responsible for committing a modified\r\n   layout to the metadata server.  The data should be written and\r\n   committed to the appropriate storage devices before the LAYOUTCOMMIT\r\n   occurs.  The scope of the LAYOUTCOMMIT operation depends on the\r\n   storage protocol in use.",
    "correct_text": "   The LAYOUTCOMMIT operation is responsible for committing a modified\r\n   layout to the metadata server.  The data should be written and\r\n   committed to the appropriate storage devices before the LAYOUTCOMMIT\r\n   occurs.  The scope of data committed by a LAYOUTCOMMIT operation is\r\n   specific to the type of layout because that scope depends on the\r\n   storage protocol in use.",
    "notes": "Errata 1 of 5 to deprecate loca_offset and loca_length arguments to LAYOUTCOMMIT.",
    "submit_date": "2011-12-27",
    "submitter_name": "David Black",
    "verifier_id": "133",
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3065",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "12.7.4",
    "orig_text": "      If the metadata server's\r\n      consistency checks on loca_layoutupdate succeed, then the metadata\r\n      server MUST commit the data (as described by the loca_offset,\r\n      loca_length, and loca_layoutupdate fields of the arguments) that\r\n      was written to the storage device. If the metadata server's\r\n      consistency checks on loca_layoutupdate fail, the metadata server\r\n      rejects the LAYOUTCOMMIT operation and makes no changes to the\r\n      file system.  However, any time LAYOUTCOMMIT with loca_reclaim\r\n      TRUE fails, the pNFS client has lost all the data in the range\r\n      defined by <loca_offset, loca_length>.  ",
    "correct_text": "      If the metadata server's\r\n      consistency checks on loca_layoutupdate succeed, then the metadata\r\n      server MUST commit the changed data that was written to the storage\r\n      device within the scope of the LAYOUTCOMMIT operation.\r\n      If the metadata server's\r\n      consistency checks on loca_layoutupdate fail, the metadata server\r\n      rejects the LAYOUTCOMMIT operation and makes no changes to the\r\n      file system.  However, any time LAYOUTCOMMIT with loca_reclaim\r\n      TRUE fails, the pNFS client may have lost all uncommitted\r\n\tdata within the scope of the failed LAYOUTCOMMIT operation.  ",
    "notes": "Errata 2 of 5 to deprecate loca_offset and loca_length arguments to LAYOUTCOMMIT.",
    "submit_date": "2011-12-27",
    "submitter_name": "David Black",
    "verifier_id": "133",
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3066",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "12.7.4",
    "orig_text": "   o  The client does not have a copy of the data in its memory and the\r\n      metadata server is no longer in its grace period; i.e., the\r\n      metadata server returns NFS4ERR_NO_GRACE.  As with the scenario in\r\n      the above bullet point, the failure of LAYOUTCOMMIT means the data\r\n      in the range <loca_offset, loca_length> lost.  The defense against\r\n      the risk is the same -- cache all written data on the client until\r\n      a successful LAYOUTCOMMIT.",
    "correct_text": "   o  The client does not have a copy of the data in its memory and the\r\n      metadata server is no longer in its grace period; i.e., the\r\n      metadata server returns NFS4ERR_NO_GRACE.  As with the scenario in\r\n      the above bullet point, the failure of LAYOUTCOMMIT means the data\r\n      in the scope of that LAYOUTCOMMIT may have been lost.  The defense\r\n      against the risk is the same -- cache all written data on the client\r\n      until a successful LAYOUTCOMMIT.",
    "notes": "Errata 3 of 5 to deprecate loca_offset and loca_length arguments to LAYOUTCOMMIT.",
    "submit_date": "2011-12-27",
    "submitter_name": "David Black",
    "verifier_id": "133",
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3067",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "18.42.3",
    "orig_text": "   The LAYOUTCOMMIT operation commits changes in the layout represented\r\n   by the current filehandle, client ID (derived from the session ID in\r\n   the preceding SEQUENCE operation), byte-range, and stateid.  Since\r\n   layouts are sub-dividable, a smaller portion of a layout, retrieved\r\n   via LAYOUTGET, can be committed.  The byte-range being committed is\r\n   specified through the byte-range (loca_offset and loca_length).  This\r\n   byte-range MUST overlap with one or more existing layouts previously\r\n   granted via LAYOUTGET (Section 18.43), each with an iomode of\r\n   LAYOUTIOMODE4_RW.  In the case where the iomode of any held layout\r\n   segment is not LAYOUTIOMODE4_RW, the server should return the error\r\n   NFS4ERR_BAD_IOMODE.  For the case where the client does not hold\r\n   matching layout segment(s) for the defined byte-range, the server\r\n   should return the error NFS4ERR_BAD_LAYOUT.",
    "correct_text": "   The LAYOUTCOMMIT operation commits changes in the layout represented\r\n   by the current filehandle, client ID (derived from the session ID in\r\n   the preceding SEQUENCE operation), and stateid.  As a layout-independent\r\n   operation, LAYOUTCOMMIT commits the entire layout; layout type-specific\r\n   data (loca_layoutupdate) may specify a smaller scope of data that is to\r\n   be committed (e.g., for the block layout, see RFC 5663 [41]).\r\n\r\n   The loca_offset and loca_length arguments have been deprecated.  The\r\n   client SHOULD set both loca_offset and loca_length to 0.\r\n   The server MUST ignore the loca_offset and loca_length arguments.\r\n   The client MUST hold one or more existing layouts\r\n   previously granted via LAYOUTGET (Section 18.43), with an iomode of\r\n   LAYOUTIOMODE4_RW.  If layout type-specific data (loca_layoutupdate)\r\n   restricts the scope of the LAYOUTCOMMIT to less than the entire layout,\r\n   the client MUST hold one or more existing layouts with an iomode\r\n   of LAYOUTIOMODE4_RW fully covering the committed byte ranges.\r\n   In the case where no previously granted layout\r\n   has an iomode of LAYOUTIOMODE4_RW, the server should return the error\r\n   NFS4ERR_BAD_IOMODE.  For the case where the client does not hold\r\n   any previously granted layout, the server should return the error\r\n   NFS4ERR_BAD_LAYOUT.",
    "notes": "Errata 4 of 5 to deprecate loca_offset and loca_length arguments to LAYOUTCOMMIT.",
    "submit_date": "2011-12-27",
    "submitter_name": "David Black",
    "verifier_id": "133",
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3068",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "18.42.3",
    "orig_text": "   The loca_last_write_offset field specifies the offset of the last\r\n   byte written by the client previous to the LAYOUTCOMMIT.  Note that\r\n   this value is never equal to the file's size (at most it is one byte\r\n   less than the file's size) and MUST be less than or equal to\r\n   NFS4_MAXFILEOFF.  Also, loca_last_write_offset MUST overlap the range\r\n   described by loca_offset and loca_length. ",
    "correct_text": "   The loca_last_write_offset field specifies the offset of the last\r\n   byte written by the client previous to the LAYOUTCOMMIT.  Note that\r\n   this value is never equal to the file's size (at most it is one byte\r\n   less than the file's size) and MUST be less than or equal to\r\n   NFS4_MAXFILEOFF.",
    "notes": "Errata 5 of 5 to deprecate loca_offset and loca_length arguments to LAYOUTCOMMIT.",
    "submit_date": "2011-12-27",
    "submitter_name": "David Black",
    "verifier_id": "133",
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3208",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "GLOBAL",
    "orig_text": null,
    "correct_text": null,
    "notes": "Section 12.5.2. says:\r\n   The first successful LAYOUTGET\r\n   processed by the server using a non-layout stateid as an argument\r\n   MUST have the \"seqid\" field of the layout stateid in the response set\r\n   to one.  Thereafter, the client MUST use a layout stateid (see\r\n   Section 12.5.3) on future invocations of LAYOUTGET on the file, and\r\n   the \"seqid\" MUST NOT be set to zero.\r\n\r\nIt should say:\r\n   The first successful LAYOUTGET\r\n   processed by the server using a non-layout stateid as an argument\r\n   MUST have the \"seqid\" field of the layout stateid in the response set\r\n   to one.  Thereafter, the client MUST use a layout stateid (see\r\n   Section 12.5.3) on future invocations of LAYOUTGET on the file, and\r\n   the \"seqid\" MUST NOT be set to zero.\r\n|  The client MUST serialize LAYOUTGET operations using a non-layout\r\n|  stateid with any other operation affecting the layout state on the file,\r\n|  including CB_LAYOUTRECALL, to allow consistent initialization of the\r\n|  layout state.\r\n\r\nAdd the following paragraph to section 12.5.3.:\r\n|  A client MAY always forget its layout state and associated\r\n|  layout stateid at any time (See also section 12.5.5.1).\r\n|  In such case, the client MUST use a non-layout stateid for the next\r\n|  LAYOUTGET operation.  This will signal the server that the client has\r\n|  no more layouts on the file and its respective layout state can be\r\n|  released before issuing a new layout in response to LAYOUTGET.\r\n\r\nSection 12.5.5.2.1. says:\r\n   One critical issue with regard to layout operations sequencing\r\n   concerns callbacks.  The protocol must defend against races between\r\n   the reply to a LAYOUTGET or LAYOUTRETURN operation and a subsequent\r\n   CB_LAYOUTRECALL.  A client MUST NOT process a CB_LAYOUTRECALL that\r\n   implies one or more outstanding LAYOUTGET or LAYOUTRETURN operations\r\n   to which the client has not yet received a reply.  The client detects\r\n   such a CB_LAYOUTRECALL by examining the \"seqid\" field of the recall's\r\n   layout stateid.  If the \"seqid\" is not exactly one higher than what\r\n   the client currently has recorded, and the client has at least one\r\n   LAYOUTGET and/or LAYOUTRETURN operation outstanding, the client knows\r\n   the server sent the CB_LAYOUTRECALL after sending a response to an\r\n   outstanding LAYOUTGET or LAYOUTRETURN.\r\n\r\nIt should say:\r\n   One critical issue with regard to layout operations sequencing\r\n   concerns callbacks.  The protocol must defend against races between\r\n   the reply to a LAYOUTGET or LAYOUTRETURN operation and a subsequent\r\n   CB_LAYOUTRECALL.  A client MUST NOT process a CB_LAYOUTRECALL that\r\n   implies one or more outstanding LAYOUTGET or LAYOUTRETURN operations\r\n   to which the client has not yet received a reply.  The client detects\r\n   such a CB_LAYOUTRECALL by examining the \"seqid\" field of the recall's\r\n   layout stateid.  If the \"seqid\" is not exactly one higher than what\r\n   the client currently has recorded, and the client has at least one\r\n   LAYOUTGET and/or LAYOUTRETURN operation outstanding,\r\n|  or if the client has a outstanding LAYOUTGET with a non-layout stateid,\r\n   the client knows\r\n   the server sent the CB_LAYOUTRECALL after sending a response to an\r\n   outstanding LAYOUTGET or LAYOUTRETURN.\r\n\r\nSection 12.5.5.2.1.1. says:\r\n   It is permissible for the client to send multiple parallel LAYOUTGET\r\n   operations for the same file or multiple parallel LAYOUTRETURN\r\n   operations for the same file or a mix of both.\r\n\r\nIt should say:\r\n    It is permissible for the client to send multiple parallel LAYOUTGET\r\n    operations for the same file\r\n|   using the layout stateid\r\n    or multiple parallel LAYOUTRETURN\r\n    operations for the same file or a mix of both.\r\n\r\nSection 12.5.5.2.1.2. says:\r\n   Note\r\n   that in the first case, the \"seqid\" in the layout stateid of the\r\n   recall is two greater than what the client has recorded;\r\n\r\nIt should say:\r\n   Note\r\n   that in the first case, the \"seqid\" in the layout stateid of the\r\n   recall is two greater than what the client has recorded,\r\n|  or the client has an outstanding LAYOUTGET using a non-layout stateid;\r\n\r\n",
    "submit_date": "2012-05-02",
    "submitter_name": "Benny Halevy",
    "verifier_id": "133",
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3379",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "18.50.3",
    "orig_text": "If there are\r\nsessions (both idle and non-idle), opens, locks, delegations, \r\nlayouts, and/or wants (Section 18.49) associated with the unexpired \r\nlease of the client ID, the server MUST return NFS4ERR_CLIENTID_BUSY.",
    "correct_text": "If there are \r\nsessions (both idle and non-idle), opens, locks, delegations, \r\nand/or wants (Section 18.49) associated with the unexpired \r\nlease of the client ID, the server MUST return NFS4ERR_CLIENTID_BUSY.",
    "notes": "Should not include layouts.\r\nA forgetful client may not return LAYOUTS. In this case, a server will always return NFS4ERR_CLIENTID_BUSY on DESTROY_CLIENTID and end up persisting the clientâ€™s lease until it expires although the client is explicitly asking us not to.",
    "submit_date": "2012-10-15",
    "submitter_name": "Asmita Karandikar",
    "verifier_id": "114",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2019-10-25 01:29:23"
  },
  {
    "errata_id": "3558",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "15.1.4.2",
    "orig_text": "In Table 5 Section 5.1 Page 342, NFS4ERR_DQUOT is defined as error number 69:\r\n\r\n    \"| NFS4ERR_DQUOT | 69 | Section 15.1.4.2 |\"\r\n\r\nHowever, in Section 15.1.4.2 Page 349 it is identified as error code 19:\r\n\r\n    \"15.1.4.2. NFS4ERR_DQUOT (Error Code 19)\"",
    "correct_text": "    \"15.1.4.2. NFS4ERR_DQUOT (Error Code 69)\"\r\n\r\n",
    "notes": "I believe NFS4ERR_DQUOT is in fact 69 and the reference to error code 19 in Section 15.1.4.2 is a typo.\r\n\r\nIn RFC 3010, Error Code 19 was assigned to \"NFS4ERR_NODEV\" but that association appears to have suffered the same fate as RFC 3010 itself and there is no mention of NFS4ERR_NODEV in RFC 3530 which rendered that RFC obsolete.",
    "submit_date": "2013-03-19",
    "submitter_name": "Cal Turney",
    "verifier_id": "133",
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3653",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "13.4.2",
    "orig_text": "The destinations of the first 13 storage units are:",
    "correct_text": "The destinations of the first 13 stripe units are:",
    "notes": "Same errata on Section 13.4.3",
    "submit_date": "2013-06-15",
    "submitter_name": "Kanda Motohiro",
    "verifier_id": "133",
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3714",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "13.4.4.",
    "orig_text": "The flag NFL4_UFLG_DENSE of the nfl_util4 data type (field nflh_util\r\nof the data type nfsv4_1_file_layouthint4 and field nfl_util of data\r\ntype nfsv4_1_file_layout_ds_addr4)",
    "correct_text": "The flag NFL4_UFLG_DENSE of the nfl_util4 data type (field nflh_util\r\nof the data type nfsv4_1_file_layouthint4 and field nfl_util of data\r\ntype  nfsv4_1_file_layout4)",
    "notes": "nfsv4_1_file_layout_ds_addr4 data type does not have field nflh_util",
    "submit_date": "2013-08-31",
    "submitter_name": "Yuri Radchenko",
    "verifier_id": "114",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2019-10-25 01:30:08"
  },
  {
    "errata_id": "3901",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "18.43.3",
    "orig_text": "The logr_return_on_close result field is a directive to return the\r\nlayout before closing the file.  When the metadata server sets this\r\nreturn value to TRUE, it MUST be prepared to recall the layout in the\r\ncase in which the client fails to return the layout before close.\r\nFor the metadata server that knows a layout must be returned before a\r\nclose of the file, this return value can be used to communicate the\r\ndesired behavior to the client and thus remove one extra step from\r\nthe client's and metadata server's interaction.",
    "correct_text": "The logr_return_on_close result field is a directive to return\r\nor forget the layout when the client returns all open/delegation\r\nstate for that file.\r\n\r\nOnce a LAYOUTGET operation returns with logr_return_on_close\r\nset to TRUE for a given file, then all subsequent LAYOUTGET\r\nrequests by that client for the same file and layout type, MUST\r\nreply with logr_return_on_close set to TRUE until the client returns\r\nall its open state for that file using CLOSE and DELEGRETURN.\r\nNote that return_on_close also applies retroactively to all layout\r\nsegments retrieved by the client for that file and layout type.\r\n\r\nAfter the client has closed all open stateids and returned the\r\ndelegation stateids for a file for which logr_return_on_close\r\nwas set to TRUE, the server MUST  invalidate all layout segments\r\nthat were  issued to the client for that file. The client MUST NOT\r\nattempt to use that layout or the layout stateid.\r\n\r\nIf the server needs to revoke all open stateids and delegation\r\nstateids owned by the client for a file for which logr_return_on_close\r\nwas set to TRUE, then it MUST also revoke all layout segments of \r\ntype loga_layout_type that were issued for that file to that client, \r\nand take action to fence the access to the DSes.",
    "notes": "This is intended as a replacement for the errata with id 3226, which is incomplete in that it does not discuss how return-on-close is supposed to work with delegations or with layout revoking.\r\n --VERIFIER NOTES-- \r\n Please get an agreement in the WG and submit an up to date errata, as this text part seems to be under discussion.\r\n\r\n2016-06-17: RFC Editor moved from Rejected to Reported per request from AD (Spencer Dawkins).\r\n\r\n2019-10-25: TSV AD Magnus Westerlund put this into the Held for document update so that the WG can deal with the consensus deision issues related to this clarification when updating the document. ",
    "submit_date": "2014-02-25",
    "submitter_name": "Trond Myklebust",
    "verifier_id": "114",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2019-10-25 01:33:10"
  },
  {
    "errata_id": "4118",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "20.12.3",
    "orig_text": "NOTIFY_DEVICEID4_CHANGE\r\n  A previously provided device-ID-to-device-address mapping has\r\n  changed and the client uses GETDEVICEINFO to obtain the updated\r\n  mapping.  The notification is encoded in a value of data type\r\n  notify_deviceid_change4.  This data type also contains a boolean\r\n  field, ndc_immediate, which if TRUE indicates that the change will\r\n  be enforced immediately, and so the client might not be able to\r\n  complete any pending I/O to the device ID.  If ndc_immediate is\r\n  FALSE, then for an indefinite time, the client can complete\r\n  pending I/O.  After pending I/O is complete, the client SHOULD get\r\n  the new device-ID-to-device-address mappings before sending new\r\n  I/O requests to the storage devices addressed by the device ID.",
    "correct_text": "NOTIFY_DEVICEID4_CHANGE\r\n  A previously provided device-ID-to-device-address mapping has\r\n  changed and the client uses GETDEVICEINFO to obtain the updated\r\n  mapping.  The notification is encoded in a value of data type\r\n  notify_deviceid_change4.  This data type also contains a boolean\r\n  field, ndc_immediate, which SHOULD be ignored by the client.\r\n  The client may finish any outstanding I/Os that reference the\r\n  previously provided device-ID-to-device-address mapping and SHOULD\r\n  use GETDEVICEINFO to obtain the updated mapping for the previously\r\n  provided device-ID-to-device-address mapping before requesting new\r\n  layouts.  All outstanding layouts remain valid after a notification\r\n  of type NOTIFY_DEVICEID4_CHANGE.  If the device-ID-to-device-address\r\n  mapping changed in an incompatible way that would invalidate\r\n  outstanding layouts, the server MUST recall all outstanding layouts\r\n  and send a NOTIFY_DEVICEID4_DELETE notification instead.",
    "notes": "Clarify what DEVICEID4_CHANGE means vs layouts instead of I/Os. Drop the under specified ndc_immediate flag, which can't be enforced.",
    "submit_date": "2014-09-17",
    "submitter_name": "Christoph Hellwig",
    "verifier_id": "133",
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4119",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "12.2.10",
    "orig_text": "A device ID lives as long as there is a layout referring to the\r\ndevice ID.  If there are no layouts referring to the device ID, the\r\nserver is free to delete the device ID any time.",
    "correct_text": "A device ID is established by referencing it in the result of a\r\nGETDEVICELIST or LAYOUTGET operation and can be deleted by the server\r\nas soon as there are no layouts referring to the device ID.\r\n\r\nIf the client requested notifications for device ID mappings, the\r\nserver SHOULD send CB_NOTIFY_DEVICEID notifications for device ID\r\ndeletions or changes to the device-ID-to-device-address mappings to any\r\nclient which has used the device-ID in question at least once,\r\nirrespective of whether the client has any layouts currently referring\r\nto it. If the server does not support or the client does not request\r\nnotifications for device ID mappings, the client SHOULD periodically\r\nretired unused device IDs.\r\n\r\n\r\nGiven that GETDEVICELIST does not support requesting notifications a\r\nserver that implements GETDEVICELIST MUST not not advertise support\r\nfor NOTIFY_DEVICEID4_CHANGE notification in GETDEVICEINFO, and client\r\nusing GETDEVICELIST must not rely on NOTIFY_DEVICEID4_CHANGE or\r\nNOTIFY_DEVICEID4_DELETE notifications to work reliably.",
    "notes": "The lifetime rules in RFC5661 are contradictory - both GETDEVICELIST and CB_NOTIFY_DEVICEID (NOTIFY4_DEVICEID_DELETE) operations imply that device IDs are valid even without layouts referring to them. Implementations rely on this fact by caching not referenced device IDs to avoid the huge setup costs, and thus require notifications to be sent for that case.",
    "submit_date": "2014-09-17",
    "submitter_name": "Christoph Hellwig",
    "verifier_id": "114",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2019-10-25 01:34:40"
  },
  {
    "errata_id": "4215",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "22.1",
    "orig_text": "   All assignments to the registry are made on a First Come First Served\r\n   basis, per Section 4.1 of [55].  The policy for each assignment is\r\n   Specification Required, per Section 4.1 of [55].\r\n",
    "correct_text": "The registry is to be maintained using the Specification Required\r\npolicy as defined in Section 4.1 of [55].",
    "notes": "Found during the IANA Review of 3530bis.",
    "submit_date": "2014-12-30",
    "submitter_name": "Tom Haynes",
    "verifier_id": "133",
    "verifier_name": "Martin Stiemerling",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4492",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "18.17.4",
    "orig_text": "If the server does not support named attributes for the current \r\nfilehandle, an error of NFS4ERR_NOTSUPP will be returned to the \r\nclient.",
    "correct_text": "If the server does not support named attributes for file system \r\nobjects on the file system associated with the current filehandle, \r\nan error of NFS4ERR_NOTSUPP will be returned to the client.",
    "notes": "There are a number of situations in which, a server might not support named attributes on particular file system objects.   A number of cases concern doing an OPENATTR on a named attribute directory or named attribute and are mentioned in the immediately preceeding section.\r\nAside from that contradiction, many implementations might allow named attributes on \r\nsymbolic likes or special files.  The existing text would require NFS4ERR_NOTSUPP rather \r\nthan NFS4ERR_WRONG_TYPE to be returned in such cases, causing the client to conclude \r\nincorrectly that named attribute support is not present for the file system in question, or at \r\nleast be uncertain about the presence/absence of such support.",
    "submit_date": "2015-10-05",
    "submitter_name": "David Noveck",
    "verifier_id": "114",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2019-10-25 01:36:06"
  },
  {
    "errata_id": "4572",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "18.35.3",
    "orig_text": "A server MUST NOT use the same client ID for two different\r\nincarnations of an eir_clientowner.",
    "correct_text": "A server MUST NOT use the same client ID for two different\r\nincarnations of an eia_clientowner.",
    "notes": null,
    "submit_date": "2015-12-30",
    "submitter_name": "Sai Chakravarthy Tangudu",
    "verifier_id": "114",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2019-10-25 01:14:13"
  },
  {
    "errata_id": "4711",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "15.1.5.5",
    "orig_text": "A stateid with a non-zero seqid value does match the current seqid\r\n   for the state designated by the user.",
    "correct_text": "A stateid with a non-zero seqid value is not the most current seqid\r\n   for the state.",
    "notes": "Two issues here:\r\n\r\n1) The negation of the fact, i.e., \"does not match\".\r\n2) The state is not associated with an user.",
    "submit_date": "2016-06-16",
    "submitter_name": "Tom Haynes",
    "verifier_id": "114",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2020-09-03 04:05:40"
  },
  {
    "errata_id": "4712",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "6.2.1.3.1.",
    "orig_text": "   ACE4_DELETE\r\n\r\n      Operation(s) affected:\r\n\r\n         REMOVE",
    "correct_text": "   ACE4_DELETE\r\n\r\n      Operation(s) affected:\r\n\r\n         REMOVE\r\n\r\n         RENAME",
    "notes": "ACE4_DELETE on the source file may allow a rename to proceed in cases where the user does not have ACE4_DELETE_CHILD on the source directory. It may also affect the ability of the user to be able to RENAME if there is an existing file in the target directory with the target name.\r\n\r\nAD notes based on Chuck Lever's input. \r\no\tThe text in RFC 5661 Section 6.2.1.3.1 matches the text in RFC 7530 Section 6.2.1.3.1. Are updaed of RFC 7530 also needed for this reason?\r\no\tShould the Notes section of the errata be added to Section 6.2.1.3.2?\r\no\tA consideration is if there are already server implementations that reject RENAME operations in these cases, or do all server implementations permit RENAME?\r\no\tThis is held so that the issues can be addressed in rfc5661bis after further discussion.\r\no\tAdditional Editorial correction: The Discussion subsections of ACE4_DELETE and ACE4_DELETE are missing the word \"how\". \r\n",
    "submit_date": "2016-06-16",
    "submitter_name": "Trond Myklebust",
    "verifier_id": "114",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2020-09-03 04:11:06"
  },
  {
    "errata_id": "4914",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "14.3.3",
    "orig_text": "Mapping Used by nfs4_cis_prep",
    "correct_text": "Mapping Used by nfs4_mixed_prep",
    "notes": "Section header is incorrect, possibly copied from previous section 14.2.3",
    "submit_date": "2017-01-22",
    "submitter_name": "Dylan Simon",
    "verifier_id": "114",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2019-10-25 01:12:10"
  },
  {
    "errata_id": "5040",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "18.46.3",
    "orig_text": "Operations other than SEQUENCE, BIND_CONN_TO_SESSION, EXCHANGE_ID,\r\nCREATE_SESSION, and DESTROY_SESSION, MUST NOT appear as the first\r\noperation in a COMPOUND.  ",
    "correct_text": "Operations other than SEQUENCE, BIND_CONN_TO_SESSION, \r\nEXCHANGE_ID, DESTROY_CLIENTID, CREATE_SESSION, and \r\nDESTROY_SESSION, MUST NOT appear as the first \r\noperation in a COMPOUND.  ",
    "notes": "In the section for DESTROY_CLIENTID (18.50.3), the following text exists (see snipped section below).\r\nThis means that DESTROY_CLIENTID must also be in the list for operations that are allowed\r\nin the first operation of a compound.\r\n\r\n<...snip...>\r\n   If DESTROY_CLIENTID is not prefixed by SEQUENCE, it MUST be the only\r\n   operation in the COMPOUND request (otherwise, the server MUST return\r\n   NFS4ERR_NOT_ONLY_OP).  If the operation is sent without a SEQUENCE\r\n   preceding it, a client that retransmits the request may receive an\r\n   error in response, because the original request might have been\r\n   successfully executed.\r\n<...snip...>",
    "submit_date": "2017-06-12",
    "submitter_name": "Jonathan Price",
    "verifier_id": "114",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2020-09-03 04:15:15"
  },
  {
    "errata_id": "5212",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "15.2",
    "orig_text": "   | LAYOUTGET            | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,     |\r\n   |                      | NFS4ERR_BADIOMODE, NFS4ERR_BADLAYOUT,      |\r\n   |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,       |\r\n   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |\r\n   |                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,      |\r\n   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,          |\r\n   |                      | NFS4ERR_INVAL, NFS4ERR_IO,                 |\r\n   |                      | NFS4ERR_LAYOUTTRYLATER,                    |\r\n   |                      | NFS4ERR_LAYOUTUNAVAILABLE, NFS4ERR_LOCKED, |\r\n   |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,       |\r\n   |                      | NFS4ERR_NOSPC, NFS4ERR_NOTSUPP,            |\r\n   |                      | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,     |\r\n   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |\r\n   |                      | NFS4ERR_RECALLCONFLICT,                    |\r\n   |                      | NFS4ERR_REP_TOO_BIG,                       |\r\n   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |\r\n   |                      | NFS4ERR_REQ_TOO_BIG,                       |\r\n   |                      | NFS4ERR_RETRY_UNCACHED_REP,                |\r\n   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |\r\n   |                      | NFS4ERR_TOOSMALL, NFS4ERR_TOO_MANY_OPS,    |\r\n   |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,                |\r\n   |                      | NFS4ERR_WRONG_TYPE                         |\r\n",
    "correct_text": "   | LAYOUTGET            | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,     |\r\n   |                      | NFS4ERR_BADIOMODE, NFS4ERR_BADLAYOUT,      |\r\n   |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,       |\r\n   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |\r\n   |                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,      |\r\n   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,          |\r\n   |                      | NFS4ERR_INVAL, NFS4ERR_IO,                 |\r\n   |                      | NFS4ERR_LAYOUTTRYLATER,                    |\r\n   |                      | NFS4ERR_LAYOUTUNAVAILABLE, NFS4ERR_LOCKED, |\r\n   |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,       |\r\n   |                      | NFS4ERR_NOSPC, NFS4ERR_NOTSUPP,            |\r\n   |                      | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,     |\r\n   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |\r\n   |                      | NFS4ERR_RECALLCONFLICT,                    |\r\n   |                      | NFS4ERR_REP_TOO_BIG,                       |\r\n   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |\r\n   |                      | NFS4ERR_REQ_TOO_BIG,                       |\r\n   |                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS,  |\r\n   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |\r\n   |                      | NFS4ERR_TOOSMALL, NFS4ERR_TOO_MANY_OPS,    |\r\n   |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,                |\r\n   |                      | NFS4ERR_WRONG_TYPE                         |\r\n",
    "notes": "It could be argued that the OPEN takes care of a NFS4ERR_ROFS for a LAYOUTGET of a LAYOUTIOMODE4_RW, but that does not explain why WRITE is allowed to return a NFS4ERR_ROFS.\r\n\r\nWith the Flex File Layout Type, the storage device depends on the metadata server enforcing the read-only filesystem semantics. An NFSv3 WRITE to the storage device might be accepted even though the filesystem might be RO. Further, if a snapshot is taken, the storage device might not be aware of the fact that a data file is in a snapshot.\r\n\r\nCurrently, if the underlying filesystem determines that the LAYOUTGET for a LAYOUTIOMODE4_RW is going to return NFS4ERR_ROFS, to be spec compliant, it MUST convert the error code to NFS4ERR_SERVERFAULT.  The client may then decide to perform IO through the metadata server with NFSv4 WRITE calls, which will in turn get a NFS4ERR_ROFS error. This change pushes the responsibility to be on the LAYOUTGET and allows the client to inform the application of an error earlier.\r\n\r\nAD Comments:\r\nThis topic requires WG discussion and establishment of consensus. Thus for future document update. \r\n\r\n --VERIFIER NOTES-- \r\n   This topic requires WG discussion and establishment of consensus. Thus for future document update.\r\n",
    "submit_date": "2017-12-19",
    "submitter_name": "NFS4ERR_ROFS is not a valid error code for LAYOUTGET",
    "verifier_id": "2",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2020-09-04 13:58:13"
  },
  {
    "errata_id": "5467",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "15.2",
    "orig_text": "   | LAYOUTGET            | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,     |\r\n   |                      | NFS4ERR_BADIOMODE, NFS4ERR_BADLAYOUT,      |\r\n   |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,       |\r\n   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |\r\n   |                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,      |\r\n   |                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,          |\r\n   |                      | NFS4ERR_INVAL, NFS4ERR_IO,                 |\r\n   |                      | NFS4ERR_LAYOUTTRYLATER,                    |\r\n   |                      | NFS4ERR_LAYOUTUNAVAILABLE, NFS4ERR_LOCKED, |\r\n   |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,       |\r\n   |                      | NFS4ERR_NOSPC, NFS4ERR_NOTSUPP,            |\r\n   |                      | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,     |\r\n   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |\r\n   |                      | NFS4ERR_RECALLCONFLICT,                    |\r\n   |                      | NFS4ERR_REP_TOO_BIG,                       |\r\n   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |\r\n   |                      | NFS4ERR_REQ_TOO_BIG,                       |\r\n   |                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS,  |\r\n   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |\r\n   |                      | NFS4ERR_TOOSMALL, NFS4ERR_TOO_MANY_OPS,    |\r\n   |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,                |\r\n   |                      | NFS4ERR_WRONG_TYPE                         |",
    "correct_text": "   | LAYOUTGET            | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,     |\r\n   |                      | NFS4ERR_BADIOMODE, NFS4ERR_BADLAYOUT,      |\r\n   |                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,       |\r\n   |                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |\r\n   |                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,      |\r\n   |                      | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,        |\r\n   |                      | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,  |\r\n   |                      | NFS4ERR_LAYOUTTRYLATER,                    |\r\n   |                      | NFS4ERR_LAYOUTUNAVAILABLE, NFS4ERR_LOCKED, |\r\n   |                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,       |\r\n   |                      | NFS4ERR_NOSPC, NFS4ERR_NOTSUPP,            |\r\n   |                      | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,     |\r\n   |                      | NFS4ERR_OP_NOT_IN_SESSION,                 |\r\n   |                      | NFS4ERR_RECALLCONFLICT,                    |\r\n   |                      | NFS4ERR_REP_TOO_BIG,                       |\r\n   |                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |\r\n   |                      | NFS4ERR_REQ_TOO_BIG,                       |\r\n   |                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS,  |\r\n   |                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |\r\n   |                      | NFS4ERR_TOOSMALL, NFS4ERR_TOO_MANY_OPS,    |\r\n   |                      | NFS4ERR_UNKNOWN_LAYOUTTYPE,                |\r\n   |                      | NFS4ERR_WRONG_TYPE                         |",
    "notes": "LAYOUTGET takes a stateid argument that can represent either a layout or a delegation,\r\nor open/lock state. As such, it needs to be able to report back when the state represented\r\nby that stateid has expired.\r\n\r\n(Verified on NFSv4 mailing list)",
    "submit_date": "2018-08-17",
    "submitter_name": "Trond Myklebust",
    "verifier_id": "137",
    "verifier_name": "Spencer Dawkins",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5476",
    "doc-id": "RFC5661",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "18.42.3",
    "orig_text": "   matching layout segment(s) for the defined byte-range, the server\r\n   should return the error NFS4ERR_BAD_LAYOUT.",
    "correct_text": "   matching layout segment(s) for the defined byte-range, the server\r\n   should return the error NFS4ERR_BADLAYOUT.",
    "notes": "The error code is   NFS4ERR_BADLAYOUT.",
    "submit_date": "2018-08-23",
    "submitter_name": "Tigran Mkrtchyan",
    "verifier_id": "114",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2019-10-25 01:10:36"
  },
  {
    "errata_id": "5982",
    "doc-id": "RFC5661",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "2.10.6.1.3.1",
    "orig_text": "   If a requester sent a Sequence operation with a slot ID and sequence\r\n   ID that are in the reply cache but the replier detected that the\r\n   retried request is not the same as the original request, including a\r\n   retry that has different operations or different arguments in the\r\n   operations from the original and a retry that uses a different\r\n   principal in the RPC request's credential field that translates to a\r\n   different user, then this is a false retry.  When the replier detects\r\n   a false retry, it is permitted (but not always obligated) to return\r\n   NFS4ERR_FALSE_RETRY in response to the Sequence operation when it\r\n   detects a false retry.",
    "correct_text": "   If a requester sent a Sequence operation with a slot ID and sequence\r\n   ID that are in the reply cache but the replier detected that the\r\n   retried request is not the same as the original request, including a\r\n   retry that was issued with a different XID or has different operations \r\n   or different arguments in the operations from the original and a retry \r\n   that uses a different principal in the RPC request's credential field \r\n   that translates to a different user, then this is a false retry.  When \r\n   the replier detects a false retry, it is permitted (but not always \r\n   obligated) to return NFS4ERR_FALSE_RETRY in response to the Sequence \r\n   operation when it detects a false retry",
    "notes": "The existing text can be read as requiring checksumming of all requests to foreclose the possibility of not noticing a false retry, which can result in data corruption.  This can be a\r\nsignificant performance consideraation in the processing of WRITE requests and could undercut the benefits of directly placing data to be written which is one of the impotant goals of RPC-over-RDMA.\n --VERIFIER NOTES-- \n   No consensus in the WG if this is just a correction. Thus rejecting the issue and may be brought for WG consenus discussion in the context of document update. ",
    "submit_date": "2020-02-13",
    "submitter_name": "David Noveck",
    "verifier_id": "114",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2020-09-03 04:29:29"
  },
  {
    "errata_id": "6015",
    "doc-id": "RFC5661",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "17",
    "orig_text": "CB_SEQUENCE             | OPT  ",
    "correct_text": "CB_SEQUENCE             | REQ",
    "notes": "The section 20.9.3 of CB_SEQUENCE says\r\n\r\n\"In each CB_COMPOUND request, CB_SEQUENCE MUST appear once and MUST be the\r\n   first operation.  The error NFS4ERR_SEQUENCE_POS MUST be returned\r\n   when CB_SEQUENCE is found in any position in a CB_COMPOUND beyond the\r\n   first.  If any other operation is in the first position of CB_COMPOUND, NFS4ERR_OP_NOT_IN_SESSION MUST be returned.\"\r\n\r\nSince CB_RECALL_SLOT is REQ operation in NFSv4.1. This make CB_COMPOUND as REQ procedure. Since CB_COMPOUND require CB_SEQUENCE as its first operation and hence CB_SEQUENCE must be required operation.",
    "submit_date": "2020-03-12",
    "submitter_name": "Sushil Agarwal",
    "verifier_id": "114",
    "verifier_name": "Magnus Westerlund",
    "update_date": "2020-09-04 00:27:05"
  },
  {
    "errata_id": "6324",
    "doc-id": "RFC5661",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "18.23.3",
    "orig_text": "The request's cookieverf field should be set to 0 zero) when the",
    "correct_text": "The request's cookieverf field should be set to 0 (zero) when the",
    "notes": "Missing the open parenthesis",
    "submit_date": "2020-11-04",
    "submitter_name": "Tigran Mkrtchyan",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  }
]
