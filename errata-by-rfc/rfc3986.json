[
  {
    "errata_id": "1783",
    "doc-id": "RFC3986",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "3.1.",
    "orig_text": "Advice for designers of new URI schemes can be found in [RFC2718].",
    "correct_text": "Advice for designers of new URL schemes can be found in [RFC2718].",
    "notes": "[RFC2718] does not contain advice for designers of new URN schemes; it is applies to URL schemes only and it is titled accordingly.\r\nThe information as published is misleading.\n --VERIFIER NOTES-- \n   Given that RFC 4395 (\"Guidelines and Registration Procedures for New URI Schemes\") obsoletes the referenced RFC 2718 (\"Guidelines for new URL Schemes\"), this erratum is best considered in error.",
    "submit_date": "2009-05-15",
    "submitter_name": "Christopher Yeleighton",
    "verifier_id": "121",
    "verifier_name": "Peter Saint-Andre",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2033",
    "doc-id": "RFC3986",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "3.3.",
    "orig_text": "      path-empty    = 0<pchar>\r\n",
    "correct_text": "      path-empty    = \"\"\r\n",
    "notes": "According to ABNF, 0<pchar> is interpreted as\r\nzero repeatation of the prose-val: pchar.\r\n\r\nHowever pchar is an non-terminal.\r\nSo I think the production should be follows:\r\n  path-empty = 0pchar\r\n\r\nHowever this production means a empty string.\r\nSo\r\n  path-empty = \"\"\r\nis more clear.\r\n\r\nAppendix A. has also the same production.",
    "submit_date": "2010-02-05",
    "submitter_name": "Tanaka Akira",
    "verifier_id": "116",
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2525",
    "doc-id": "RFC3986",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "3.1",
    "orig_text": "Advice for designers of new URI schemes can be found in [RFC2718].\r\n",
    "correct_text": "Advice for designers of new URI schemes can be found in [RFC4395].",
    "notes": "The document [RFC2718] is for designers of designers of new URL schemes only.  It has been obsoleted by [RFC4395] that covers all URI schemes.\r\n\r\n[RFC4395]  \r\nT. Hansen, T. Hardie, T. and L. Masinter,\r\n\"Guidelines and Registration Procedures for New URI Schemes\", \r\nRFC 4395, February 2006.",
    "submit_date": "2010-09-17",
    "submitter_name": "Christopher Yeleighton",
    "verifier_id": "116",
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2624",
    "doc-id": "RFC3986",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "Appendix B",
    "orig_text": "^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?",
    "correct_text": "/^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/",
    "notes": "This is a copy of Erratum #1933, reported against RFC 2396.",
    "submit_date": "2010-11-11",
    "submitter_name": "Peter Saint-Andre",
    "verifier_id": "121",
    "verifier_name": "Peter Saint-Andre",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2717",
    "doc-id": "RFC3986",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "3",
    "orig_text": "      hier-part   = \"//\" authority path-abempty\r\n                  / path-absolute\r\n                  / path-rootless\r\n                  / path-empty\r\n",
    "correct_text": "      hier-part   = \"//\" authority path-abempty\r\n                  / path-absolute\r\n                  / path-noscheme\r\n                  / path-rootless\r\n                  / path-empty\r\n",
    "notes": "There are four ABNF rules for path, but the following words says:\r\n\r\n'These restrictions result in five different ABNF rules for a path (Section 3.3)'\r\n\r\nAnd in section 3.3, there are five rules.\n --VERIFIER NOTES-- \n   PSA: There is no error here, because the hierarchical part excludes\r\n   paths that are not preceded by \"//\", whereas the path rule includes\r\n   paths that are not preceded by \"//\" (thus five rules for \"path\" but\r\n   only four rules for \"hier-part\").",
    "submit_date": "2011-02-14",
    "submitter_name": "Winfred Qin",
    "verifier_id": "121",
    "verifier_name": "Peter Saint-Andre",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2933",
    "doc-id": "RFC3986",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "5.2.2.",
    "orig_text": "T.path = merge(Base.path, R.path);",
    "correct_text": "T.path = merge(Base, R);\r\n",
    "notes": "In 5.2.3. the \"If the base URI has a defined authority component\" condition requires knowing the authority component, so passing just the path component is misleading.\r\n\r\nDuring discussion of this issue, Roy Fielding noted: \"No, this is not an error in the algorithm.  The algorithm is just saying that you need to merge the two paths.  The two paths are not parameters to a function, nor is the merge procedure limited to those two parameters.\" Saving this report as \"Hold For Document Update\" so that future implementers do not experience the same confusion.",
    "submit_date": "2011-08-13",
    "submitter_name": "Bjoern Hoehrmann",
    "verifier_id": "121",
    "verifier_name": "Peter Saint-Andre",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3330",
    "doc-id": "RFC3986",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "Appendix A",
    "orig_text": "fragment      = *( pchar / \"/\" / \"?\" )",
    "correct_text": "fragment      = *( pchar / \"/\" / \"?\" / \"#\" )",
    "notes": "Appendix B's regex doesn't fail with this correction. Additionally, this gives freedom to media type designers. Specifically, the ((path?),(query?),(fragment?)) subsyntax could be reused in hypermedia type design as the \"?\" delimiter transitions path => query and the \"#\" delimiter transitions query => fragment. It also follows the pattern:\r\npath         = *( pchar / \"/\" )\r\nquery         = *( pchar / \"/\" / \"?\" )\r\nfragment      = *( pchar / \"/\" / \"?\" / \"#\" )\n --VERIFIER NOTES-- \nThis is something that should be looked at further, but it is not an error in the spec and is unlikely to be a direct change we'd make in a revision of the spec.\r\n\r\nSome applications at the time the specification was written parsed the fragment from left to right, and others parsed from right to left, which means they would get different results if \"#\" were allowed inside of a fragment.  That's why it was not allowed in the ABNF.  It's possible that situation has improved in the years since, but it would be difficult to test so many implementations.  Deciding the right way to handle this goes beyond what can be handled by an erratum.",
    "submit_date": "2012-08-29",
    "submitter_name": "David Sheets",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4293",
    "doc-id": "RFC3986",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "Appendix B",
    "orig_text": "^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?",
    "correct_text": "^(([^:/?#]+):)(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?",
    "notes": "The regular expression makes the scheme part optional, but both the ABNF in Appendix A and the text in Section 3 state that the scheme is in fact required.\n --VERIFIER NOTES-- \nThe context is that this is for parsing references:\r\n\r\n   The following line is the regular expression for breaking-down a\r\n   well-formed URI reference into its components.\r\n\r\nThe ABNF makes it clear that the scheme is, in fact, NOT required for URI references (see the ABNF for the \"relative-ref\" production).",
    "submit_date": "2015-03-07",
    "submitter_name": "Cesar Crusius",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4393",
    "doc-id": "RFC3986",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "3.2.2",
    "orig_text": "dec-octet   = DIGIT                 ; 0-9\r\n            / %x31-39 DIGIT         ; 10-99\r\n            / \"1\" 2DIGIT            ; 100-199\r\n            / \"2\" %x30-34 DIGIT     ; 200-249\r\n            / \"25\" %x30-35          ; 250-255",
    "correct_text": "dec-octet = \"25\" %x30-35          ; 250-255\r\n          / \"2\" %x30-34 DIGIT     ; 200-249\r\n          / \"1\" 2DIGIT            ; 100-199\r\n          / %x31-39 DIGIT         ; 10-99\r\n          / DIGIT                 ; 0-9",
    "notes": "The 'dec-octet' rule requires more than 1 lookahead symbol.\r\n\r\nExample value: 127\r\n\r\nParsers that implement a first-match-wins strategy will erroneously match 127 as ( DIGIT ), followed by two unexpected symbols.\r\n\r\nParsers that implement a first-match-wins strategy with the corrected grammar will correctly match 127 as ( \"1\" 2DIGIT ).\n --VERIFIER NOTES-- \nYes, except that ABNF defined in RFC 5234 is designed to describe what's valid to produce -- it's not designed as the definitive source for building a perfect parser.  In particular, the order of the alternatives is not significant in ABNF, so reordering them is irrelevant.\r\n\r\nIn fact, the ABNF here is more specific than it often is.  In other RFCs it will say things like\r\n   xyz = 0 / %x31-39 *2DIGIT ; valid values are 0-255\r\n...and just let the comment restrict the maximum value.",
    "submit_date": "2015-06-15",
    "submitter_name": "Steven Liekens",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4394",
    "doc-id": "RFC3986",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "3.2.2",
    "orig_text": "IPv6address =                            6( h16 \":\" ) ls32\r\n                 /                       \"::\" 5( h16 \":\" ) ls32\r\n                 / [               h16 ] \"::\" 4( h16 \":\" ) ls32\r\n                 / [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\r\n                 / [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\r\n                 / [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\r\n                 / [ *4( h16 \":\" ) h16 ] \"::\"              ls32\r\n                 / [ *5( h16 \":\" ) h16 ] \"::\"              h16\r\n                 / [ *6( h16 \":\" ) h16 ] \"::\"",
    "correct_text": "IPv6address = (                6( h16 \":\" ) ls32 ) \r\n            / (           \"::\" 5( h16 \":\" ) ls32 )\r\n            / ( [   h16 ] \"::\" 4( h16 \":\" ) ls32 )\r\n            / ( [ h16-2 ] \"::\" 3( h16 \":\" ) ls32 )\r\n            / ( [ h16-3 ] \"::\" 2( h16 \":\" ) ls32 )\r\n            / ( [ h16-4 ] \"::\"    h16 \":\"   ls32 )\r\n            / ( [ h16-5 ] \"::\"              ls32 )\r\n            / ( [ h16-6 ] \"::\"               h16 )\r\n            / ( [ h16-7 ] \"::\"                   )\r\n\r\nh16-7       = ( *6( h16 \":\" ) h16 ) / h16-6\r\n\r\nh16-6       = ( *5( h16 \":\" ) h16 ) / h16-5\r\n\r\nh16-5       = ( *4( h16 \":\" ) h16 ) / h16-4\r\n\r\nh16-4       = ( *3( h16 \":\" ) h16 ) / h16-3\r\n\r\nh16-3       = ( *2( h16 \":\" ) h16 ) / h16-2\r\n\r\nh16-2       = (   [ h16 \":\" ] h16 ) / h16",
    "notes": "The 'IPv6address' rule requires more than 1 lookahead symbol.\r\n\r\nExample value: 1::\r\n\r\nParsers that implement a first-match-wins strategy will erroneously match 1:: as ( h16 \":\" ), followed by an unexpected symbol.\r\n\r\nParsers that implement a first-match-wins strategy with the corrected grammar will correctly match 1:: as ( h16 \"::\" ).\n --VERIFIER NOTES-- \nAs with errata report 4393, this is trying to use ABNF beyond what it's meant for.",
    "submit_date": "2015-06-15",
    "submitter_name": "Steven Liekens",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4547",
    "doc-id": "RFC3986",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "5.4.2",
    "orig_text": "5.4.2.  Abnormal Examples\r\n\r\n   Although the following abnormal examples are unlikely to occur in\r\n   normal practice, all URI parsers should be capable of resolving them\r\n   consistently.  Each example uses the same base as that above.\r\n\r\n   Parsers must be careful in handling cases where there are more \"..\"\r\n   segments in a relative-path reference than there are hierarchical\r\n   levels in the base URI's path.  Note that the \"..\" syntax cannot be\r\n   used to change the authority component of a URI.\r\n\r\n      \"../../../g\"    =  \"http://a/g\"\r\n      \"../../../../g\" =  \"http://a/g\"\r\n",
    "correct_text": "5.4.2.  Abnormal Examples\r\n\r\n   Although the following abnormal examples are unlikely to occur in\r\n   normal practice, all URI parsers should be capable of resolving them\r\n   consistently.  Each example uses the same base as that above.\r\n\r\n   Parsers must be careful in handling cases where there are more \"..\"\r\n   segments in a relative-path reference than there are hierarchical\r\n   levels in the base URI's path.  Note that the \"..\" syntax cannot be\r\n   used to change the authority component of a URI.\r\n\r\n      \"../../../g\"    =  \"http://a/../g\"\r\n      \"../../../../g\" =  \"http://a/../../g\"\r\n",
    "notes": "The example which was taken from RFC 1808 had proper resolved URL ( 5.2 ).\r\n\r\nAs the base URL has two levels ( http://a/b/c/ ) and if the relative url's have two \"..\" segments then from the resolved URI both the hierarchical levels can be removed to form the resolved URL, as below:\r\n\r\n../../g    = http://a/g \r\n\r\nand if there are more \"..\" segments than hierarchical level in base URI's path... then the number of \"..\" segments that doesn't have corresponding segments in base URI should be left as is in the resolved URI,  like below\r\n\r\n\"../../../g\" = \"http://a/../g\"",
    "submit_date": "2015-12-01",
    "submitter_name": "siva elango ramaswamy",
    "verifier_id": "2",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4789",
    "doc-id": "RFC3986",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "5.2.3",
    "orig_text": "   o  If the base URI has a defined authority component and an empty\r\n      path, then return a string consisting of \"/\" concatenated with the\r\n      reference's path; otherwise,\r\n",
    "correct_text": "   o  If the base URI has a defined authority component and an empty \r\n      path, or if the base URI's path is ending with \"/..\", then return \r\n      a string consisting of base's path concatenated with \"/\" and then \r\n      concatenated with the reference's path; otherwise,",
    "notes": "this is about case when reference does not have scheme and authority and its path is not starting with \"/\".",
    "submit_date": "2016-08-31",
    "submitter_name": "Dinar Qurbanov",
    "verifier_id": "2",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4942",
    "doc-id": "RFC3986",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "3.2.2. Host",
    "orig_text": "Such a name consists of a sequence of domain labels separated by \".\",\r\neach domain label starting and ending with an alphanumeric character\r\nand possibly also containing \"-\" characters.  The rightmost domain\r\nlabel of a fully qualified domain name in DNS may be followed by a\r\nsingle \".\" and should be if it is necessary to distinguish between\r\nthe complete domain name and some local domain.\r\n\r\n   reg-name    = *( unreserved / pct-encoded / sub-delims )\r\n\r\nIf the URI scheme defines a default for host, then that default\r\n",
    "correct_text": "Such a name consists of a sequence of domain labels separated by \".\",\r\neach domain label starting and ending with an alphanumeric character\r\nand possibly also containing \"-\" characters.  The rightmost domain\r\nlabel of a fully qualified domain name in DNS may be followed by a\r\nsingle \".\" and should be if it is necessary to distinguish between\r\nthe complete domain name and some local domain.\r\n\r\n   reg-name    = *( unreserved / pct-encoded / \"-\" / \".\")\r\n\r\nIf the URI scheme defines a default for host, then that default\r\n",
    "notes": "sub-delims  are defined as \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\" these are not characters that are allowed in host, domain or tld names, in addition the sub-delims do not sontain the \"-\" and \".\" \r\ntherefore the reg-name (fully qualified domain name) definition is incorrect   \r\n\r\nThe same issue appears in \"Appendix A.\"",
    "submit_date": "2017-02-19",
    "submitter_name": "r. de raat",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5428",
    "doc-id": "RFC3986",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.2",
    "orig_text": "      relative-part = \"//\" authority path-abempty\r\n                    / path-absolute\r\n                    / path-noscheme\r\n                    / path-empty\r\n",
    "correct_text": "      relative-part = \"//\" authority path-abempty\r\n                    / path-absolute\r\n                    / path-noscheme\r\n\t\t    / path-abempty    ; this was added\r\n                    / path-empty\r\n",
    "notes": "As written, the ABNF excludes \"/\" being a valid URI.  It is hard to believe that href=\"/\" when converted to a URI, would be illegal.",
    "submit_date": "2018-07-17",
    "submitter_name": "Kevin Layer",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "7019",
    "doc-id": "RFC3986",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "B",
    "orig_text": "^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?",
    "correct_text": "^(([^:/?#]+):#)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?",
    "notes": "Added the missing '#\" delimiter.\n --VERIFIER NOTES-- \nIn rejecting this Errata report I note that the reported error is not an error, but a deliberate decision of the authors and working group. The change, therefore, if it is to be applied needs to be achieved through a consensus document and definitely not via an errata report.",
    "submit_date": "2022-07-10",
    "submitter_name": "Tim McSweeney",
    "verifier_id": "170",
    "verifier_name": "Francesca Palombini",
    "update_date": "2022-07-12 03:42:42"
  }
]
