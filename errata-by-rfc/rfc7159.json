[
  {
    "errata_id": "3915",
    "doc-id": "RFC7159",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "12",
    "orig_text": "   Since JSON's syntax is borrowed from JavaScript, it is possible to\r\n   use that language's \"eval()\" function to parse JSON texts.",
    "correct_text": "   Since JSON's syntax is borrowed from JavaScript, it is possible to\r\n   use that language's \"eval()\" function to parse most (but not all)\r\n   JSON texts.",
    "notes": "This wording may be construed as meaning that every compliant JSON text is parseable as JavaScript, which is not the case: <http://timelessrepo.com/json-isnt-a-javascript-subset>. (Actually I would prefer this to be stated clearly elsewhere in the document, e.g. where it says \"JSON's design goals were for it to be [...] a subset of JavaScript\".)\r\n\r\n --VERIFIER NOTES-- \r\nAs per the above citation, there are characters (in particular line terminators like U+2028 and U+2029) which are permissible in JSON but not permissible in JavaScript. The corrected text makes this clearer.",
    "submit_date": "2014-03-07",
    "submitter_name": "Vasiliy Faronov",
    "verifier_id": "127",
    "verifier_name": "Pete Resnick",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3983",
    "doc-id": "RFC7159",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "2.",
    "orig_text": "JSON-text = ws value ws",
    "correct_text": "JSON-text = [BOM] ws value ws\r\n\r\nBOM = %xFEFF",
    "notes": "Section 8.1 states:\r\n[START QUOTE]\r\n(...) implementations that parse JSON texts *MAY* ignore the presence of a byte order mark rather than treating it as an error.\r\n[END QUOTE]\r\n\r\nIndeed that means that a BOM *CAN* occur, and *MAY* be accepted instead of returning an error. So, if the BOM can be accepted, the grammar is incomplete as it does not show it.\r\n\r\nFurthermore, about BOMs, see my other comments.\n --VERIFIER NOTES-- \nThe WG was clear that syntactically, the BOM is not part of a valid JSON-text, but implementation advice included that if one appears, it MAY be ignored. The document is correct as-is.",
    "submit_date": "2014-05-09",
    "submitter_name": "Alain BENEDETTI",
    "verifier_id": "127",
    "verifier_name": "Pete Resnick",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3984",
    "doc-id": "RFC7159",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "7",
    "orig_text": "unescaped = %x20-21 / %x23-5B / %x5D-10FFFF",
    "correct_text": "unescaped = %x20-21 / %x23-5B / %x5D-D7FF / %xE000-10FFFF",
    "notes": "Section 1 says:\r\n[START QUOTE]\r\nA string is a sequence of zero or more Unicode characters [UNICODE]. Note that this citation references the latest version of Unicode rather than a specific release.\r\n[END QUOTE]\r\n\r\nSection 8.2 emphasizes on the characters not allowed by the Unicode norm:\r\n[START QUOTE]\r\nHowever, the ABNF in this specification allows member names and string values to contain bit sequences that cannot encode Unicode characters; for example, \"\\uDEAD\" (a single unpaired UTF-16 surrogate).\r\n[END QUOTE]\r\n\r\nThe ABNF cannot at the same time allow non conformant Unicode codepoints (section 7) and states conformance to Unicode (section 1).\r\n\r\nTherefore, there is an incoherence that must be fixed between section 1 (and 8.2 that emphasizes it) and section 7. Hence the proposition of modification in section 7.\r\n\r\nThe other less preferable solution to this fix incoherence in RFC7159 would have been to NOT require Unicode conformance.\n --VERIFIER NOTES-- \nThe WG's consensus was to leave the full range present in the ABNF and add the interoperability guidance about values outside the Unicode accepted range.\r\n",
    "submit_date": "2014-05-09",
    "submitter_name": "Alain BENEDETTI",
    "verifier_id": "127",
    "verifier_name": "Pete Resnick",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4220",
    "doc-id": "RFC7159",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "7",
    "orig_text": "   […] All Unicode characters may be placed within the\r\n   quotation marks, except for the characters that must be escaped:\r\n   quotation mark, reverse solidus, and the control characters (U+0000\r\n   through U+001F).\r\n\r\n[…]\r\n\r\n      unescaped = %x20-21 / %x23-5B / %x5D-10FFFF",
    "correct_text": "   […] All Unicode characters may be placed within the\r\n   quotation marks, except for the characters that must be escaped:\r\n   quotation mark, reverse solidus, the control characters (U+0000\r\n   through U+001F), and codepoints beyond the BMP (U-00010000\r\n   through U-0010FFFF).\r\n\r\n[…]\r\n\r\n      unescaped = %x20-21 / %x23-5B / %x5D-FFFF",
    "notes": "ECMA-262 states that \"ECMAScript source text is assumed to be a sequence\r\nof 16-bit code units\", and everything must be converted to UTF-16 first.\r\nThis stems from the fact that Java™, like Win32, used UCS-2, which only\r\nlater got extended to allow UTF-16. This means that SMP codepoints must\r\nalways be escaped into their twelve-character form.\r\n\r\nThis is also an interoperability issue: implementations may wish to parse\r\n(or generate) JSON by using a wchar_t data type (in C) which, depending on\r\nthe platform, may be only 16 bits wide. ECMAscript allows for this.\n --VERIFIER NOTES-- \nThis is reporting a disagreement with a decision the working group made in the development of the document, and is not reporting an erratum.",
    "submit_date": "2015-01-05",
    "submitter_name": "mirabilos",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4264",
    "doc-id": "RFC7159",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "15.2",
    "orig_text": "   [Err3607]  RFC Errata, Errata ID 3607, RFC 3607,\r\n              <http://www.rfc-editor.org>.\r\n\r\n   [Err607]   RFC Errata, Errata ID 607, RFC 607,\r\n              <http://www.rfc-editor.org>.",
    "correct_text": "   [Err3607]  RFC Errata, Errata ID 3607, for RFC 4627,\r\n              <http://www.rfc-editor.org>.\r\n\r\n   [Err607]   RFC Errata, Errata ID 607, for RFC 4627,\r\n              <http://www.rfc-editor.org>.",
    "notes": "The references point to RFCs by the same numbers as the errata IDs, while the intention was to refer to errata (by the same IDs) reported for the previous JSON RFC, namely RFC 4627. (RFCs 607 and 3607 are completely unrelated.)\r\n\r\nThe links may also be replaced with direct links to the errata pages, for instance http://www.rfc-editor.org/errata_search.php?eid=607 and http://www.rfc-editor.org/errata_search.php?eid=3607",
    "submit_date": "2015-02-05",
    "submitter_name": "Federico do Pino",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4298",
    "doc-id": "RFC7159",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "7 Strings",
    "orig_text": "4HEXDIG",
    "correct_text": "Something along the lines\r\n\r\n4hexdig\r\nhexdig = 0..9 A..F a..f",
    "notes": "The prose states that within a six-character escape sequence starting \\u, the hex digits can be either upper or lower case. But the grammar only allows upper case, because it uses the symbol HEXDIG which is defined in RFC 5234 to include upper case A..F only. There is thus an inconsistency beween the grammar and the prose, and although most readers are likely to know which to believe, the spec is formally ambiguous on this point.\n --VERIFIER NOTES-- \nThe reporter doesn't understand RFC 5234.  Look in Section 2.3 (Terminal Values), and see this:\r\n\r\n>   NOTE:\r\n>\r\n>      ABNF strings are case insensitive and the character set for these\r\n>      strings is US-ASCII.\r\n\r\nThere is no inconsistency, and the text as written allows both upper and lower case for the hex digits.",
    "submit_date": "2015-03-11",
    "submitter_name": "Michael Kay",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4336",
    "doc-id": "RFC7159",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "Appendix A",
    "orig_text": "[NO MENTION OF SECTION 3 OF RFC 4627]",
    "correct_text": "   o  Removed method of detection of character encoding from\r\n      section 3 \"Encoding\" of RFC 4627.\r\n\r\n       ",
    "notes": "Appendix 1 (listing changes between RFC 4627 and RFC 7159) does not include any comment on the removal of this text from RFC 4627 section 3:\r\n\r\n[START QUOTE]\r\n   Since the first two characters of a JSON text will always be ASCII\r\n   characters [RFC0020], it is possible to determine whether an octet\r\n   stream is UTF-8, UTF-16 (BE or LE), or UTF-32 (BE or LE) by looking\r\n   at the pattern of nulls in the first four octets.\r\n\r\n           00 00 00 xx  UTF-32BE\r\n           00 xx 00 xx  UTF-16BE\r\n           xx 00 00 00  UTF-32LE\r\n           xx 00 xx 00  UTF-16LE\r\n           xx xx xx xx  UTF-8\r\n[END QUOTE]\r\n\r\n\r\nThe new section 8.1 \"Character encoding\" states that:\r\n\r\n[START QUOTE]\r\nJSON text SHALL be encoded in UTF-8, UTF-16, or UTF-32\r\n[END QUOTE]\r\n\r\nbut, unlike RFC 4627 section 3, it does not say anything about how to distinguish which has been used when parsing a byte string as JSON.\r\n\r\n\r\nRFC 7159 section 8.1 also says:\r\n\r\n[START QUOTE]\r\n   Implementations MUST NOT add a byte order mark to the beginning of a\r\n   JSON text.\r\n[END QUOTE]\r\n\r\nwhich rules out using a byte order mark for this purpose.\r\n\r\n\r\nAdditionally, RFC 7159 section 11 says:\r\n\r\n[START QUOTE]\r\n   Note:  No \"charset\" parameter is defined for this registration.\r\n      Adding one really has no effect on compliant recipients.\r\n[END QUOTE]\r\n\r\nwhich rules out one means of communicating which character encoding is in use when communicating JSON over HTTP (namely a charset parameter on the media type), and implies that there is another means of detecting the character encoding, but does not say what it is.\r\n\r\n\r\nI've reported this as an erratum on the appendix, as I expect there is an existing means of detecting which of the Unicode character encodings are in use, but I was expecting the appendix to reference it as part of an explanation of the removal of the text I quoted from RFC 4627 section 3 but no such explanation is present. It may be the case that the erratum ought to be against section 8.1 to provide a reference there.",
    "submit_date": "2015-04-14",
    "submitter_name": "Martin Pain",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4388",
    "doc-id": "RFC7159",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "1.2",
    "orig_text": "   This document updates [RFC4627], which describes JSON and registers\r\n   the media type \"application/json\".\r\n\r\n",
    "correct_text": "   This document replaces [RFC4627], which previously described JSON and\r\n   registered the media type \"application/json\".\r\n\r\n",
    "notes": "The link at https://tools.ietf.org/html/rfc7159 says it obsoletes RFC 4627.  I believe this is the intent and result of RFC 7159, and that RFC 4627 need not be consulted except for historical reasons going forward.",
    "submit_date": "2015-06-09",
    "submitter_name": "Kerry Lynn",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  }
]
