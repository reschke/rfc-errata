[
  {
    "errata_id": "3150",
    "doc-id": "RFC6455",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.1",
    "orig_text": "AQIDBAUGBwgJCgsMDQ4PEC==",
    "correct_text": "AQIDBAUGBwgJCgsMDQ4PEA==",
    "notes": "The \"test vector\" for Sec-WebSocket-Key encoding, provided in RFC 6455 section 4.1, is wrong.  It was processed by a base 64 encoder that was \"improperly implemented\" as mentioned in RFC 4648 section 3.5.  Pad bits were not set to zero, which is a \"MUST\" requirement in RFC 4648, and was also required by many other RFCs, going back to RFC 989 in the 1980s.  In the string \"AQIDBAUGBwgJCgsMDQ4PEC==\", the final C should be changed to A.\r\n\r\nIn a Sec-WebSocket-Key header sent by a properly implemented client, the last letter will always be A, Q, g or w.",
    "submit_date": "2012-03-07",
    "submitter_name": "Robert Munyer",
    "verifier_id": "121",
    "verifier_name": "Peter Saint-Andre",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3215",
    "doc-id": "RFC6455",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "5.3",
    "orig_text": "The unpredictability of the masking key is\r\nessential to prevent authors of malicious applications from selecting\r\nthe bytes that appear on the wire.",
    "correct_text": null,
    "notes": "I don't see how the client-to-server masking prevents \"authors of malicious applications from selecting the bytes that appear on the wire\".\r\n\r\nMaliciously changing the contents of a message simply requires a few more steps than it would without masking, as far as I can tell.\r\n\r\nI'm quite new at networking, so perhaps I'm missing something.  Thank you.\r\n --VERIFIER NOTES-- \r\nNot appropriate for errata; please take your input to the HyBi working group as it continues its efforts.   ",
    "submit_date": "2012-05-06",
    "submitter_name": "Jesse Katzman",
    "verifier_id": "2",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3227",
    "doc-id": "RFC6455",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "7.4.1",
    "orig_text": "   1011\r\n\r\n      1011 indicates that a server is terminating the connection because\r\n      it encountered an unexpected condition that prevented it from\r\n      fulfilling the request.\r\n",
    "correct_text": "   1011\r\n\r\n      1011 indicates that a remote endpoint is terminating the connection\r\n      because it encountered an unexpected condition that prevented it from\r\n      fulfilling the request.\r\n",
    "notes": "As per the discussion in the WG (See <http://www.ietf.org/mail-archive/web/hybi/current/msg09628.html>) the meaning of this error close code should be extended to cover clients as well. As the Designated Expert for the WebSocket close code registry I've approved the corresponding change to the IANA registry.\r\n\r\nThis should be \"hold for update\" for rfc6455bis.",
    "submit_date": "2012-05-16",
    "submitter_name": "Alexey Melnikov",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3432",
    "doc-id": "RFC6455",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "5.7",
    "orig_text": "   o  Unmasked Ping request and masked Ping response\r\n\r\n      *  0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains a body of \"Hello\",\r\n         but the contents of the body are arbitrary)\r\n\r\n      *  0x8a 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58\r\n         (contains a body of \"Hello\", matching the body of the ping)\r\n\r\n",
    "correct_text": "   o  Unmasked Ping request and masked Pong response\r\n\r\n      *  0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains a body of \"Hello\",\r\n         but the contents of the body are arbitrary)\r\n\r\n      *  0x8a 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58\r\n         (contains a body of \"Hello\", matching the body of the ping)\r\n\r\n",
    "notes": "The response isn't a Ping, it's a Pong.\r\n --VERIFIER NOTES-- \r\nThe errata system is meant for documentation errors that could cause implementation confusion.  I don't think this will confuse anyone.   ",
    "submit_date": "2012-12-18",
    "submitter_name": "Eric Lawrence",
    "verifier_id": "2",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3433",
    "doc-id": "RFC6455",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "11.3.2",
    "orig_text": "However, the |Sec-WebSocket-Extensions| header field MUST NOT appear\r\nmore than once in an HTTP response.\r\n",
    "correct_text": "The |Sec-WebSocket-Extensions| header field MAY appear multiple \r\ntimes in an HTTP response (which is logically the same as a single\r\n|Sec-WebSocket-Extensions| header field that contains all values).\r\n",
    "notes": "Section 4.2.2 Step 5 subpart 6 (top of page 25) clearly explains that this header field may appear multiple times in the server's response: \"If multiple extensions are to be used, they can all be listed in a single |Sec-WebSocket-Extensions| header field or split between multiple instances of the |Sec-WebSocket-Extensions| header field. This completes the server's handshake...\"",
    "submit_date": "2012-12-20",
    "submitter_name": "Eric Lawrence",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3473",
    "doc-id": "RFC6455",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "4.1",
    "orig_text": "   2.  If the client already has a WebSocket connection to the remote\r\n       host (IP address) identified by /host/ and port /port/ pair, even\r\n       if the remote host is known by another name, the client MUST wait\r\n       until that connection has been established or for that connection\r\n       to have failed.  There MUST be no more than one connection in a\r\n       CONNECTING state.  If multiple connections to the same IP address\r\n       are attempted simultaneously, the client MUST serialize them so\r\n       that there is no more than one connection at a time running\r\n       through the following steps.",
    "correct_text": "   2.  If the client already has a WebSocket connection to the same IP\r\n       address and port pair, even if the remote host is known by another\r\n       name, the client MUST wait until that connection has been established\r\n       or for that connection to have failed.  There MUST be no more than\r\n       one connection in the CONNECTING state for any IP address and port\r\n       pair.  If multiple connections to the same IP address and port pair\r\n       are attempted simultaneously, the client MUST serialize them so that\r\n       there is no more than one connection at a time running through the\r\n       following steps.",
    "notes": "The original wording makes it ambiguous whether distinct ports on the same host are considered distinct for throttling purposes. The first sentence implies that the throttling should be applied per (host,port) pair, whereas the final sentence implies it is only based on IP address.\r\n\r\nImplementations of both interpretations appear to exist in the wild.\r\n\r\nI propose disambiguating in favour of the (host,port) interpretation, because the host-only interpretation allows for a potential denial-of-service attack targeted against hosts which drop packets to unused ports.\r\n\r\nFor example, an attacker from a different origin can create several hundred WebSockets to \"wss://google.com:81/\". Each one will attempt to connect in serial, and take tens of seconds to time out.\r\n\r\nIf the user then attempts to use an application which legitimately uses a WebSocket to \"wss://google.com:443/\", then due to the throttling to google.com it will not be able to connect until all of the attacker's connections have timed out.\r\n\r\nThe user will perceive that the legitimate application is malfunctioning, since there is no visible sign that they are being attacked. From the server end, the attack is only apparent in the firewall logs. The actual rate of SYN packets dropped will be small and unlikely to trigger an alert.\r\n\r\nOn the other hand, with the (host,port) interpretation, connections to google.com:81 do not block connections to google.com:443, and this attack is completely ineffective.\r\n\r\n=== Verifier Notes ===\r\n\r\nThe subsequent paragraph already indicates what must be done in the case where the IP address cannot be determined, so this change should not create any difficulties in the case where the connection is tunnelled via an HTTP(S) or SOCKS5 proxy.\r\n\r\nA separate concern has been raised that this section creates problems for WebSocket proxies and non-browser clients.  That issue cannot be handled without changing the meaning of the text, so it would have to be dealt with in a document update.",
    "submit_date": "2013-01-31",
    "submitter_name": "Adam Rice",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3912",
    "doc-id": "RFC6455",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "5.2",
    "orig_text": "    frame-payload-length    = ( %x00-7D )\r\n                            / ( %x7E frame-payload-length-16 )\r\n                            / ( %x7F frame-payload-length-63 )\r\n                            ; 7, 7+16, or 7+64 bits in length,\r\n                            ; respectively\r\n\r\n    frame-payload-length-16 = %x0000-FFFF ; 16 bits in length\r\n\r\n    frame-payload-length-63 = %x0000000000000000-7FFFFFFFFFFFFFFF\r\n                            ; 64 bits in length",
    "correct_text": "    frame-payload-length    = ( %x00-7D )\r\n                            / ( %x7E frame-payload-length-16 )\r\n                            / ( %x7F frame-payload-length-64 )\r\n                            ; 7, 7+16, or 7+64 bits in length,\r\n                            ; respectively\r\n\r\n    frame-payload-length-16 = %x0000-FFFF ; 16 bits in length\r\n\r\n    frame-payload-length-64 = %x0000000000000000-FFFFFFFFFFFFFFFF\r\n                            ; 64 bits in length",
    "notes": "Name of field and range is implying that it should be 63 bits in length, but documentation is saying 64 bits in 2 places.\n --VERIFIER NOTES-- \nThe intended interpretation is that lexically the field is 64 bit long but the value space is constrained to 63 bit (so the length can be represented in a 64 signed integer, with the sign bit always zero). It is a bit unconventional to use ABNF like this, but it is explained in Section 5.2.",
    "submit_date": "2014-03-05",
    "submitter_name": "Mattias Ekendahl",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4184",
    "doc-id": "RFC6455",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "5.4",
    "orig_text": "5.4.  Fragmentation\r\n\r\n   The primary purpose of fragmentation is to allow sending a message\r\n   that is of unknown size when the message is started without having to\r\n   buffer that message.  If messages couldn't be fragmented, then an\r\n   endpoint would have to buffer the entire message so its length could\r\n   be counted before the first byte is sent.  With fragmentation, a\r\n   server or intermediary may choose a reasonable size buffer and, when\r\n   the buffer is full, write a fragment to the network.\r\n\r\n   A secondary use-case for fragmentation is for multiplexing, where it\r\n   is not desirable for a large message on one logical channel to\r\n   monopolize the output channel, so the multiplexing needs to be free\r\n   to split the message into smaller fragments to better share the\r\n   output channel.  (Note that the multiplexing extension is not\r\n   described in this document.)\r\n\r\n   Unless specified otherwise by an extension, frames have no semantic\r\n   meaning.  An intermediary might coalesce and/or split frames, if no\r\n   extensions were negotiated by the client and the server or if some\r\n   extensions were negotiated, but the intermediary understood all the\r\n   extensions negotiated and knows how to coalesce and/or split frames\r\n   in the presence of these extensions.  One implication of this is that\r\n   in absence of extensions, senders and receivers must not depend on\r\n   the presence of specific frame boundaries.\r\n\r\n   The following rules apply to fragmentation:\r\n\r\n   o  An unfragmented message consists of a single frame with the FIN\r\n      bit set (Section 5.2) and an opcode other than 0.\r\n\r\n   o  A fragmented message consists of a single frame with the FIN bit\r\n      clear and an opcode other than 0, followed by zero or more frames\r\n      with the FIN bit clear and the opcode set to 0, and terminated by\r\n      a single frame with the FIN bit set and an opcode of 0.  A\r\n      fragmented message is conceptually equivalent to a single larger\r\n      message whose payload is equal to the concatenation of the\r\n      payloads of the fragments in order; however, in the presence of\r\n      extensions, this may not hold true as the extension defines the\r\n      interpretation of the \"Extension data\" present.  For instance,\r\n      \"Extension data\" may only be present at the beginning of the first\r\n      fragment and apply to subsequent fragments, or there may be\r\n      \"Extension data\" present in each of the fragments that applies\r\n      only to that particular fragment.  In the absence of \"Extension\r\n      data\", the following example demonstrates how fragmentation works.\r\n\r\n      EXAMPLE: For a text message sent as three fragments, the first\r\n      fragment would have an opcode of 0x1 and a FIN bit clear, the\r\n      second fragment would have an opcode of 0x0 and a FIN bit clear,\r\n      and the third fragment would have an opcode of 0x0 and a FIN bit\r\n      that is set.\r\n\r\n   o  Control frames (see Section 5.5) MAY be injected in the middle of\r\n      a fragmented message.  Control frames themselves MUST NOT be\r\n      fragmented.\r\n\r\n   o  Message fragments MUST be delivered to the recipient in the order\r\n      sent by the sender.\r\n\r\n   o  The fragments of one message MUST NOT be interleaved between the\r\n      fragments of another message unless an extension has been\r\n      negotiated that can interpret the interleaving.\r\n\r\n   o  An endpoint MUST be capable of handling control frames in the\r\n      middle of a fragmented message.\r\n\r\n   o  A sender MAY create fragments of any size for non-control\r\n      messages.\r\n\r\n   o  Clients and servers MUST support receiving both fragmented and\r\n      unfragmented messages.\r\n\r\n   o  As control frames cannot be fragmented, an intermediary MUST NOT\r\n      attempt to change the fragmentation of a control frame.\r\n\r\n   o  An intermediary MUST NOT change the fragmentation of a message if\r\n      any reserved bit values are used and the meaning of these values\r\n      is not known to the intermediary.\r\n\r\n   o  An intermediary MUST NOT change the fragmentation of any message\r\n      in the context of a connection where extensions have been\r\n      negotiated and the intermediary is not aware of the semantics of\r\n      the negotiated extensions.  Similarly, an intermediary that didn't\r\n      see the WebSocket handshake (and wasn't notified about its\r\n      content) that resulted in a WebSocket connection MUST NOT change\r\n      the fragmentation of any message of such connection.\r\n\r\n   o  As a consequence of these rules, all fragments of a message are of\r\n      the same type, as set by the first fragment's opcode.  Since\r\n      control frames cannot be fragmented, the type for all fragments in\r\n      a message MUST be either text, binary, or one of the reserved\r\n      opcodes.\r\n\r\n   NOTE: If control frames could not be interjected, the latency of a\r\n   ping, for example, would be very long if behind a large message.\r\n   Hence, the requirement of handling control frames in the middle of a\r\n   fragmented message.\r\n\r\n   IMPLEMENTATION NOTE: In the absence of any extension, a receiver\r\n   doesn't have to buffer the whole frame in order to process it.  For\r\n   example, if a streaming API is used, a part of a frame can be\r\n   delivered to the application.  However, note that this assumption\r\n   might not hold true for all future WebSocket extensions.\r\n",
    "correct_text": null,
    "notes": "There is no indication or mention of the payload length of the frame with regards to fragmentation. In abstract, it's apparent that the payload length specified in the header of the frame corresponds to the actual frames payload length. However, implementations have been observed that allow the headers payload length to be specified as a higher length than the actual raw payload of that frame. In the event that this occurs, some implementations are reallocating memory to support the length of what is reported as the entire payload of all fragmented messages combined, and continue building the buffer off of each frame from that point forward by allocating enough memory for specified payload length. Obviously, this opens up the potential for a memory consumption DoS attack on an implementation that uses this method. A lack of specification with regards to the RFC allows for such a mistake to happen, as it is not clearly defined in the fragmentation section.\r\n\r\nThe RFC specifies that fragmented messages should be used to send messages of an unknown length, i.e. streaming media, and therefore should also specify that the frame length bit should be preserved to the length of only that current frame and not be used to specify the overall payload length of all fragmented messages combined. Implementations should be forced to work with them on a frame-by-frame basis and to drop the connection of any instances where the specified length of the frames payload does not match the length of the actual raw payload data for that one frame.\n --VERIFIER NOTES-- \nThanks, Jonathan, for some useful comments.  As we discussed, these aren't appropriate for the errata system, but should be discussed on the relevant mailing list for possibly inclusion in an update or follow-on to the document.  That list is <hybi@ietf.org>.",
    "submit_date": "2014-11-17",
    "submitter_name": "Jonathan Hall",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4398",
    "doc-id": "RFC6455",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "4.1",
    "orig_text": "1. The components of the WebSocket URI passed into this algorithm\r\n   (/host/, /port/, /resource name/, and /secure/ flag) MUST be\r\n   valid according to the specification of WebSocket URIs specified\r\n   in Section 3.  If any of the components are invalid, the client\r\n   MUST _Fail the WebSocket Connection_ and abort these steps.",
    "correct_text": "1. The components of the WebSocket URI passed into this algorithm\r\n   (/host/, /port/, /resource name/, and /secure/ flag) MUST be\r\n   valid according to the specification of WebSocket URIs specified\r\n   in Section 3.  If any of the components are invalid, the client\r\n   MUST _Fail the WebSocket Connection_ and abort these steps.\r\n\r\n2. If secure is false, and the algorithm in Mixed Content's \"§5.1\r\n   Does settings object restrict mixed content?\" returns Restricts\r\n   Mixed Content when applied to client's entry script's relevant\r\n   settings object's, then the client MUST fail the WebSocket\r\n   connection and abort the connection.",
    "notes": "This change is suggested by the W3C's \"Mixed Content\" document (https://w3c.github.io/webappsec/specs/mixedcontent/#websockets-integration), and will bring WebSockets' behaviors into line with XMLHttpRequest, EventSource, and Fetch, all of which act as though there was a network error when blocking a mixed content request, rather than throwing a SecurityError exception.",
    "submit_date": "2015-06-24",
    "submitter_name": "Mike West",
    "verifier_id": "130",
    "verifier_name": "Barry Leiba",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4672",
    "doc-id": "RFC6455",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "5.6",
    "orig_text": "   Data frames (e.g., non-control frames) are identified by opcodes\r\n   where the most significant bit of the opcode is 0.  Currently defined\r\n   opcodes for data frames include 0x1 (Text), 0x2 (Binary).  Opcodes\r\n   0x3-0x7 are reserved for further non-control frames yet to be\r\n   defined.\r\n\r\n   Data frames carry application-layer and/or extension-layer data.  The\r\n   opcode determines the interpretation of the data:\r\n\r\n   Text\r\n\r\n      The \"Payload data\" is text data encoded as UTF-8.  Note that a\r\n      particular text frame might include a partial UTF-8 sequence;\r\n      however, the whole message MUST contain valid UTF-8.  Invalid\r\n      UTF-8 in reassembled messages is handled as described in\r\n      Section 8.1.\r\n\r\n   Binary\r\n\r\n      The \"Payload data\" is arbitrary binary data whose interpretation\r\n      is solely up to the application layer.\r\n",
    "correct_text": "   Data frames (i.e., non-control frames) are identified by opcodes\r\n   where the most significant bit of the opcode is 0.  Currently defined\r\n   opcodes for data frames include 0x00 (Continuation), 0x1 (Text) and\r\n   0x2 (Binary).  Opcodes 0x3-0x7 are reserved for further non-control\r\n   frames yet to be defined.\r\n\r\n   Data frames carry application-layer and/or extension-layer data.  The\r\n   opcode determines the interpretation of the data:\r\n\r\n   Text\r\n\r\n      The \"Payload data\" is text data encoded as UTF-8.  Note that a\r\n      particular text frame might include a partial UTF-8 sequence;\r\n      however, the whole message MUST contain valid UTF-8.  Invalid\r\n      UTF-8 in reassembled messages is handled as described in\r\n      Section 8.1.\r\n\r\n   Binary\r\n\r\n      The \"Payload data\" is arbitrary binary data whose interpretation\r\n      is solely up to the application layer.\r\n\r\n   Continuation\r\n\r\n      These frames MUST be always preceeded by either Text or Binary\r\n      frame with FIN bit clear (See Section 5.2). The \"Payload data\"\r\n      contains next fragment (See section 5.4) of the message whose\r\n      transmission were opened by the latest Text or Binary frame and\r\n      MUST be interpreted in the same way as the initial fragment of\r\n      the message.\r\n",
    "notes": "For any other opcode defined frames are explicitly listed and described in either Section 5.5 or Section 5.6. But continuation frame is not. \r\n\r\nFormally it matches definition of data frame (given in section 5.6) as the most significant bit of its opcode is 0. Logically it should be data frame too. But it is unclear whether there are two categories of frames (data and control) or the Continuation frame represents the third.\r\n\r\nOne could guess though that Continuation frame is a data frame from the content of the section 5.5.1 stating that \"An endpoint MAY delay sending a Close frame until its current message is sent (for instance, if the majority of a fragmented message is already sent, an endpoint MAY send the remaining fragments before sending a Close frame)\". This fragment clarifies that Close frame is sent after an endpoint finished message transmission. Thus such interpreation would be consistent with the Section 5.5.1 stating that \"The application MUST NOT send any more data frames after sending a Close frame\".",
    "submit_date": "2016-04-18",
    "submitter_name": "Anton Dunaev",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4919",
    "doc-id": "RFC6455",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7.4.1",
    "orig_text": "1001 indicates that an endpoint is \"going away\", such as a server\r\n      going down or a browser having navigated away from a page.",
    "correct_text": "(unsure)",
    "notes": "This status code apparently covers two entirely different situations: a server going down, and a browser having navigated away.  What is meant by \"going away\", why can't these be 2 different status codes?  That info should be present in the RFC text.",
    "submit_date": "2017-01-28",
    "submitter_name": "Jefferson Carpenter",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5288",
    "doc-id": "RFC6455",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "5.2",
    "orig_text": "frame-payload-length-16 = %x0000-FFFF ; 16 bits in length\r\n\r\nframe-payload-length-63 = %x0000000000000000-7FFFFFFFFFFFFFFF\r\n                        ; 64 bits in length\r\n\r\nframe-masking-key       = 4( %x00-FF )\r\n                        ; present only if frame-masked is 1\r\n                        ; 32 bits in length",
    "correct_text": "frame-payload-length-16 = %x0000-FFFF ; 16 bits in length\r\n\r\nframe-payload-length-63 = %x0000000000000000-7FFFFFFFFFFFFFFF\r\n                        ; 64 bits in length\r\n\r\nframe-masking-key       = %x00000000-FFFFFFFF\r\n                        ; present only if frame-masked is 1\r\n                        ; 32 bits in length",
    "notes": "frame-masking-key is 32bits in length",
    "submit_date": "2018-03-20",
    "submitter_name": "champkeh",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5453",
    "doc-id": "RFC6455",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "4.1",
    "orig_text": "   2.  If the response lacks an |Upgrade| header field or the |Upgrade|\r\n       header field contains a value that is not an ASCII case-\r\n       insensitive match for the value \"websocket\", the client MUST\r\n       _Fail the WebSocket Connection_.",
    "correct_text": "   2.  If the response lacks an |Upgrade| header field or the |Upgrade|\r\n       header field contains a value that does not match \"WebSocket\",\r\n       the client MUST _Fail the WebSocket Connection_.",
    "notes": "HTTP upgrade tokens are case-sensitive, and the token registered by RFC 6455 is \"WebSocket\" (see <https://www.iana.org/assignments/http-upgrade-tokens/http-upgrade-tokens.xhtml>). Examples should be adjusted accordingly.\r\n\r\nIf stricter checks actually break the protocol, an alternative would be to register more variants of the token, such as \"websocket\".\n --VERIFIER NOTES-- \n   See <https://www.rfc-editor.org/errata/eid5498>. Implementations seem to be using \"websocket\", as shown in all examples in this RFC.",
    "submit_date": "2018-08-08",
    "submitter_name": "Julian Reschke",
    "verifier_id": "116",
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5498",
    "doc-id": "RFC6455",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "11.2",
    "orig_text": "   Name of token\r\n      WebSocket",
    "correct_text": "   Name of token\r\n      websocket",
    "notes": "The HTTP bootstrap request is required to use an upgrade token of all lowercase \"websocket\" - \r\n\r\n   5.   The request MUST contain an |Upgrade| header field whose value\r\n        MUST include the \"websocket\" keyword.\r\n\r\nThe registration is for \"WebSocket\" (capital W and capital S). In practice \"websocket\" is used.\r\n\r\nAlthough the interpretation of that is defined case-insensitively for this RFC (which conflicts with general HTTP semantics where this is case sensitive). As part of RFC 8441, the IANA registry has been updated to also include \"websocket\" with a reference to both RFC 6455 and RFC 8441.\r\n\r\nimo this errata should be held for update and the reference to \"WebSocket\" removed at that time.\r\n\r\nSee also https://www.rfc-editor.org/errata/eid5453",
    "submit_date": "2018-09-14",
    "submitter_name": "Patrick McManus",
    "verifier_id": "2",
    "verifier_name": "Alexey Melnikov",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "6997",
    "doc-id": "RFC6455",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "4.3, 9.1",
    "orig_text": "      extension-param = token [ \"=\" (token | quoted-string) ]\r\n           ; When using the quoted-string syntax variant, the value\r\n           ; after quoted-string unescaping MUST conform to the\r\n           ; 'token' ABNF.",
    "correct_text": "      extension-param = token [ \"=\" (token | quoted-string) ]\r\n",
    "notes": "The text reads as if any quoted-string which was supplied as a value has to follow the same rules as a token. That precludes the use of any token separators inside a quoted-string which is the whole reason why quoted-string exists as explained in RFC 2616:\r\n\r\n   Many HTTP/1.1 header field values consist of words separated by LWS\r\n   or special characters. These special characters MUST be in a quoted\r\n   string to be used within a parameter value (as defined in section\r\n   3.6).",
    "submit_date": "2022-06-17",
    "submitter_name": "Daniel Egger",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7262",
    "doc-id": "RFC6455",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "5.5.1",
    "orig_text": "Following the 2-byte integer, the body MAY contain UTF-8-encoded data\r\nwith value /reason/, the interpretation of which is not defined by\r\nthis specification.  This data is not necessarily human readable but\r\nmay be useful for debugging or passing information relevant to the\r\nscript that opened the connection.  As the data is not guaranteed to\r\nbe human readable, clients MUST NOT show it to end users.",
    "correct_text": "> Following the 2-byte integer, the body MAY contain data which MUST\r\nbe UTF-8-encoded with value /reason/, the interpretation of which is\r\nnot defined by this specification.\r\n\r\n> As the interpretation is not defined here, clients MAY show it to\r\nend users.\r\n\r\n----- OR -----\r\n\r\n> Following the 2-byte integer, the body MAY contain arbitrary data,\r\nthe interpretation of which is not defined by this specification.\r\n\r\n> As the interpretation is not defined here, clients MAY hide it\r\nfrom end users.",
    "notes": "The RFC is unclear on whether or not close-frames can contain binary data for the /reason/.\r\n\r\nIn section 5.2, \"Application data\" is defined as \"arbitrary\".\r\n\r\nSection 5.5.1 also says about the /reason/:\r\n> This data is not necessarily human readable ...\r\n> As the data is not guaranteed to be human readable ...\r\n\r\nOk, but what if it is?\r\n\r\nAs per RFC 2119, The \"MUST NOT show it to end users\" here is not a mere suggestion.\r\nIt implies some sort of inherent danger or contract breaking that would occur if the data were \"shown\" (undefined term), as if passing along UTF-8 text in a controlled manner could cause harm to their application.\r\n\r\nDue to the \"MUST NOT\", the \"MAY contain UTF-8-encoded data\" here is ambiguous. It implies it could be something other than UTF-8, like binary data, which would be unsafe to blindly \"show\" to the \"end user\" (undefined term). There is no clear reason as to why it (emphatically) \"MUST NOT\" be shown to \"end users\".\r\n\r\nWho is the client and who is the \"end user\"? This is the only occurrence of \"end user\" in the RFC. Is the \"client\" the browser, and the \"end user\" the developer trying to debug their application, but \"MUST NOT\" see close /reason/s? In practice, the close reason is of course exposed by browsers. But then is the end user the non-developer who triggers an unexpected error on the server, and has no way to report a bug since the server's error /reason/ MUST NOT be shown to them? Why MUSTN'T it be shown? Is it because it MAY contain binary data?\r\n\r\nClarification is needed on whether or not the /reason/ can contain arbitrary binary data. And the imperative restriction on what the undefined \"end user\" can be \"shown\" should be loosened.",
    "submit_date": "2022-12-09",
    "submitter_name": "Demi Y",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "7608",
    "doc-id": "RFC6455",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7.1.1",
    "orig_text": "The underlying TCP connection, in most normal cases, SHOULD be closed\r\n   first by the server, so that it holds the TIME_WAIT state and not the\r\n   client (as this would prevent it from re-opening the connection for 2\r\n   maximum segment lifetimes (2MSL), while there is no corresponding\r\n   server impact as a TIME_WAIT connection is immediately reopened upon\r\n   a new SYN with a higher seq number).  ",
    "correct_text": "The underlying TCP connection, in most normal cases, SHOULD be closed\r\n   first by the server, so that the TIME_WAIT occurs at the\r\n   client, not at the server.  ",
    "notes": "1. There is no such thing as a 'TIME_WAIT connection'.\r\n2. TCP connections are never reused.\r\n3. It is better for the TIME_WAIT *port* states to accumulate at the clients rather than at the server, as this distributes them among the client base and avoids possible resource exhaustion at the server (NB *not* port exhaustion, as the server is only using one port).\r\n4. The part about 'as this would prevent it [the client] from re-opening the connection' is only true if the client is using a fixed local port number, which never works anyway.\r\n5. The part about ' a TIME_WAIT connection is immediately reopened upon\r\n   a new SYN with a higher seq number' is nonsense.",
    "submit_date": "2023-08-19",
    "submitter_name": "Esmond Pitt",
    "verifier_id": "99",
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": "8491",
    "doc-id": "RFC6455",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "9.1",
    "orig_text": "   is exactly equivalent to\r\n\r\n         Sec-WebSocket-Extensions: foo, bar; baz=2",
    "correct_text": "   is exactly equivalent to\r\n\r\n         Sec-WebSocket-Extensions: foo; bar; baz=2",
    "notes": "Should be semicolon-separated",
    "submit_date": "2025-06-28",
    "submitter_name": "YuSheng Chen",
    "verifier_id": "2",
    "verifier_name": null,
    "update_date": "2025-07-02 09:11:09"
  }
]
