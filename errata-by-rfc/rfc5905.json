[
  {
    "errata_id": "2476",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "7.3.",
    "orig_text": "For instance, a value of -18 \r\ncorresponds to a precision of about one microsecond.",
    "correct_text": "For instance, a value of -20 \r\ncorresponds to a precision of about one microsecond.",
    "notes": "2**-20 = 0.954 usec\r\n2**-18 = 3.815 usec",
    "submit_date": "2010-08-19",
    "submitter_name": "Joerg Weilbier",
    "verifier_id": "2",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2514",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "A.5.1",
    "orig_text": "if (0) { ...",
    "correct_text": "if (unicast ...) { ...",
    "notes": "expression under if is needed, even using pseudo-code",
    "submit_date": "2010-09-08",
    "submitter_name": "Jerzy Miernik",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "2826",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "6",
    "orig_text": "[...]\r\nand a 64-bit fraction field resolving .05 attosecond (i.e., 0.5e-18).",
    "correct_text": "[...]\r\nand a 64-bit fraction field resolving .05 attosecond (i.e., 0.05e-18).",
    "notes": "\"atto\" is the prefix for 1e-18.",
    "submit_date": "2011-06-10",
    "submitter_name": "Christian Aistleitner",
    "verifier_id": "2",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3007",
    "doc-id": "RFC5905",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "7.4",
    "orig_text": "b.  For kiss code RATE, the client MUST immediately reduce its\r\n       polling interval to that server and continue to reduce it each\r\n       time it receives a RATE kiss code.",
    "correct_text": "b.  For kiss code RATE, the client MUST immediately increase its\r\n       polling interval to that server and continue to increase it each\r\n       time it receives a RATE kiss code.",
    "notes": "The client needs to poll the server for new timestamps less often",
    "submit_date": "2011-10-28",
    "submitter_name": "Danny Mayer",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3125",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "A.5.1.1",
    "orig_text": "        /*\r\n         * Calculate offset, delay and dispersion, then pass to the\r\n         * clock filter.  Note carefully the implied processing.  The\r\n         * first-order difference is done directly in 64-bit arithmetic,\r\n         * then the result is converted to floating double.  All further\r\n         * processing is in floating-double arithmetic with rounding\r\n         * done by the hardware.  This is necessary in order to avoid\r\n         * overflow and preserve precision.\r\n         *\r\n         * The delay calculation is a special case.  In cases where the\r\n         * server and client clocks are running at different rates and\r\n         * with very fast networks, the delay can appear negative.  In\r\n         * order to avoid violating the Principle of Least Astonishment,\r\n         * the delay is clamped not less than the system precision.\r\n         */\r\n        if (p->pmode == M_BCST) {\r\n                offset = LFP2D(r->xmt - r->dst);\r\n                delay = BDELAY;\r\n                disp = LOG2D(r->precision) + LOG2D(s.precision) + PHI *\r\n                    2 * BDELAY;\r\n        } else {\r\n                offset = (LFP2D(r->rec - r->org) + LFP2D(r->dst -\r\n                    r->xmt)) / 2;\r\n                delay = max(LFP2D(r->dst - r->org) - LFP2D(r->rec -\r\n                    r->xmt), LOG2D(s.precision));\r\n                disp = LOG2D(r->precision) + LOG2D(s.precision) + PHI *\r\n                    LFP2D(r->dst - r->org);\r\n        }\r\n        clock_filter(p, offset, delay, disp);\r\n",
    "correct_text": "        /*\r\n         * Calculate offset, delay and dispersion, then pass to the\r\n         * clock filter.  Note carefully the implied processing.  The\r\n         * first-order difference is done directly in 64-bit arithmetic,\r\n         * then the result is converted to floating double.  All further\r\n         * processing is in floating-double arithmetic with rounding\r\n         * done by the hardware.  This is necessary in order to avoid\r\n         * overflow and preserve precision.\r\n         *\r\n         * The delay calculation is a special case.  In cases where the\r\n         * server and client clocks are running at different rates and\r\n         * with very fast networks, the delay can appear negative.  In\r\n         * order to avoid violating the Principle of Least Astonishment,\r\n         * the delay is clamped not less than the system precision.\r\n         */\r\n        if (p->pmode == M_BCST) {\r\n                offset = LFP2D(r->xmt - r->dst);\r\n                delay = BDELAY;\r\n                disp = LOG2D(r->precision) + LOG2D(s.precision) + PHI *\r\n                    2 * BDELAY;\r\n        } else {\r\n                offset = (LFP2D(r->rec - r->org) + LFP2D(r->xmt -\r\n                    r->dst)) / 2;\r\n                delay = max(LFP2D(r->dst - r->org) - LFP2D(r->xmt -\r\n                    r->rec), LOG2D(s.precision));\r\n                disp = LOG2D(r->precision) + LOG2D(s.precision) + PHI *\r\n                    LFP2D(r->dst - r->org);\r\n        }\r\n        clock_filter(p, offset, delay, disp);\r\n",
    "notes": "Calculations of 'offset' and 'delay' have terms that are incorrectly swapped.  In the calculation of 'offset', term 'r->dst' should be 'r->xmt', and term 'r->xmt' should be 'r->dst'.  In the calculation of 'delay', term 'r->rec' should be 'r->xmt', and term 'r->xmt' should be 'r->rec'.\r\n\r\nSee the text from section 8:\r\n\r\n   \"In the figure, the first packet transmitted by A contains only the\r\n   origin timestamp t1, which is then copied to T1.  B receives the\r\n   packet at t2 and copies t1 to T1 and the receive timestamp t2 to T2.\r\n   At this time or some time later at t3, B sends a packet to A\r\n   containing t1 and t2 and the transmit timestamp t3.  All three\r\n   timestamps are copied to the corresponding state variables.  A\r\n   receives the packet at t4 containing the three timestamps t1, t2, and\r\n   t3 and the destination timestamp t4.  These four timestamps are used\r\n   to compute the offset and delay of B relative to A, as described\r\n   below.\r\n\r\n...\r\n\r\n   \"The four most recent timestamps, T1 through T4, are used to compute\r\n   the offset of B relative to A\r\n\r\n   theta = T(B) - T(A) = 1/2 * [(T2-T1) + (T3-T4)]\r\n\r\n   and the round-trip delay\r\n\r\n   delta = T(ABA) = (T4-T1) - (T3-T2).\"\r\n\r\nNoting that, from the perspective of A at time t4:\r\n\r\nT1 = t1 = origin timestamp (r->org)\r\nT2 = t2 = receive timestamp (r->rec)\r\nT3 = t3 = transmit timestamp (r->xmt)\r\nT4 = t4 = destination timestamp (r->dst)\r\n\r\nAn alternative correction would be to change the '+' to a '-' in the calculation of 'offset', and change the '-' to a '+' in the calculation of 'delay'.  However, this would deviate from the operators used in the formulas from section 8.",
    "submit_date": "2012-02-16",
    "submitter_name": "Richard Walters",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3126",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "3",
    "orig_text": "          +-------------------+-------------------+------------------+\r\n          |  Association Mode | Assoc. Mode Value | Packet Mode Value|\r\n          +-------------------+-------------------+------------------+\r\n          | Symmetric Active  |         1         | 1 or 2           |\r\n          | Symmetric Passive |         2         | 1                |\r\n          | Client            |         3         | 4                |\r\n          | Server            |         4         | 3                |\r\n          | Broadcast Server  |         5         | 5                |\r\n          | Broadcast Client  |         6         | N/A              |\r\n          +-------------------+-------------------+------------------+\r\n\r\n                  Figure 1: Association and Packet Modes\r\n\r\n   In the client/server variant, a persistent client sends packet mode 4\r\n   packets to a server, which returns packet mode 3 packets.\r\n",
    "correct_text": "          +-------------------+-------------------+------------------+\r\n          |  Association Mode | Assoc. Mode Value | Packet Mode Value|\r\n          +-------------------+-------------------+------------------+\r\n          | Symmetric Active  |         1         | 1 or 2           |\r\n          | Symmetric Passive |         2         | 1                |\r\n          | Client            |         3         | 4                |\r\n          | Server            |         4         | 3                |\r\n          | Broadcast Server  |         5         | N/A              |\r\n          | Broadcast Client  |         6         | 5                |\r\n          +-------------------+-------------------+------------------+\r\n\r\n                  Figure 1: Association and Packet Modes\r\n\r\n   In the client/server variant, a persistent client sends packet mode 3\r\n   packets to a server, which returns packet mode 4 packets.",
    "notes": "The majority of the rows in Figure 1 are correct if the 'Packet Mode Value' refers to the mode of packets which are expected to be received by an NTP speaker which has mobilized an association with the corresponding 'Association Mode'.  Assuming this is the case, the last two rows are incorrect:\r\n\r\n* A peer with a mobilized 'Broadcast Server' mode association is not expected to receive any packets at all for this association -- a broadcast server does not receive anything back (see 'Broadcast' mode row in Section 9.2, Figure 20, where each column in that row is 'DSCRD'.)  Therefore, the value of 'Packet Mode Value' for 'Broadcast Server' should be 'N/A', not '5'.\r\n\r\n* A peer with a mobilized 'Broadcast Client' mode association is expected to receive packets with a 'Packet Mode Value' of 5 for this association (see 'Bcast Client' mode row in Section 9.2, Figure 20, where each column in that row is 'DSCRD' except for the '5' column, which is 'PROC'.)  Therefore, the value of 'Packet Mode Value' for 'Broadcast Client' should be '5', not 'N/A'.\r\n\r\nIt might help the clarity of Figure 1 if the row labeled 'Packet Mode Value' were to be changed to 'Receive Packet Mode Value(s)'.\r\n\r\nThe text immediately following Figure 1 also has the packet mode values swapped.  As made clear throughout the RFC (for example, see Section 9.2 where is says, \"FXMIT.  This indicates a client (mode 3) packet matching no association (mode 0).  If the destination address is not a broadcast address, the server constructs a server (mode 4) packet and returns it to the client without retaining state.\"), clients send servers packet mode 3 packets, not packet mode 4 packets; it is servers which send clients packet mode 4 packets, not packet mode 3 packets.\r\n\r\nJust to make it perfectly clear, here are the modes of packets sent:\r\n\r\n* Time t0: client mobilizes 'Client' mode association for server (via configuration, or due to reception of manycast server packet)\r\n* Time t1: client transmits mode 3 packet to server (e.g. via poll(p) => peer_xmit(p) when c.t >= p->nextdate)\r\n* Time t2: server receives mode 3 packet from client (dispatch: FXMIT; no association found or mobilized)\r\n* Time t3: server transmits mode 4 packet to client\r\n* Time t4: client receives mode 4 packet from server (matches previously mobilized association -- dispatch: PROC)",
    "submit_date": "2012-02-16",
    "submitter_name": "Richard Walters",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3127",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "A.5.5.1",
    "orig_text": "                /*\r\n                 * Scan the chime list from lowest to highest to find\r\n                 * the lower endpoint.\r\n                 */\r\n                found = 0;\r\n                chime = 0;\r\n                for (i = 0; i < n; i++) {\r\n                        chime -= s.m[i].type;\r\n                        if (chime >= n - found) {\r\n                                low = s.m[i].edge;\r\n                                break;\r\n                        }\r\n                        if (s.m[i].type == 0)\r\n                                found++;\r\n                }\r\n\r\n                /*\r\n                 * Scan the chime list from highest to lowest to find\r\n                 * the upper endpoint.\r\n                 */\r\n                chime = 0;\r\n                for (i = n - 1; i >= 0; i--) {\r\n                        chime += s.m[i].type;\r\n                        if (chime >= n - found) {\r\n                                high = s.m[i].edge;\r\n                                break;\r\n                        }\r\n                        if (s.m[i].type == 0)\r\n                                found++;\r\n                }\r\n",
    "correct_text": "                /*\r\n                 * Scan the chime list from lowest to highest to find\r\n                 * the lower endpoint.\r\n                 */\r\n                found = 0;\r\n                chime = 0;\r\n                for (i = 0; i < n; i++) {\r\n                        chime -= s.m[i].type;\r\n                        if (chime >= n - allow) {\r\n                                low = s.m[i].edge;\r\n                                break;\r\n                        }\r\n                        if (s.m[i].type == 0)\r\n                                found++;\r\n                }\r\n\r\n                /*\r\n                 * Scan the chime list from highest to lowest to find\r\n                 * the upper endpoint.\r\n                 */\r\n                chime = 0;\r\n                for (i = n - 1; i >= 0; i--) {\r\n                        chime += s.m[i].type;\r\n                        if (chime >= n - allow) {\r\n                                high = s.m[i].edge;\r\n                                break;\r\n                        }\r\n                        if (s.m[i].type == 0)\r\n                                found++;\r\n                }\r\n",
    "notes": "In both scans (lowest to highest, and highest to lowest)\r\n\r\nchime >= n - found\r\n\r\nneeds to be:\r\n\r\nchime >= n - allow",
    "submit_date": "2012-02-17",
    "submitter_name": "Richard Walters",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3132",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "11.2.1",
    "orig_text": "   First, those servers that are unusable according to the rules of the\r\n   protocol are detected and discarded as shown by the accept() routine\r\n   in Appendix A.5.5.3.",
    "correct_text": "   First, those servers that are unusable according to the rules of the\r\n   protocol are detected and discarded as shown by the fit() routine\r\n   in Appendix A.5.2.",
    "notes": "The fit() and accept() routines are identical.  Since accept() is not called from, nor mentioned anywhere else, whereas fit() is called from two places and listed in the function prototypes, just drop accept() and use fit() instead in section 11.2.1.",
    "submit_date": "2012-02-21",
    "submitter_name": "Richard Walters",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3404",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "A.1.1.",
    "orig_text": "#define SQUARE(x)       (x * x)\r\n",
    "correct_text": "#define SQUARE(x)       ((x) * (x))\r\n",
    "notes": "This macro is used in the example code to square differences:\r\n\r\n//- in clock_filter() {...} (page 85) :\r\n\r\n                p->jitter += SQUARE(f[i].offset - f[0].offset);\r\n\r\n//- in clock_select() { ... } (page 92) :\r\n\r\n                                dtemp += SQUARE(p->offset - q->offset);\r\n\r\n//- in clock_combine() { ... } (page 96) :\r\n\r\n                w += SQUARE(p->offset - s.v[0].p->offset) / x;\r\n\r\n//- in local_clock() { ... } (page 99) :\r\n\r\n                dtemp = SQUARE(max(fabs(offset - c.last),\r\n                    LOG2D(s.precision)));\r\n\r\n\r\nThese expressions are using differences of double values: the .offset member in a Filter stage structure (f), and the .jitter member in an Association structure (p), or in a Local clock structure (c), or in a System structure (s).\r\n\r\nAll these occurences of macro substitions of SQUARE() will be wrong if the C macro does not surrounds its parameter expression by adding parentheses around them !\r\n\r\nThis is a very classic error made by beginners in C programming using \"utility\" macros with side effects... At least newer programmers avoid these kind of macros and prefer defining inline functions",
    "submit_date": "2012-11-08",
    "submitter_name": "Philippe Verdy",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3608",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "A.2.",
    "orig_text": "/*\r\n         * Read command line options and initialize system variables.\r\n         * The reference implementation measures the precision specific\r\n         * to each machine by measuring the clock increments to read the\r\n         * system clock.\r\n         */\r\n        memset(&s, sizeof(s), 0);\r\n\r\n.....\r\n/*\r\n         * Initialize local clock variables\r\n         */\r\n        memset(&c, sizeof(c), 0);",
    "correct_text": "/*\r\n         * Read command line options and initialize system variables.\r\n         * The reference implementation measures the precision specific\r\n         * to each machine by measuring the clock increments to read the\r\n         * system clock.\r\n         */\r\n        memset(&s, 0. sizeof(s));\r\n...\r\n\r\n/*\r\n         * Initialize local clock variables\r\n         */\r\n        memset(&c, 0, sizeof(c));",
    "notes": "Paramters 2 and 3 of the memset functions are inverted everywhere in the example code, not just in section A2",
    "submit_date": "2013-04-29",
    "submitter_name": "Cristian Rodríguez",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3613",
    "doc-id": "RFC5905",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "8",
    "orig_text": null,
    "correct_text": null,
    "notes": "In the paragraph explaining the sanity checks on received packets, it states: \"In the exchange above, a packet is duplicate or replay if the transmit timestamp t3 in the packet matches the org state variable T3.\"  But in the pseudo-code in A.5.1 it states\r\n        /*\r\n         * If the transmit timestamp duplicates a previous one, the\r\n         * packet is a replay.\r\n         */\r\n        if (r->xmt == p->xmt)\r\ni.e. comparing the transmit timestamp p->xmt with the xmt state variable T1.  Which is correct?\r\n\r\nSimilarly for the check for a bogus packet, Section 8 states: \"A packet is bogus if the origin timestamp t1 in the packet does not match the xmt state variable T1.  But the pseudo-code says:\r\n        /*\r\n         * If this is a broadcast mode packet, skip further checking.\r\n         * If the origin timestamp is zero, the sender has not yet heard\r\n         * from us.  Otherwise, if the origin timestamp does not match\r\n         * the transmit timestamp, the packet is bogus.\r\n         */\r\n        synch = TRUE;\r\n        if (r->mode != M_BCST) {\r\n                if (r->org == 0)\r\n                        synch = FALSE;  /* unsynchronized */\r\n\r\n                else if (r->org != p->xmt)\r\n                        synch = FALSE;  /* bogus packet */\r\n        }\r\ni.e. it is comparing the transmit timestamp t3 in the packet with the org state variable T3.\r\n\r\nWhich is correct?  Looking at Figure 15 my guess would be Section 8 is correct but I have seen code that more closely follows the pseudo-code.\n --VERIFIER NOTES-- \nThe Introduction of the document clearly states that the pseudo-code in the appendix is non-normative.  Therefore the text in the main body of the specification describes the conformant behavior:\r\n\r\n\"The contents of Appendix A are non-normative examples designed to illustrate the protocol's operation and are not a requirement for a conforming implementation.\"",
    "submit_date": "2013-05-06",
    "submitter_name": "Tony O'Brien",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "3627",
    "doc-id": "RFC5905",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "7.5",
    "orig_text": "In NTPv4, one or more extension fields can be inserted after the \r\nheader and before the MAC, which is always present when an extension \r\nfield is present.",
    "correct_text": "In NTPv4, one or more extension fields can be inserted after the \r\nheader and before the MAC, if a MAC is present. If a MAC is not \r\npresent, one or more extension fields can be inserted after the \r\nheader, according to the following rules:\r\no If the packet includes a single extension field, the length of the \r\n  extension  field MUST be at least 7 words, i.e., at least 28 octets.\r\no If the packet includes more than one extension field, the length of \r\n  the last extension field MUST be at least 28 octets. The length of \r\n  the other extension fields in this case MUST be at least 16 octets \r\n  each.\r\n",
    "notes": "The usage of NTP extension fields without authentication is aligned with Section 10 of RFC 5906:\r\n\r\nThe extension field parser initializes a pointer to the first octet beyond the NTP packet header and calculates the number of octets remaining to the end of the packet If the remaining length is 20 (128-bit digest plus 4-octet key ID) or 22 (160-bit digest plus 4-octet key ID), the remaining data are the MAC and parsing is complete.  If the remaining length is greater than 22, an extension field is present.  If the remaining length is less than 8 or not a multiple of 4, a format error has occurred and the packet is discarded; otherwise, the parser increments the pointer by the extension field length and then uses the same rules as above to determine whether a MAC is present or another extension field.",
    "submit_date": "2013-05-17",
    "submitter_name": "Tal Mizrahi",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4019",
    "doc-id": "RFC5905",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "11.2.1",
    "orig_text": "   An\r\n   example of this calculation is shown by the rootdist() routine in\r\n   Appendix A.5.1.1.\r\n",
    "correct_text": "   An\r\n   example of this calculation is shown by the root_dist() routine in\r\n   Appendix A.5.5.2.\r\n",
    "notes": "No rootdist() routine is in Appendix.  root_dist() appears in Appendix A.5.5.2.",
    "submit_date": "2014-06-20",
    "submitter_name": "Teruaki Kitasuka",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4025",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "6",
    "orig_text": "-678,491",
    "correct_text": "-678,941",
    "notes": "In Figure 4, the MJD of 1 Jan 0 has a typo.\r\n\r\nThere are 365 (not 815) days from 1 Jan -1 to 1 Jan 0, and 366 (not -84) from 1 Jan 0 to 1 Jan 1. I took NTP Timestamp Era Offset as a reference for the number of days in these years.",
    "submit_date": "2014-06-25",
    "submitter_name": "Julien Cretin",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4121",
    "doc-id": "RFC5905",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "8",
    "orig_text": "In the exchange above, a packet is duplicate or\r\n   replay if the transmit timestamp t3 in the packet matches the org\r\n   state variable T3. ",
    "correct_text": "In the exchange above, a packet is duplicate or\r\n   replay if the transmit timestamp t3 in the packet matches the org\r\n   state variable. ",
    "notes": "The org state variable for peer A has not yet been assigned the value T3.",
    "submit_date": "2014-09-23",
    "submitter_name": "Marina Gertsvolf",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4263",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "7.3, Fig 8",
    "orig_text": "       0                   1                   2                   3\r\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n      |LI | VN  |Mode |    Stratum     |     Poll      |  Precision   |\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
    "correct_text": "       0                   1                   2                   3\r\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n      |LI | VN  |Mode |    Stratum    |     Poll      |  Precision    |\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
    "notes": "The field boundaries are not aligned with the bit boundaries in \"Figure 8: Packet Header Format\".",
    "submit_date": "2015-02-05",
    "submitter_name": "Priyesh Patel",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4366",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "11.2.1",
    "orig_text": "5.  Is d = f and l < u?  If yes, then follow step 5A; else, follow\r\n   step 5B.\r\n",
    "correct_text": "5.  Is d <= f and l < u?  If yes, then follow step 5A; else, follow\r\n   step 5B.\r\n",
    "notes": "Original text doesn't correspond to sample implementation at A.5.5.1. And, I suppose, described algorithm may throw out reasonable set of measures.",
    "submit_date": "2015-05-13",
    "submitter_name": "Vyacheslav",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4504",
    "doc-id": "RFC5905",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "7.3",
    "orig_text": "   LI Leap Indicator (leap): 2-bit integer warning of an impending leap\r\n   second to be inserted or deleted in the last minute of the current\r\n   month with values defined in Figure 9.\r\n\r\n           +-------+----------------------------------------+\r\n           | Value | Meaning                                |\r\n           +-------+----------------------------------------+\r\n           | 0     | no warning                             |\r\n           | 1     | last minute of the day has 61 seconds  |\r\n           | 2     | last minute of the day has 59 seconds  |\r\n",
    "correct_text": "   LI Leap Indicator (leap): 2-bit integer warning of an impending leap\r\n   second to be inserted or deleted in the last minute of the current\r\n   day with values defined in Figure 9.\r\n\r\n           +-------+----------------------------------------+\r\n           | Value | Meaning                                |\r\n           +-------+----------------------------------------+\r\n           | 0     | no warning                             |\r\n           | 1     | last minute of the day has 61 seconds  |\r\n           | 2     | last minute of the day has 59 seconds  |\r\n",
    "notes": "There is an inconsistency (day vs month) between the LI description and the description of values in the Figure 9.  Few paragraphs before that text there is: Except for a minor variation when using the IPv6 address family, these fields are backwards compatible with NTPv3.\r\n\r\nIf it was month instead of day it would not be compatible with RFC 1305 (NTPv3) and RFC 4330 (SNTPv4), which were obsoleted by RFC 5905.",
    "submit_date": "2015-10-15",
    "submitter_name": "Miroslav Lichvar",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2022-07-27 08:02:31"
  },
  {
    "errata_id": "4505",
    "doc-id": "RFC5905",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "A.5.1",
    "orig_text": "        /*\r\n         * Update the origin and destination timestamps.  If\r\n         * unsynchronized or bogus, abandon ship.\r\n         */\r\n        p->org = r->xmt;\r\n        p->rec = r->dst;\r\n        if (!synch)\r\n                return;                 /* unsynch */\r\n\r\n        /*\r\n         * The timestamps are valid and the receive packet matches the\r\n         * last one sent.  If the packet is a crypto-NAK, the server\r\n         * might have just changed keys.  We demobilize the association\r\n         * and wait for better times.\r\n         */\r\n        if (auth == A_CRYPTO) {\r\n                clear(p, X_CRYPTO);\r\n                return;                 /* crypto-NAK */\r\n        }\r\n\r\n        /*\r\n         * If the association is authenticated, the key ID is nonzero\r\n         * and received packets must be authenticated.  This is designed\r\n         * to avoid a bait-and-switch attack, which was possible in past\r\n         * versions.\r\n         */\r\n        if (!AUTH(p->keyid || (p->flags & P_NOTRUST), auth))\r\n                return;                 /* bad auth */\r\n",
    "correct_text": "        /*\r\n         * If the packet is a valid crypto-NAK, the server might have\r\n         * just changed keys.  We demobilize the association and wait\r\n         * for better times.\r\n         */\r\n        if (synch && auth == A_CRYPTO) {\r\n                clear(p, X_CRYPTO);\r\n                return;                 /* crypto-NAK */\r\n        }\r\n\r\n        /*\r\n         * If the association is authenticated, the key ID is nonzero\r\n         * and received packets must be authenticated.  This is designed\r\n         * to avoid a bait-and-switch attack, which was possible in past\r\n         * versions.\r\n         */\r\n        if (!AUTH(p->keyid || (p->flags & P_NOTRUST), auth))\r\n                return;                 /* bad auth */\r\n\r\n        /*\r\n         * Update the origin and destination timestamps.  If\r\n         * unsynchronized or bogus, abandon ship.\r\n         */\r\n        p->org = r->xmt;\r\n        p->rec = r->dst;\r\n        if (!synch)\r\n                return;                 /* unsynch */\r\n",
    "notes": "The state variables must be updated after the authentication is checked in order to prevent DoS attacks on authenticated symmetric associations (CVE-2015-1799).\n --VERIFIER NOTES-- \n   The appendix is not the normative description of the protocol behavior. A change such as this needs consensus within the working group. To do that, a draft should be submitted with the proposed changes.",
    "submit_date": "2015-10-15",
    "submitter_name": "Miroslav Lichvar",
    "verifier_id": "131",
    "verifier_name": "Brian Haberman",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "4680",
    "doc-id": "RFC5905",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "6, Fig 3",
    "orig_text": "       0                   1                   2                   3\r\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n      |                           Era Number                          |\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n      |                           Era Offset                          |\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n      |                                                               |\r\n      |                           Fraction                            |\r\n      |                                                               |\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n\r\n                              NTP Date Format",
    "correct_text": "       0                   1                   2                   3\r\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n      |                           Era Number                          |\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n      |                           Era Offset                          |\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n      |                                                               |\r\n      +                           Fraction                            +\r\n      |                                                               |\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n\r\n                              NTP Date Format",
    "notes": "This allows to better appreciate only two 32b rows really form the Fraction part, leading to an overall type length of 128b instead of 160b as it could otherwise be misunderstood in the original figure.\r\n\r\n---\r\n\r\nThe \"+\" vs \"|\" on the Fraction line would seem to improve consistency with packet layouts in other documents.",
    "submit_date": "2016-04-29",
    "submitter_name": "Riccardo Brama",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2022-07-27 08:13:09"
  },
  {
    "errata_id": "5020",
    "doc-id": "RFC5905",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "8",
    "orig_text": "theta = T(B) - T(A) = 1/2 * [(T2-T1) + (T3-T4)]",
    "correct_text": "theta = T(B) - T(A) = 1/2 * [(T2-T1) + (T4-T3)]",
    "notes": "The corresponding code line in A.5.1.1. agrees with this correction:\r\n\r\noffset = (LFP2D(r->rec - r->org) + LFP2D(r->dst - r->xmt)) / 2;\r\n\r\ntaking Figure 7 into account:\r\n\r\n| org       | T1         | origin timestamp      |\r\n| rec       | T2         | receive timestamp     |\r\n| xmt       | T3         | transmit timestamp    |\r\n| dst       | T4         | destination timestamp |\n --VERIFIER NOTES-- \nAs noted this thread:\r\n\r\n    https://mailarchive.ietf.org/arch/msg/ntp/AR7k0IP2PMgXdq2bknx6Eiz4upE/\r\n\r\n'''\r\nTheta is \"the offset of B relative to A\". The proposed revision is\r\n\r\n   1/2 * [(T2-T1) + (T4-T3)]\r\n\r\nExample: Let's assume that B and A are exactly synced to UTC and that the\r\nnetwork delay is 50msec in each direction.\r\n\r\n    T2-T1 is the NTP mode 3 request delay (including network delay).\r\n\r\nThis gives 50 msec\r\n    T4-T3 is the NTP mode 4 response delay (including network delay).\r\n\r\nThis gives 50 msec.\r\n\r\nThe proposed revision gives 100msec/2 = RTT/2, not the expected offset of\r\nzero.\r\n\r\nThe RFC5905 formula seems correct.\r\n\r\n    theta = T(B) - T(A) = 1/2 * [(T2-T1) + (T3-T4)]\r\n\r\nbut might have been clearer had it been written:\r\n\r\n    theta = T(B) - T(A) = 1/2 * [(T2-T1) - (T4-T3)]\r\n'''",
    "submit_date": "2017-05-15",
    "submitter_name": "Ferenc Wágner",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2022-08-29 15:39:08"
  },
  {
    "errata_id": "5104",
    "doc-id": "RFC5905",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "7.3, Fig 8",
    "orig_text": "      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n      |                          Key Identifier                       |\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n      |                                                               |\r\n      |                            dgst (128)                         |\r\n      |                                                               |\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n",
    "correct_text": "      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n      |                          Key Identifier                       |\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n      |                                                               |\r\n      |                       Message Digest (128)                    |\r\n      |                                                               |\r\n      |                                                               |\r\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n",
    "notes": "As the text before the figure explains, the last field is called \"Message Digest\", which is consistent with the rest of the document. In this document \"dgst\" and \"mac\" mean two protocol variables associated with this packet field.\r\n\r\n---\r\n\r\nNote: edited to clarify 4 32bit words, rather than 3 rows.",
    "submit_date": "2017-08-30",
    "submitter_name": "Denis Ovsienko",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2022-07-27 08:17:40"
  },
  {
    "errata_id": "5189",
    "doc-id": "RFC5905",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "6",
    "orig_text": "   | 31 Dec 1999 | 51,543     | 0   | 3,155,587,200 | Last day 20th    |\r\n   |             |            |     |               | Century          |\r\n",
    "correct_text": "   | 31 Dec 2000 | 51,909     | 0   | 3,187,209,600 | Last day 20th    |\r\n   |             |            |     |               | Century          |\r\n",
    "notes": "20th Century was from 1901 to 2000.\r\n\r\n---\r\n\r\n[verifier notes]\r\n\r\nSee also: https://mailarchive.ietf.org/arch/msg/ntp/Cbg3sOhChyfenYoj7UG5wCymFMU/",
    "submit_date": "2017-11-28",
    "submitter_name": "Marcel Telka",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2022-09-25 17:16:18"
  },
  {
    "errata_id": "5600",
    "doc-id": "RFC5905",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "10.",
    "orig_text": "   Let the first stage offset in the sorted list be theta_0; then, for\r\n   the other stages in any order, the jitter is the RMS average\r\n\r\n                          +-----                 -----+^1/2\r\n                          |  n-1                      |\r\n                          |  ---                      |\r\n                  1       |  \\                     2  |\r\n      psi   =  -------- * |  /    (theta_0-theta_j)   |\r\n                (n-1)     |  ---                      |\r\n                          |  j=1                      |\r\n                          +-----                 -----+",
    "correct_text": "   Let the first stage offset in the sorted list be theta_0; then, for\r\n   the other stages in any order, the jitter is the RMS average\r\n\r\n               +-----                             -----+^1/2\r\n               |              n-1                      |\r\n               |              ---                      |\r\n               |    1         \\                     2  |\r\n      psi   =  | -------- *   /    (theta_0-theta_j)   |\r\n               |  (n-1)       ---                      |\r\n               |              j=1                      |\r\n               +-----                             -----+",
    "notes": "The formula to calculate jitter \"psi\" in section \"10.  Clock Filter Algorithm\" is incorrect, and also inconsistent with the formulate to calculate \"psi_s\" in section \"11.2.2.  Cluster Algorithm\".\r\n\r\n\"psi\" is defined as RMS average, so the term 1/(n-1) should be within [ ]^1/2 block.",
    "submit_date": "2019-01-15",
    "submitter_name": "Takashi Nakamoto",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2022-08-29 16:26:05"
  },
  {
    "errata_id": "5601",
    "doc-id": "RFC5905",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "11.2.3.",
    "orig_text": "                  | s.rootdisp  <-- p.epsilon_r + p.epsilon + |\r\n                  |                 p.psi + PHI * (s.t - p.t) |\r\n                  |                 + |THETA|                 |\r\n                  | s.refid     <-- p.refid                   |\r\n                  | s.reftime   <-- p.reftime                 |\r\n                  | s.t         <-- p.t                       |\r\n                  +-------------------------------------------+\r\n\r\n                    Figure 25: System Variables Update\r\n\r\n   There is an important detail not shown.  The dispersion increment\r\n   (p.epsilon + p.psi + PHI * (s.t - p.t) + |THETA|) is bounded from\r\n   below by MINDISP.",
    "correct_text": "                  | s.rootdisp  <-- p.epsilon_r + p.epsilon + |\r\n                  |                 p.psi + PHI * (t_s - p.t) |\r\n                  |                 + |THETA|                 |\r\n                  | s.refid     <-- p.refid                   |\r\n                  | s.reftime   <-- p.reftime                 |\r\n                  | s.t         <-- p.t                       |\r\n                  +-------------------------------------------+\r\n\r\n                    Figure 25: System Variables Update\r\n\r\n   where t_s is the time when the system variables are updated.\r\n   There is an important detail not shown.  The dispersion increment\r\n   (p.epsilon + p.psi + PHI * (t_s - p.t) + |THETA|) is bounded from\r\n   below by MINDISP.",
    "notes": "In the same section, it is said that \"By rule, an update is discarded if its time of arrival p.t is not strictly later than the last update used s.t.\" This means that p.t > s.t when the system variable is updated. Hence, (s.t - p.t) is negative. It may lead to a negative dispersion, but, by definition, the dispersion cannot be negative. So, the original formula should be wrong.\r\n\r\nBecause the dispersion is defined as the value that grows at constant rate PHI, s.rootdisp should be\r\n\r\n  s.rootdisp <-- p.epsilon_r + p.epsilon + p.psi + PHI * (t_s - p.t) + |THETA|\r\n\r\nwhere t_s is the time when the system variables are updated. The symbol t_s is arbitrary because it is not defined in other places.\r\n\r\n---\r\n\r\n[verifier notes]\r\n\r\nFrom https://mailarchive.ietf.org/arch/msg/ntp/CHcBo-my1WdRg5PbhSU8aFlIS_k/ :\r\n\r\n\"\"\"\r\n... the reported section with is indeed erroneous, and s.t\r\nshould be replaced with c.t, defined in section 9.1/12. The attached\r\nnote seems inaccurate in the statement that a new name (t_s) is\r\nneeded, since c.t covers the required concept...\r\n\"\"\"\r\n",
    "submit_date": "2019-01-15",
    "submitter_name": "Takashi Nakamoto",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2022-09-25 17:11:45"
  },
  {
    "errata_id": "5604",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "11.2.3.",
    "orig_text": "                  | s.rootdisp  <-- p.epsilon_r + p.epsilon + |\r\n                  |                 p.psi + PHI * (s.t - p.t) |\r\n                  |                 + |THETA|                 |",
    "correct_text": "                  | s.rootdisp  <-- p.epsilon_r + p.epsilon   |\r\n                  |                 + 5 * p.psi +             |\r\n                  |                 + PHI * (s.t - p.t)       |\r\n                  |                 + |THETA|                 |\r\n",
    "notes": "In addition to the correction proposed in Errata ID 5601, I think that the formula to calculate the dispersion should be revised. The term \"p.psi\" should be multiplied by not one, but a larger value.\r\n\r\nThis is because the dispersion is defined as the statistics that represent the maximum error, so when it is calculated, it should take into account the maximum errors in the offset estimation. However, the jitter p.psi is defined as the RMS average of the offset values theta_j relative to theta_0, so the term \"p.psi\" does not represent the maximum error caused by the distribution of the offset values.\r\n\r\nIf we assume that the offset value follows the uniform distribution, the error bound is represented as sqrt(3) * p.psi. So, at least, the term \"p.psi\" should be multiplied by sqrt(3). There is arbitrarity in choice of the distribution type, so depending on the distribution type the factor may change. For example, if the normal distribution is assumed, 5 * p.psi gives us 99.99994% confidence. Assuming that the system variable is updated every 16 seconds, the actual offset may be outside the range [theta_0 - 5 * p.psi, theta_0 + 5 * p.psi] approximately once a year. It should be sufficient for usual Internet applications, though someone may think that the factor \"5\" may not be sufficient depending on the application.\r\n\r\n---\r\n\r\n[INT AD notes]\r\n\r\nSee also https://mailarchive.ietf.org/arch/msg/ntp/Cbg3sOhChyfenYoj7UG5wCymFMU/ :\r\n\r\n\"\"\"\r\n...That makes some sense to me, but I'd say it really depends on the model of the clock and that's arbitrary...\r\n\"\"\"\r\n",
    "submit_date": "2019-01-15",
    "submitter_name": "Takashi Nakamoto",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2022-09-25 17:23:59"
  },
  {
    "errata_id": "5978",
    "doc-id": "RFC5905",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "A.5.1.1.",
    "orig_text": "    /*\r\n        * Verify valid root distance.\r\n        */\r\n    if (r->rootdelay / 2 + r->rootdisp >= MAXDISP || p->reftime >\r\n        r->xmt)\r\n            return;                 /* invalid header values */\r\n",
    "correct_text": "    /*\r\n        * Verify valid root distance.\r\n        */\r\n    if (p->rootdelay / 2 + p->rootdisp >= MAXDISP || p->reftime >\r\n        r->xmt)\r\n            return;                 /* invalid header values */\r\n",
    "notes": "The r->rootdelay and r->rootdisp are the received values not in double format and therefore, should not be compared against MAXDISP. Use the p->rootdelay and p->rootdisp instead which have already been converted to double via FP2D macro.\r\n\r\n---\r\n\r\n[verifier notes]\r\n\r\nSee also https://mailarchive.ietf.org/arch/msg/ntp/Cbg3sOhChyfenYoj7UG5wCymFMU/",
    "submit_date": "2020-02-08",
    "submitter_name": "David Verbree",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2022-09-25 17:13:57"
  },
  {
    "errata_id": "6207",
    "doc-id": "RFC5905",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "A.5.5.1",
    "orig_text": "/*\r\n         * Find the largest contiguous intersection of correctness\r\n         * intervals.  Allow is the number of allowed falsetickers;\r\n         * found is the number of midpoints.  Note that the edge values\r\n         * are limited to the range +-(2 ^ 30) < +-2e9 by the timestamp\r\n         * calculations.\r\n         */\r\n        low = 2e9; high = -2e9;\r\n        for (allow = 0; 2 * allow < n; allow++) {\r\n\r\n                /*\r\n                 * Scan the chime list from lowest to highest to find\r\n                 * the lower endpoint.\r\n                 */\r\n                found = 0;\r\n                chime = 0;\r\n                for (i = 0; i < n; i++) {\r\n                        chime -= s.m[i].type;\r\n                        if (chime >= n - found) {\r\n                                low = s.m[i].edge;\r\n                                break;\r\n                        }\r\n                        if (s.m[i].type == 0)\r\n                                found++;\r\n                }\r\n\r\n                /*\r\n                 * Scan the chime list from highest to lowest to find\r\n                 * the upper endpoint.\r\n                 */\r\n                chime = 0;\r\n                for (i = n - 1; i >= 0; i--) {\r\n                        chime += s.m[i].type;\r\n                        if (chime >= n - found) {\r\n                                high = s.m[i].edge;\r\n                                break;\r\n                        }\r\n                        if (s.m[i].type == 0)\r\n                                found++;\r\n                }\r\n\r\n\r\n\r\n\r\nMills, et al.                Standards Track                   [Page 91]\r\n \r\nRFC 5905                   NTPv4 Specification                 June 2010\r\n\r\n\r\n                /*\r\n                 * If the number of midpoints is greater than the number\r\n                 * of allowed falsetickers, the intersection contains at\r\n                 * least one truechimer with no midpoint.  If so,\r\n                 * increment the number of allowed falsetickers and go\r\n                 * around again.  If not and the intersection is\r\n                 * non-empty, declare success.\r\n                 */\r\n                if (found > allow)\r\n                        continue;\r\n\r\n                if (high > low)\r\n                        break;\r\n        }",
    "correct_text": "/*\r\n         * Find the largest contiguous intersection of correctness\r\n         * intervals.  Allow is the number of allowed falsetickers;\r\n         * found is the number of midpoints.  Note that the edge values\r\n         * are limited to the range +-(2 ^ 30) < +-2e9 by the timestamp\r\n         * calculations.\r\n         */\r\n        low = 2e9; high = -2e9;\r\n        for (allow = 0; 2 * allow < n; allow++) {\r\n\r\n                /*\r\n                 * Scan the chime list from lowest to highest to find\r\n                 * the lower endpoint.\r\n                 */\r\n                found = 0;\r\n                chime = 0;\r\n                for (i = 0; i < n; i++) {\r\n                        chime -= s.m[i].type;\r\n                        if (chime >= n - allow) {\r\n                                low = s.m[i].edge;\r\n                                break;\r\n                        }\r\n                        if (s.m[i].type == 0)\r\n                                found++;\r\n                }\r\n\r\n                /*\r\n                 * Scan the chime list from highest to lowest to find\r\n                 * the upper endpoint.\r\n                 */\r\n                chime = 0;\r\n                for (i = n - 1; i >= 0; i--) {\r\n                        chime += s.m[i].type;\r\n                        if (chime >= n - allow) {\r\n                                high = s.m[i].edge;\r\n                                break;\r\n                        }\r\n                        if (s.m[i].type == 0)\r\n                                found++;\r\n                }\r\n\r\n\r\n\r\n\r\nMills, et al.                Standards Track                   [Page 91]\r\n \r\nRFC 5905                   NTPv4 Specification                 June 2010\r\n\r\n\r\n                /*\r\n                 * If the number of midpoints is greater than the number\r\n                 * of allowed falsetickers, the intersection contains at\r\n                 * least one truechimer with no midpoint.  If so,\r\n                 * increment the number of allowed falsetickers and go\r\n                 * around again.  If not and the intersection is\r\n                 * non-empty, declare success.\r\n                 */\r\n                if (found > allow)\r\n                        continue;\r\n\r\n                if (high > low)\r\n                        break;\r\n        }",
    "notes": "The algorithm described in section 11.2.3 is not properly written here; we compare c to n - f in the algorithm, but f != found; f corresponds to the \"allowed\" falsetickers. This algorithm implementation results in the lower and upper bounds unchanging throughout the described loop, but this change should fix the implementation.\r\n\r\n---\r\n\r\n[INT AD notes]\r\n\r\nFor analysis and further discussion see https://mailarchive.ietf.org/arch/msg/ntp/zJNoHvZ08SPX-3kwflMK7PIReFo/ especially the one or two addition issues identified.",
    "submit_date": "2020-06-08",
    "submitter_name": "Tam Phan",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2022-09-25 17:33:25"
  },
  {
    "errata_id": "6280",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "A.5.5.1.",
    "orig_text": "There is the following comment:\r\n\r\n* First, construct the chime list of tuples (p, type, edge) as\r\n* shown below, then sort the list by edge from lowest to\r\n* highest.\r\n\r\n",
    "correct_text": "There should be some statements to do the sorting since the comment mentions it. But there are no statements related to sorting in the following code. \r\n\r\nAnd I checked the NTP reference implementation. There is code to do the sorting at https://github.com/ntp-project/ntp/blob/71a962710bfe066f76da9679cf4cfdeffe34e95e/ntpd/ntp_proto.c#L2837\r\n",
    "notes": "From https://mailarchive.ietf.org/arch/msg/ntp/zJNoHvZ08SPX-3kwflMK7PIReFo/ :\r\n\r\n\"\"\"\r\n... correctly identifies the problem, but it doesn't provide the new\r\ntext. I'd suggest to add \"sort(s.m, n);\" right after the first while\r\nloop in A.5.5.1.\r\n\"\"\"",
    "submit_date": "2020-09-05",
    "submitter_name": "Jingguo Yao",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2022-09-25 17:29:52"
  },
  {
    "errata_id": "6423",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "6",
    "orig_text": "| 1 Jan 1972  | 41,317     | 0   | 2,272,060,800 | First day UTC    |",
    "correct_text": "| 1 Jan 1972  | 41,317     | 0   | 2,272,060,800 | First day \"modern\" UTC |",
    "notes": "The initial definition of UTC was introduced in 1963 with CCIR Recommendation 374. The time standard specified that seconds had a varying duration. In 1970, CCIR Recommendation 460 introduced the current definition of UTC, using leap seconds, which was implemented on the first second of 1972. Consult D. McCarthy's \"Note on Coordinated Universal Time\" (numbered CCTF/09-32 by the Consultative Committee for Time and Frequency of the BIPM) for more information.\r\n\r\n---\r\n\r\nThere may perhaps be more precise terminology than \"modern\", but this point should be addressed by a document that updates or replaces this one.",
    "submit_date": "2021-02-07",
    "submitter_name": "Stijn van Drongelen",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2022-07-27 08:30:52"
  },
  {
    "errata_id": "6524",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "6",
    "orig_text": "202,939,144",
    "correct_text": "202,934,144",
    "notes": "In Figure 4 The Era Offset of 1 Jan 1 has a typo.\r\n\r\nThe value of 202,939,144 for the Era Offset of 1 Jan 1 should be 202,934,144 because 1 Jan 0 has an Era Offset of 171,311,744 and there are 366 days in year 0, therefore the Era Offset for 1 Jan 1 should be 86400 * 366 (= 31,622,400) greater than that for 1 JAN 0.\r\n\r\n---\r\n\r\n[INT AD notes]\r\n\r\nFrom https://mailarchive.ietf.org/arch/msg/ntp/Cbg3sOhChyfenYoj7UG5wCymFMU/ :\r\n\r\n\"\"\"\r\n... might be correct too, but I find that table confusing with those\r\ndates when the modern definition of the second and UTC didn't exist\r\nyet...\r\n\"\"\"",
    "submit_date": "2021-04-09",
    "submitter_name": "Kenneth Duffill",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2022-09-25 17:27:35"
  },
  {
    "errata_id": "6550",
    "doc-id": "RFC5905",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "A.5.2",
    "orig_text": "        for (i = 0; i < NSTAGE; i++) {\r\n                p->disp += f[i].disp / (2 ^ (i + 1));\r\n                p->jitter += SQUARE(f[i].offset - f[0].offset);\r\n        }",
    "correct_text": "        for (i = 0; i < NSTAGE; i++) {\r\n                p->disp += f[i].disp / (1 << (i + 1));\r\n                p->jitter += SQUARE(f[i].offset - f[0].offset);\r\n        }",
    "notes": "^ is the xor operator in C, not the exponent operator.  2 xor (i+1) will be zero when i == 1, causing a division by zero error.",
    "submit_date": "2021-04-17",
    "submitter_name": "Perry Lorier",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2022-08-29 16:08:00"
  },
  {
    "errata_id": "7555",
    "doc-id": "RFC5905",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "4",
    "orig_text": "Under the auspices of the\r\n   Metre Convention of 1865, in 1975 the CGPM [CGPM] strongly endorsed\r\n   the use of UTC as the basis for civil time.",
    "correct_text": "Under the auspices of the\r\n   Metre Convention of 1875, in 1975 the CGPM [CGPM] strongly endorsed\r\n   the use of UTC as the basis for civil time.",
    "notes": "The Metre convention was signed on 20 May 1875 as stated on https://www.bipm.org/en/metre-convention.",
    "submit_date": "2023-06-28",
    "submitter_name": "Sylvain Etienne",
    "verifier_id": "2",
    "verifier_name": "RFC Editor",
    "update_date": "2023-06-28 14:30:48"
  },
  {
    "errata_id": "8214",
    "doc-id": "RFC5905",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "A.5.5.7",
    "orig_text": "  /*\r\n   * rstclock() - clock state machine\r\n   */\r\n  void\r\n  rstclock(\r\n          int     state,          /* new state */\r\n          double  offset,         /* new offset */\r\n          double  t               /* new update time */\r\n          )\r\n  {\r\n          /*\r\n           * Enter new state and set state variables.  Note, we use the\r\n           * time of the last clock filter sample, which must be earlier\r\n           * than the current time.\r\n           */\r\n          c.state = state;\r\n          c.last = c.offset = offset;\r\n          s.t = t;\r\n  }",
    "correct_text": "  /*\r\n   * rstclock() - clock state machine\r\n   */\r\n  void\r\n  rstclock(\r\n          int     state,          /* new state */\r\n          double  t,              /* new update time */\r\n          double  offset          /* new offset */\r\n          )\r\n  {\r\n          /*\r\n           * Enter new state and set state variables.  Note, we use the\r\n           * time of the last clock filter sample, which must be earlier\r\n           * than the current time.\r\n           */\r\n          c.state = state;\r\n          c.last = c.offset = offset;\r\n          s.t = t;\r\n  }",
    "notes": "These are all the calls of rstclock in the example code:\r\n\r\n- rstclock(FSET, 0, 0); inside main(), pg 71\r\n- rstclock(NSET, 0, 0); inside main(), pg 71\r\n- rstclock(FREQ, p->t, 0); inside local_clock(), pg 100\r\n- rstclock(SYNC, p->t, 0); inside local_clock(), pg 100\r\n- rstclock(FREQ, p->t, offset); inside local_clock(), pg 100\r\n- rstclock(SYNC, p->t, offset); inside local_clock(), pg 101\r\n- rstclock(SYNC, p->t, offset); inside local_clock(), pg 102\r\n\r\nAll calls use the new update time as the second argument and the new offset as the third argument, or set both to zero. But the definition of rstclock expects the new offset as the second argument and the new update time as the third, i.e. the order of the parameters is flipped.",
    "submit_date": "2024-12-18",
    "submitter_name": "Manuel Bergler",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2025-08-10 17:33:40"
  },
  {
    "errata_id": "8215",
    "doc-id": "RFC5905",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "A.5.5.4",
    "orig_text": "        /*\r\n         * Combine the survivor offsets and update the system clock; the\r\n         * local_clock() routine will tell us the good or bad news.\r\n         */\r\n        s.t = p->t;\r\n        clock_combine();\r\n        switch (local_clock(p, s.offset)) {\r\n.....\r\n        }",
    "correct_text": "        /*\r\n         * Combine the survivor offsets and update the system clock; the\r\n         * local_clock() routine will tell us the good or bad news.\r\n         */\r\n        clock_combine();\r\n        switch (local_clock(p, s.offset)) {\r\n.....\r\n        }\r\n        s.t = p->t;",
    "notes": "The `clock_update` function sets `s.t` to the value of `p->t` before calling `local_clock`. This causes the assignment `mu =  p->t - s.t;` inside the `local_clock` function to always set `mu` to zero, which in turn causes a division by zero when evaluating `freq = (offset - c.offset) / mu;`\r\n\r\nLuckily, neither `clock_combine()` nor any code inside the switch's cases make use of `s.t`, neither directly nor indirectly. Moreover, the only way to return early from the `clock_update` function is by exiting the program entirely. Moving the assignment to after the `switch` thus cannot cause bugs due to using an outdated value in `clock_combine`, any of the cases and anything happening after `clock_update` returns.\r\n\r\nAll that is left to do to verify that the suggested correction fixes the problem without introducing other bugs is to ensure that moving the assignment doesn't unintentionally change the behavior of the `local_clock` function. There are three distinct cases how `s.t` is used inside `local_clock`:\r\n\r\n- Its value is used in the (currently problematic) calculation of `mu`\r\n- Its value is updated through calls of `rstclock`\r\n- Its value is used in the condition of the `if` statement `if (c.t - s.t < WATCH) return (IGNORE);` in the `FREQ` case on pg 101\r\n\r\nThe change of behavior of the computation of `mu` is the intended effect of this erratum, so that is fine.\r\nThe calls to `rstclock` all set the value of `s.t` to the value of `p->t` (assuming erratum 8214 [0] is correct) , so having the assignment `s.t = p->t;` at the end of `clock_update` fortunately doesn't conflict with the value set by `rstclock`.\r\n\r\nSince I haven't fully grasped how the clock discipline is supposed to work I'm unsure about what to do with the `c.t - s.t < WATCH` condition, though. It might be the case that the condition should've used the old value of `s.t` just like the computation of `mu`, in which case there is nothing to do. If, however, the current behavior is correct, the condition has to be replaced by `c.t - p->t < WATCH`.\r\n\r\n\r\n[0] https://www.rfc-editor.org/errata/eid8214\r\n\r\n\r\n--- notes ---\r\n\r\nMarking as HFDU, but noting here that my preferred \"document update\" strategy would be to DELETE ALL CODE from the document.",
    "submit_date": "2024-12-18",
    "submitter_name": "Manuel Bergler",
    "verifier_id": "165",
    "verifier_name": "Erik Kline",
    "update_date": "2025-10-18 16:10:55"
  }
]
