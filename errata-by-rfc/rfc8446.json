[
  {
    "errata_id": "5483",
    "doc-id": "RFC8446",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.2.8.2",
    "orig_text": "For X25519 and X448, the contents of the public value are the byte\r\nstring inputs and outputs of the corresponding functions defined in\r\n[RFC7748]: 32 bytes for X25519 and 56 bytes for X448.",
    "correct_text": "For X25519 and X448, the contents of the public value are the byte\r\nstring outputs of the corresponding functions defined in [RFC7748]: 32\r\nbytes for X25519 and 56 bytes for X448.",
    "notes": "Per Section 7.4.2 of this RFC and Section 6 of RFC7748, the byte string inputs to the corresponding ECDH scalar multiplication function are the private key and the u-coordinate of the standard public base point, the former of which of course must not be transmitted and the latter of which is a known constant.\r\n\r\nPaul Wouters (AD): Resolved but with the following Corrected Text:\r\n\r\nFor X25519 and X448, the contents of the public value is the K_A or\r\nK_B value described in Section 6 of [RFC7748].  This is 32 bytes for\r\nX25519 and 56 bytes for X448.\r\n\r\nFrom another perspective, including the byte string inputs in the contents of the public value would contradict the resulting content sizes given at the end of the cited paragraph as well as the statement in Section 7.4.2 that the public key put into the KeyShareEntry is the output of ECDH scalar multiplication function.",
    "submit_date": "2018-08-28",
    "submitter_name": "Patrick Kelsey",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-28 17:57:07"
  },
  {
    "errata_id": "5627",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "4.2.11",
    "orig_text": "In TLS versions prior to TLS 1.3, the Server Name Identification\r\n(SNI) value ",
    "correct_text": "In TLS versions prior to TLS 1.3, the Server Name Indication\r\n(SNI) value ",
    "notes": "RFC 6066 and many other places indicate that the correct expansion for \"SNI\" is \"Server Name Indication\", not \"Server Name Identification\".",
    "submit_date": "2019-02-08",
    "submitter_name": "Daniel Kahn Gillmor",
    "verifier_id": "159",
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": "5682",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "4.3.2, B.3.2",
    "orig_text": "     struct {\r\n         opaque certificate_request_context<0..2^8-1>;\r\n         Extension extensions<2..2^16-1>;\r\n     } CertificateRequest;",
    "correct_text": "     struct {\r\n         opaque certificate_request_context<0..2^8-1>;\r\n         Extension extensions<0..2^16-1>;\r\n     } CertificateRequest;",
    "notes": "The length of this vector can never 2.  It is either 0, if the vector is empty, or >=4, if the vector has at least one extension.  Nothing elsewhere in the spec requires a non-zero number of extensions here, so this syntax should allow a zero-length vector.\r\n\r\nPaul Wouters (AD): There are two places in the mentioned sections that need this one liner fix.",
    "submit_date": "2019-04-01",
    "submitter_name": "Richard Barnes",
    "verifier_id": "2",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-01-22 10:29:40"
  },
  {
    "errata_id": "5717",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "2.2.",
    "orig_text": " Figure 3 shows a pair of handshakes in which the first handshake\r\n   establishes a PSK and the second handshake uses it:\r\n \r\n          Client                                               Server\r\n \r\n   Initial Handshake:\r\n          ClientHello\r\n          + key_share               -------->\r\n                                                          ServerHello\r\n                                                          + key_share\r\n                                                {EncryptedExtensions}\r\n                                                {CertificateRequest*}\r\n                                                       {Certificate*}\r\n                                                 {CertificateVerify*}\r\n                                                           {Finished}\r\n                                    <--------     [Application Data*]\r\n          {Certificate*}\r\n          {CertificateVerify*}\r\n          {Finished}                -------->\r\n                                    <--------      [NewSessionTicket]\r\n          [Application Data]        <------->      [Application Data]\r\n \r\n \r\n   Subsequent Handshake:\r\n          ClientHello\r\n          + key_share*\r\n          + pre_shared_key          -------->\r\n                                                          ServerHello\r\n                                                     + pre_shared_key\r\n                                                         + key_share*\r\n                                                {EncryptedExtensions}\r\n                                                           {Finished}\r\n                                    <--------     [Application Data*]\r\n          {Finished}                -------->\r\n          [Application Data]        <------->      [Application Data]\r\n \r\n               Figure 3: Message Flow for Resumption and PSK\r\n",
    "correct_text": " Figure 3 shows a pair of handshakes in which the first handshake\r\n   establishes a PSK and the second handshake uses it:\r\n \r\n          Client                                               Server\r\n \r\n   Initial Handshake:\r\n          ClientHello\r\n          + key_share               -------->\r\n                                                          ServerHello\r\n                                                          + key_share\r\n                                                {EncryptedExtensions}\r\n                                                {CertificateRequest*}\r\n                                                       {Certificate*}\r\n                                                 {CertificateVerify*}\r\n                                                           {Finished}\r\n                                    <--------     [Application Data*]\r\n          {Certificate*}\r\n          {CertificateVerify*}\r\n          {Finished}                -------->\r\n                                    <--------      [NewSessionTicket]\r\n          [Application Data]        <------->      [Application Data]\r\n \r\n \r\n   Subsequent Handshake:\r\n          ClientHello\r\n          + key_share*\r\n          + psk_key_exchange_modes        \r\n          + pre_shared_key          -------->\r\n\r\n                                                          ServerHello\r\n                                                     + pre_shared_key\r\n                                                         + key_share*\r\n                                                {EncryptedExtensions}\r\n                                                           {Finished}\r\n                                    <--------     [Application Data*]\r\n          {Finished}                -------->\r\n          [Application Data]        <------->      [Application Data]\r\n \r\n               Figure 3: Message Flow for Resumption and PSK\r\n",
    "notes": "The pre_shared_key requires the pre_share_key extension.\r\n\r\nThis Issue and PR should address this erratum:\r\nhttps://github.com/tlswg/tls13-spec/issues/1344\r\nhttps://github.com/tlswg/tls13-spec/pull/1345\r\n",
    "submit_date": "2019-05-03",
    "submitter_name": "Daniel Migault",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-28 18:17:26"
  },
  {
    "errata_id": "5868",
    "doc-id": "RFC8446",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.2.3",
    "orig_text": "   ECDSA algorithms:  Indicates a signature algorithm using ECDSA\r\n      [ECDSA], the corresponding curve as defined in ANSI X9.62 [ECDSA]\r\n      and FIPS 186-4 [DSS], and the corresponding hash algorithm as\r\n      defined in [SHS].  The signature is represented as a DER-encoded\r\n      [X690] ECDSA-Sig-Value structure.",
    "correct_text": "   ECDSA algorithms:  Indicates a signature algorithm using ECDSA\r\n      [ECDSA], the corresponding curve as defined in ANSI X9.62 [ECDSA]\r\n      and FIPS 186-4 [DSS], and the corresponding hash algorithm as\r\n      defined in [SHS].  The signature is represented as a DER-encoded\r\n      [X690] ECDSA-Sig-Value structure as defined in [RFC4492].",
    "notes": "There is a possibility for confusion as the ECDSA-Sig-Value has two conflicting definitions in authoritative standards. TLS always used the following (see RFC4492):\r\n\r\n   ECDSA-Sig-Value ::= SEQUENCE {\r\n     r  INTEGER,\r\n     s  INTEGER\r\n   }\r\n\r\nbut the publicly accessible SECG SEC1 v2.0 (https://www.secg.org/sec1-v2.pdf) defines it like this:\r\n\r\nECDSA-Sig-Value ::= SEQUENCE {\r\n r INTEGER,\r\n s INTEGER,\r\n a INTEGER OPTIONAL,\r\n y CHOICE { b BOOLEAN, f FieldElement } OPTIONAL\r\n}\r\n\r\nI think using the RFC5480 in the Corrected Text would be cleaner than RFC4492, but the former is not an existing reference, so we would need to update section 12 also.",
    "submit_date": "2019-10-02",
    "submitter_name": "Hubert Kario",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-20 20:24:17"
  },
  {
    "errata_id": "5874",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "5.1",
    "orig_text": "...\r\n\r\n   Application Data messages contain data that is opaque to TLS.\r\n   Application Data messages are always protected.  Zero-length\r\n   fragments of Application Data MAY be sent, as they are potentially\r\n   useful as a traffic analysis countermeasure.  Application Data\r\n   fragments MAY be split across multiple records or coalesced into a\r\n   single record.",
    "correct_text": "...\r\n\r\n   Application Data messages contain data that is opaque to TLS.\r\n   Application Data messages are always protected.  Zero-length\r\n   fragments of Application Data (i.e. those encapsulating an\r\n   TLSInnerPlaintext record having a content field of length zero)\r\n   MAY be sent, as they are potentially useful as a traffic analysis\r\n   countermeasure. Application Data fragments MAY be split across\r\n   multiple records or coalesced into a single record.",
    "notes": "In the interest of clarity, it may be prudent to specify the type of record for\r\nwhich a fragment of length zero is being considered - it cannot be that of the\r\nTLSCiphertext itself, for \"Application Data messages are always protected,\"\r\ntherefore I infer this relates to the TLSInnerPlaintext content field (of\r\nlength \"TLSPlaintext.length\") - i.e. to the TLSPlaintext fragment.\r\n\r\nNote: This comment also applies to previous versions of the TLS specification,\r\nin particular with the introduction of the respective text concerning zero-length\r\nfragments in RFC 5246. In TLS 1.2, this would be the GenericXXCipher content\r\nfield of length \"TLSCompressed.length\" - i.e. to the TLSCompressed fragment.\r\n\r\nNote: The implications of zero-length records must be considered with respect to\r\npotential vectors for denial of service.\r\n\r\nPaul Wouters(AD): Currently discussed at:\r\n\r\nhttps://github.com/tlswg/tls13-spec/issues/1346\r\nhttps://github.com/tlswg/tls13-spec/pull/1347",
    "submit_date": "2019-10-12",
    "submitter_name": "Mr Laurie Perrin",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-04-05 05:46:18"
  },
  {
    "errata_id": "5976",
    "doc-id": "RFC8446",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "11",
    "orig_text": "   This document updates an entry in the TLS Certificate Types registry\r\n   originally created in [RFC6091] and updated in [RFC8447].  IANA has\r\n   updated the entry for value 1 to have the name \"OpenPGP_RESERVED\",\r\n   \"Recommended\" value \"N\", and comment \"Used in TLS versions prior\r\n   to 1.3.\"\r\n",
    "correct_text": "   This document updates two entries in the TLS Certificate Types registry\r\n   originally created in [RFC6091] and updated in [RFC8447].  IANA has\r\n   updated the entry for value 1 to have the name \"OpenPGP_RESERVED\",\r\n   \"Recommended\" value \"N\", and comment \"Used in TLS versions prior\r\n   to 1.3.\"  IANA has updated the entry for value 0 to have the name\r\n   \"X509\", \"Recommended\" value \"Y\", and comment \"Was X.509 before TLS 1.3\".",
    "notes": "The protocol description language changed the spelling used for \"X509\", and the registry should be updated to match.",
    "submit_date": "2020-02-04",
    "submitter_name": "Rich Salz",
    "verifier_id": "159",
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2020-03-06 19:01:36"
  },
  {
    "errata_id": "6120",
    "doc-id": "RFC8446",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "1",
    "orig_text": "the underlying transport is a reliable, in-order data stream\r\n\r\n",
    "correct_text": "the underlying transport layer is a reliable, in-order stream delivery service\r\n\r\nor\r\n\r\nthe underlying transport protocol is a reliable, in-order stream delivery service\r\n\r\nor similar",
    "notes": "Similar elsewhere\n --VERIFIER NOTES-- \n   rejected by WG.",
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 11:46:02"
  },
  {
    "errata_id": "6121",
    "doc-id": "RFC8446",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "1",
    "orig_text": "cryptographic modes",
    "correct_text": "cryptographic algorithms",
    "notes": "\n --VERIFIER NOTES-- \n   rejected by WG",
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 11:46:48"
  },
  {
    "errata_id": "6122",
    "doc-id": "RFC8446",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "1.2",
    "orig_text": "The key derivation functions have been redesigned.",
    "correct_text": "The key derivation function has been redesigned.",
    "notes": null,
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-20 20:27:21"
  },
  {
    "errata_id": "6123",
    "doc-id": "RFC8446",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "2",
    "orig_text": "The handshake protocol allows peers to negotiate a protocol version, select cryptographic algorithms, optionally authenticate each other, and establish shared secret keying material.",
    "correct_text": null,
    "notes": "Only client authentication is optional (albeit, server authentication is implicit for PSK-only key exchange mode)\r\n\r\nPaul Wouters(AD): corrected with the following text:\r\n\r\nThe handshake protocol allows peers to negotiate a protocol version, select cryptographic algorithms, authenticate each other (with client authentication being optional), and establish shared secret keying material.",
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-28 17:59:40"
  },
  {
    "errata_id": "6124",
    "doc-id": "RFC8446",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "2",
    "orig_text": "   In the Key Exchange phase, the client sends the ClientHello                  \r\n   (Section 4.1.2) message, which contains a random nonce                       \r\n   (ClientHello.random); its offered protocol versions; a list of               \r\n   symmetric cipher/HKDF hash pairs; either a set of Diffie-Hellman key         \r\n   shares (in the \"key_share\" (Section 4.2.8) extension), a set of              \r\n   pre-shared key labels (in the \"pre_shared_key\" (Section 4.2.11)              \r\n   extension), or both; and potentially additional extensions.   ",
    "correct_text": "   In the Key Exchange phase, the client sends the ClientHello                  \r\n   (Section 4.1.2) message, which contains a random nonce                       \r\n   (ClientHello.random); its offered protocol versions; a list of               \r\n   symmetric cipher/Hash algorithm pairs; either a set of Diffie-Hellman key         \r\n   shares (in the \"key_share\" (Section 4.2.8) extension), a set of              \r\n   pre-shared key labels (in the \"pre_shared_key\" (Section 4.2.11)              \r\n   extension), or both; and potentially additional extensions.   \r\n\r\nor\r\n\r\n   In the Key Exchange phase, the client sends the ClientHello                  \r\n   (Section 4.1.2) message, which contains a random nonce                       \r\n   (ClientHello.random); its offered protocol versions; a list of               \r\n   symmetric cipher/Hash algorithm (to be used with HKDF) pairs; either a set of Diffie-Hellman key         \r\n   shares (in the \"key_share\" (Section 4.2.8) extension), a set of              \r\n   pre-shared key labels (in the \"pre_shared_key\" (Section 4.2.11)              \r\n   extension), or both; and potentially additional extensions.   ",
    "notes": "\n --VERIFIER NOTES-- \n   rejected by WG",
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 11:48:22"
  },
  {
    "errata_id": "6125",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "GLOBAL",
    "orig_text": "PSKs are referred to as out-of-band and external",
    "correct_text": "Referring to PSKs as either out-of-band xor external would help at least one reader",
    "notes": " This got incorporated into the bis document, but not exactly as suggested.",
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-20 20:16:30"
  },
  {
    "errata_id": "6126",
    "doc-id": "RFC8446",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "4.1.1",
    "orig_text": "Note that if the PSK can be used without (EC)DHE, then\r\nnon-overlap in the \"supported_groups\" parameters need not be fatal, \r\nas it is in the non-PSK case discussed in the previous paragraph.",
    "correct_text": "Note that if the PSK can be used without (EC)DHE, then\r\nnon-overlap in the \"supported_groups\" parameters need not be fatal, \r\nas it is in the non-PSK case discussed in the previous paragraph, \r\nbecause PSK-only key exchange mode does not need supported_groups.",
    "notes": "If \"the PSK can be used without (EC)DHE\", then PSK-only key exchange mode can be used, which doesn't require supported_groups. This is perhaps worthy of explanation.\n --VERIFIER NOTES-- \n   rejected by WG",
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 11:49:11"
  },
  {
    "errata_id": "6127",
    "doc-id": "RFC8446",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "4.1.2.",
    "orig_text": "If a \"key_share\" extension was supplied in the HelloRetryRequest,\r\nreplacing the list of shares with a list containing a single\r\nKeyShareEntry from the indicated group.",
    "correct_text": "If a \"key_share\" extension was supplied in the HelloRetryRequest,\r\nreplacing the list of shares with a list containing a single\r\nKeyShareEntry from the indicated group. Note: A \"key_share\" \r\nextension may not be supplied in a HelloRetryRequest message \r\nwhen a server receives  an \"early_data\" (Section 4.2.10).",
    "notes": "\n --VERIFIER NOTES-- \n   rejected by WG",
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 11:49:58"
  },
  {
    "errata_id": "6128",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "GLOBAL",
    "orig_text": "terminate and abort are used interchangeable, but this isn't explained until after such use.\r\n\r\nIn Section 6.2, we have: In the rest of this specification, when the phrases \"terminate the connection\" and \"abort the handshake\" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the\r\ndescriptions below.  ",
    "correct_text": "Perhaps explain terminology earlier. At the very least, in Section 6.2, open the above sentence with \"Throughout this specification\"\r\n\r\n",
    "notes": " This got incorporated into the bis document, but not exactly as suggested.",
    "submit_date": "2020-04-24",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-20 20:17:06"
  },
  {
    "errata_id": "6135",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "Global",
    "orig_text": "list, series, set, and vector are seemingly used as synonyms. ",
    "correct_text": "Using list, series, set, xor vector would help at least one reader. \r\n",
    "notes": "Additionally, consistent usage is desirable, e.g., page 31 uses \"A list of extensions\" whereas \"A set of \r\nextensions\" is used on page 60. Elsewhere inconsistently usage causes confusion, e.g., \r\nPage 48:\r\n\r\n   client_shares:  A list of offered KeyShareEntry values in descending\r\n      order of client preference.\r\n\r\n   This vector MAY be empty if the client is requesting a\r\n\r\n(Replace \"vector\" with \"list\", or vice versa.)\r\n\r\nPaul Wouters (AD):  This got incorporated into the bis document, but not exactly as suggested.",
    "submit_date": "2020-04-28",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-20 20:20:06"
  },
  {
    "errata_id": "6136",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "4.1.4",
    "orig_text": "   Upon receipt of a HelloRetryRequest, the client MUST check the\r\n   legacy_version, legacy_session_id_echo, cipher_suite, and     \r\n   legacy_compression_method as specified in Section 4.1.3 ",
    "correct_text": null,
    "notes": "Section 4.1.3 defines no checks for legacy_version nor legacy_compression_method\r\n --VERIFIER NOTES-- \r\n   It does have the listed fields and values it should contain (to check) in the previous 4.1.3 section.\r\n\r\nThis is being addressed; see https://github.com/tlswg/tls13-spec/pull/1364/files\r\n\r\n",
    "submit_date": "2020-04-28",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-18 11:41:57"
  },
  {
    "errata_id": "6137",
    "doc-id": "RFC8446",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "4.2.10",
    "orig_text": "symmetric cipher suite",
    "correct_text": "cipher suite",
    "notes": "\n --VERIFIER NOTES-- \n   rejected by WG",
    "submit_date": "2020-04-28",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 12:07:04"
  },
  {
    "errata_id": "6138",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "4.2.10",
    "orig_text": "   For externally              \r\n   provisioned PSKs, the associated values are those provisioned along \r\n   with the key.  For PSKs established via a NewSessionTicket message, \r\n   the associated values are those which were negotiated in the        \r\n   connection which established the PSK.  \r\n\r\n   ...\r\n\r\n   For externally established             \r\n   PSKs, the associated values are those provisioned along with the key.\r\n   For PSKs established via a NewSessionTicket message, the associated  \r\n   values are those negotiated in the connection during which the ticket\r\n   was established.                                                     ",
    "correct_text": "   For externally              \r\n   provisioned PSKs, the associated values are those provisioned along \r\n   with the key.  For PSKs established via a NewSessionTicket message, \r\n   the associated values are those which were negotiated in the        \r\n   connection which established the PSK.  ",
    "notes": "Drop largely verbatim duplicated text\r\n\r\nPaul Wouters (AD):  This got incorporated into the bis document, but not exactly as suggested.",
    "submit_date": "2020-04-28",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-20 20:21:32"
  },
  {
    "errata_id": "6139",
    "doc-id": "RFC8446",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "4.4.2.2.",
    "orig_text": "As servers MAY require the presence of the \"server_name\" extension, clients\r\nSHOULD send this extension, when applicable.",
    "correct_text": "As servers MAY require the presence of the \"server_name\" extension, client\r\nSHOULD send this extension.",
    "notes": "Since it is unclear when it is applicable for a server to send the extension, dropping \"when applicable\"\r\nseems appropriate. Alternatively, giving some extra guidance would be useful.\r\n\r\nPaul Wouters(AD): Resolved with alternative Corrected Text:\r\n\r\nAs servers MAY require the presence of the \"server_name\" extension, clients SHOULD send this extension when the server is identified by name.\r\n",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-28 18:11:01"
  },
  {
    "errata_id": "6140",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "4.4.2.2.",
    "orig_text": "This fallback chain SHOULD NOT use the deprecated SHA-1 hash\r\nalgorithm in general, but MAY do so if the client's advertisement\r\npermits it, and MUST NOT do so otherwise.",
    "correct_text": "This fullback chain MUST NOT use the deprecated SHA-1 hash,\r\nexcept if advertised by the client, in which case it MAY.",
    "notes": "The original text is difficult to read, eliminating the unnecessary \"SHOULD NOT\" seems to make it \r\neasier.\r\n\r\nPaul Wouters(SEC AD): accepted with slightly different text, keeping the SHOULD NOT -> MUST NOT change proposed here",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 12:13:51"
  },
  {
    "errata_id": "6141",
    "doc-id": "RFC8446",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "4.4.3",
    "orig_text": "   -  The context string",
    "correct_text": "   -  The context string (defined below)",
    "notes": null,
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-20 20:27:54"
  },
  {
    "errata_id": "6142",
    "doc-id": "RFC8446",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.6.1.",
    "orig_text": "Clients MUST NOT cache tickets for longer than 7 days",
    "correct_text": "Clients MUST NOT use tickets for longer than 7 days",
    "notes": "\"MUST NOT cache\" is surely overly zealous and may unnecessarily result in non-compliant implementations",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-20 20:24:56"
  },
  {
    "errata_id": "6143",
    "doc-id": "RFC8446",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "4.2.7",
    "orig_text": "As of TLS 1.3, servers are permitted to send the \"supported_groups\"\r\nextension to the client.",
    "correct_text": null,
    "notes": "It is unclear whether servers are permitted to send the \"supported_groups\" extension to \r\nthe client without solicitation, i.e., when the client does not first send the extension to the \r\nserver. Clarification would be useful.\n --VERIFIER NOTES-- \n   rejected by WG",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 11:58:40"
  },
  {
    "errata_id": "6144",
    "doc-id": "RFC8446",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "4.2.8.",
    "orig_text": "Upon receipt of this extension in a HelloRetryRequest, the client\r\nMUST verify that...the selected_group field does not\r\ncorrespond to a group which was provided in the \"key_share\" extension\r\nin the original ClientHello.",
    "correct_text": "Upon receipt of this extension in a HelloRetryRequest, the client\r\nMUST verify that...a key share was not offered (in the \"key_share\" \r\nextension in the original ClientHello) for the group in the \r\nselected_group field.",
    "notes": "The original text requires knowledge of the \"key_share\" extension and is rather hard to read,\r\nthe proposed text should be easier to understand.\n --VERIFIER NOTES-- \n   rejected by WG",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 12:17:20"
  },
  {
    "errata_id": "6145",
    "doc-id": "RFC8446",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "4.2.10.",
    "orig_text": "When a PSK is used and early data is allowed for that PSK",
    "correct_text": null,
    "notes": "I couldn't find restrictions that forbid early data for a PSK. Explaining where such restrictions\r\ncould exist would be useful. E.g., PSKs might be associated with data that forbids early data.\n --VERIFIER NOTES-- \n   rejected by WG",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 11:59:57"
  },
  {
    "errata_id": "6146",
    "doc-id": "RFC8446",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.2.10.",
    "orig_text": "The TLS version number",
    "correct_text": "The selected TLS version number",
    "notes": null,
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-20 20:26:21"
  },
  {
    "errata_id": "6147",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "4.2.10.",
    "orig_text": "In order to accept early data, the server MUST have accepted a PSK\r\ncipher suite....In addition, it MUST verify that the\r\nfollowing values are the same as those associated with the\r\nselected PSK:\r\n\r\n...\r\n\r\n-  The selected cipher suite",
    "correct_text": null,
    "notes": "Accepting the \"PSK cipher suite\" surely implies the PSK is associated with the cipher suite, hence, \r\n\"The selected cipher suite\" can be dropped.\r\n\r\nPaul Wouters(SEC AD): The text was changed a little to solve this issue",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 12:19:36"
  },
  {
    "errata_id": "6148",
    "doc-id": "RFC8446",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "4.2.10",
    "orig_text": "The selected ALPN [RFC7301] protocol, if any",
    "correct_text": "The selected ALPN [RFC7301] protocol, if extension application_layer_protocol_negotiation is present",
    "notes": "\n --VERIFIER NOTES-- \n   rejected by WG",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 12:21:40"
  },
  {
    "errata_id": "6150",
    "doc-id": "RFC8446",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "GLOBAL",
    "orig_text": "Note that certificate-based client authentication is not available \r\nin PSK handshake flows (including 0-RTT). ",
    "correct_text": "Note that certificate-based client authentication is not available \r\nin PSK handshake flows (including 0-RTT), post-handshake \r\ncertificate-based client authentication is possible.",
    "notes": "\n --VERIFIER NOTES-- \n   rejected by WG",
    "submit_date": "2020-04-29",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 12:23:09"
  },
  {
    "errata_id": "6151",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "4.4",
    "orig_text": "   | Post-     | ClientHello ... client  | client_application_traffic_ |\r\n   | Handshake | Finished +              | secret_N                    |\r\n   |           | CertificateRequest      |                             |",
    "correct_text": "   | Post-     | ClientHello ... client  | [sender]_application_traffic|\r\n   | Handshake | Finished +              | _secret_N                   |\r\n   |           | CertificateRequest      |                             |",
    "notes": null,
    "submit_date": "2020-04-30",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 11:37:19"
  },
  {
    "errata_id": "6152",
    "doc-id": "RFC8446",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "4",
    "orig_text": "Clients MUST check for [\"supported_versions\"] prior to\r\nprocessing the rest of the ServerHello (although they will have to \r\nparse the ServerHello in order to read the extension). -- Section 4.2.1.\r\n\r\nUpon receipt of a HelloRetryRequest, the client MUST check the\r\nlegacy_version, legacy_session_id_echo, cipher_suite, and\r\nlegacy_compression_method as specified in Section 4.1.3 and then\r\nprocess the extensions, starting with determining the version using\r\n\"supported_versions\". -- Section 4.1.4\r\n\r\nUpon receiving a message with type server_hello, implementations MUST\r\nfirst examine the Random value... -- Section 4.1.3.\r\n",
    "correct_text": null,
    "notes": "These requirements are seemingly conflicting. I suspect checking for \"supported_versions\" must \r\ncome first, since that may influence subsequent steps, e.g., checking legacy_compression_method \r\nand the Random value. It doesn't seem to matter whether legacy_version, legacy_session_id_echo, \r\ncipher_suite, and legacy_compression_method are checked before the Random value, so it doesn't\r\nseem to matter which check is second and which is third. (Noting, as per one of my earlier reports,\r\ndated 28 Apr, Section 4.1.3 defines no checks for legacy_version nor legacy_compression_method. \r\nPerhaps the latter should be checked to be zero, aborting with alert illegal_parameter if it isn't, as per\r\nSection 4.1.2.)\n --VERIFIER NOTES-- \n   rejected by WG",
    "submit_date": "2020-05-01",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 12:06:00"
  },
  {
    "errata_id": "6204",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "E.1",
    "orig_text": "Implementations MUST NOT combine external PSKs with certificate-based authentication of either the client or the server unless negotiated by some extension.",
    "correct_text": "Implementations MUST NOT combine external PSKs with certificate-based authentication of either client or the server. Future specifications MAY provide an extension to permit this. ",
    "notes": "The existing text can be misread as permitting this combination upon negotiation of the \"post_handshake_auth\" extension, which would be incorrect. [1] describes an attack that can occur based on this misinterpretation. The proposed text aims to make clear that a *new* extension is required for this combination. \r\n\r\nPaul Wouters(AD): See https://mailarchive.ietf.org/arch/msg/tls/uDjERicvcTimiecyhiSrYA0H1Sc/\r\n[1] https://link.springer.com/article/10.1007%2Fs11416-020-00352-0",
    "submit_date": "2020-06-03",
    "submitter_name": "Chris Wood",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-28 18:13:30"
  },
  {
    "errata_id": "6205",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "4.3.2",
    "orig_text": "   Servers which are authenticating with a PSK MUST NOT send the\r\n   CertificateRequest message in the main handshake, though they MAY\r\n   send it in post-handshake authentication (see Section 4.6.2) provided\r\n   that the client has sent the \"post_handshake_auth\" extension (see\r\n   Section 4.2.6).",
    "correct_text": "   Servers which are authenticating with a resumption PSK MUST NOT send the\r\n   CertificateRequest message in the main handshake, though they MAY\r\n   send it in post-handshake authentication (see Section 4.6.2) provided\r\n   that the client has sent the \"post_handshake_auth\" extension (see\r\n   Section 4.2.6).  Servers which are authenticating with an external PSK\r\n   MUST NOT send the CertificateRequest message either in the main handshake\r\n   or request post-handshake authentication. Future specifications MAY\r\n   provide an extension to permit this. ",
    "notes": "The lack of qualification on \"authenticating with a PSK\" implies that the statement applies equally to both external and resumption PSKs.  However, there are two conditions being governed: whether a certificate can be requested during the handshake, and whether a certificate can be requested post-handshake.  The latter of these requires different rules depending on the type of PSK.\r\n\r\nWe know from the analysis of resumption (see https://mailarchive.ietf.org/arch/msg/tls/TugB5ddJu3nYg7chcyeIyUqWSbA/) that combining a PSK handshake of either type with a client certificate is not safe.  Thus, the prohibition on CertificateRequest during the handshake applies equally to both resumption and external PSKs.\r\n\r\nFor post-handshake, Appendix E.1 already discusses the risks of combining PSKs with certificates, citing the same analysis as above.\r\n\r\n   [...]  It is unsafe to use certificate-based client\r\n   authentication when the client might potentially share the same\r\n   PSK/key-id pair with two different endpoints.\r\n\r\nFor this reason an external PSK is not safe to use with post-handshake authentication.  A resumption PSK does not have this property, so the same prohibition doesn't apply.\r\n\r\nSplitting the requirements as proposed makes this split clearer.",
    "submit_date": "2020-06-04",
    "submitter_name": "Martin Thomson",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-01-16 16:59:14"
  },
  {
    "errata_id": "6401",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "4.6.2",
    "orig_text": "When the client has sent the \"post_handshake_auth\" extension (see\r\nSection 4.2.6), a server MAY request client authentication at any\r\ntime after the handshake has completed by sending a\r\nCertificateRequest message.  ",
    "correct_text": "When the client has sent the \"post_handshake_auth\" extension (see\r\nSection 4.2.6), a server MAY request client authentication during the \r\nmain handshake and/or at any time after the handshake has completed by \r\nsending a CertificateRequest message.  \r\n\r\n",
    "notes": "4.6.2 is ambiguous as to whether it forbids \"main handshake\" (mid-handshake) client \r\nauthentication when the client has sent  the \"post_handshake_auth\" extension. I think \r\nthe language would be stronger if it were really forbidden, and openssl s_server permits \r\nthis behavior and rfc8740 implies it as well.\r\n\r\nThe \"main handshake\" language is adopted from 4.3.2 but \"main\" could be dropped as \r\n\"handshake\" is not ambiguous in 1.3 due to no renegotiation.",
    "submit_date": "2021-01-20",
    "submitter_name": "Eric Covener",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-28 17:54:39"
  },
  {
    "errata_id": "6820",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "6.2",
    "orig_text": "unsupported_extension:  Sent by endpoints receiving any handshake\r\n      message containing an extension known to be prohibited for\r\n      inclusion in the given handshake message, or including any\r\n      extensions in a ServerHello or Certificate not first offered in\r\n      the corresponding ClientHello or CertificateRequest. ",
    "correct_text": "unsupported_extension:  Sent by endpoints receiving any handshake\r\n      message containing an extension in a ServerHello or Certificate\r\n      not first offered in the corresponding ClientHello or \r\n      CertificateRequest.",
    "notes": "The definition of the unsupported_extension alert in section 6.2 contradicts the statements in section 4.2:\r\n\r\n        If an implementation receives an extension\r\n        which it recognizes and which is not specified for the message in\r\n        which it appears, it MUST abort the handshake with an\r\n   \"illegal_parameter\" alert.\r\n\r\nWhile this might not be inconsistent due to the \"abort the handshake with an X alert\" specification at the beginning of section 6.2, it might lead to confusion. (see https://mailarchive.ietf.org/arch/msg/tls/hGOGWZRMg718mWqOZ06LwjV9360/).\r\n\r\nPaul Wouters(AD): Currently discussed at:\r\n\r\nhttps://github.com/tlswg/tls13-spec/issues/1352\r\nhttps://github.com/tlswg/tls13-spec/pull/1353",
    "submit_date": "2022-01-21",
    "submitter_name": "Leander Schwarz",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-04-05 05:47:15"
  },
  {
    "errata_id": "7003",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "4.6.1.",
    "orig_text": "At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message.",
    "correct_text": "At any time after the server has received both a \"psk_key_exchange_modes\" extension and a Finished message, it MAY send a NewSessionTicket message.\r\n\r\n",
    "notes": "Section 4.2.9. demands \r\n\r\nIn order to use PSKs, clients MUST also send a \"psk_key_exchange_modes\" extension.\r\n\r\nHence, an additional restriction is needed in Section 4.6.1.",
    "submit_date": "2022-06-22",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 11:38:47"
  },
  {
    "errata_id": "7073",
    "doc-id": "RFC8446",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "4.4",
    "orig_text": "These messages are encrypted under keys derived from the [sender]_handshake_traffic_secret.",
    "correct_text": "These messages are encrypted under keys derived from the [sender]_handshake_traffic_secret, except for post-handshake authentication",
    "notes": "There's an exception",
    "submit_date": "2022-08-06",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 11:40:02"
  },
  {
    "errata_id": "7250",
    "doc-id": "RFC8446",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.6.1",
    "orig_text": "   The client MAY use this PSK for future handshakes by including the\r\n   ticket value in the \"pre_shared_key\" extension in its ClientHello\r\n   (Section 4.2.11).",
    "correct_text": "(to add)\r\n\r\n  Where the client does not support session tickets, this extension MUST be ignored.",
    "notes": "I've seen a TLS implementation which doesn't implement session tickets.  That's fine, but the implementation doesn't *ignore* session tickets it receives.  Instead, it treats reception of the ticket as un recoverable error, and drops the TLS connection.\r\n\r\nIt's also worth adding a note to section 4.2 at the bottom of page 38.  To note that in general, f an extension isn't supported AND doesn't materially affect the TLS exchange, THEN it should be ignored.\r\n\r\ni.e. there's nothing in the spec which mentions Postel's law \"be conservative in what you send, be liberal in what you accept\".  So implementors reading this document are free to do all kinds of odd things.\r\n\r\nIn addition, the text in Section 4.2 at the bottom of page 38 says:\r\n\r\n\"\r\n      Designers\r\n      and implementors should be aware of the fact that until the\r\n      handshake has been authenticated, active attackers can modify\r\n      messages and insert, remove, or replace extensions.\r\n\"\r\n\r\nThe implicit conclusion here is that an implementation receiving extensions must sanity check them.  e.g. an attacker adding an undefined / unknown extension should not cause the entire session to be torn down.\r\n\r\nPaul Wouters(AD): Resolved but with the Corrected Text:\r\n\r\nThe client MAY use this PSK for future handshakes by including the ticket value in the \"pre_shared_key\" extension in its ClientHello (Section 4.2.11). Clients which receive a NewSessionTicket message but do not support resumption MUST silently ignore this message.",
    "submit_date": "2022-11-14",
    "submitter_name": "Alan DeKok",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-28 18:06:50"
  },
  {
    "errata_id": "7303",
    "doc-id": "RFC8446",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "6.1",
    "orig_text": "This alert notifies the recipient that the sender will not send any more messages on this connection. ",
    "correct_text": "This alert notifies the recipient that the sender will not send any more messages on this connection. close_notify alerts should be sent with a severity level of WARNING.",
    "notes": "Apparently, TLS/1.0 specified these should be set to WARNING, not FATAL, but this text got lost somewhere along the way. https://github.com/pion/dtls/issues/195\r\n\r\nOpenSSL/NSS both send as WARNING, and servers that have tried sending as FATAL have encountered compatibility problems with clients which treat FATAL alerts differently than WARNING alerts: e.g. https://source.chromium.org/chromium/chromium/src/+/main:third_party/boringssl/src/ssl/tls_record.cc;l=591;drc=c0872c02015009bf3dbab0a83c0452d141e8e9cf?q=tls_open_record&ss=chromium%2Fchromium%2Fsrc\r\n\r\nPaul Wouters(AD): Resolved but with the following Corrected Text:\r\n\r\nclose_notify:  This alert notifies the recipient that the sender will not send any more messages on this connection.  Any data received after a closure alert has been received MUST be ignored. This alert MUST be sent with AlertLevel=warning.",
    "submit_date": "2023-01-12",
    "submitter_name": "Eric Lawrence",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-03-28 18:04:34"
  },
  {
    "errata_id": "7620",
    "doc-id": "RFC8446",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "6.1",
    "orig_text": "Each party MUST send a \"close_notify\" alert before closing its write\r\nside of the connection, unless it has already sent some error alert.\r\nThis does not have any effect on its read side of the connection.\r\nNote that this is a change from versions of TLS prior to TLS 1.3 in\r\nwhich implementations were required to react to a \"close_notify\" by\r\ndiscarding pending writes and sending an immediate \"close_notify\"\r\nalert of their own.  That previous requirement could cause truncation\r\nin the read side.  Both parties need not wait to receive a\r\n\"close_notify\" alert before closing their read side of the\r\nconnection, though doing so would introduce the possibility of\r\ntruncation.",
    "correct_text": "Each party MUST send a \"close_notify\" alert before closing its write\r\nside of the connection, unless it has already sent some error alert.\r\nThis SHOULD NOT have any effect on the read side of the sender's connection;\r\nparties SHOULD receive a \"close_notify\" alert before closing the read side of their connection.\r\nNote that this is a change from versions of TLS prior to TLS 1.3 in\r\nwhich receivers were required to react to a \"close_notify\" by\r\ndiscarding pending writes and sending an immediate \"close_notify\"\r\nalert of their own.  That previous requirement could cause truncation\r\nin the read side.  Both parties need not wait to receive a\r\n\"close_notify\" alert before closing their read side of the\r\nconnection, though doing so would introduce the possibility of\r\ntruncation.",
    "notes": "As-is there's a specification-level vulnerability: Specification-compliant implementations may be vulnerable to truncation attacks.\r\n\r\nI suggest using SHOULD NOT & SHOULD for better signposting and to avoid specification-level vulnerability.\r\n\r\nI also suggest minor tweaks for readability.\n --VERIFIER NOTES-- \n   Rejected by WG. See https://github.com/tlswg/tls13-spec/pull/1357/commits/d2a36a8029067cb20ff431fcaa8b3a4e537e4bf6",
    "submit_date": "2023-08-28",
    "submitter_name": "Ben Smyth",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2024-10-17 11:54:03"
  },
  {
    "errata_id": "7774",
    "doc-id": "RFC8446",
    "errata_status_code": "Verified",
    "errata_type_code": "Editorial",
    "section": "4.1.3",
    "orig_text": "ServerHello.Random",
    "correct_text": "ServerHello.random",
    "notes": "Lowercase \"random\".\r\n\r\nThis report was created/verified per Paul Wouter's note at https://www.rfc-editor.org/errata/eid7769.",
    "submit_date": "2024-01-22",
    "submitter_name": "Rebecca VanRheenen",
    "verifier_id": "2",
    "verifier_name": "RFC Editor",
    "update_date": "2024-01-22 10:43:23"
  },
  {
    "errata_id": "8411",
    "doc-id": "RFC8446",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "4.2.7",
    "orig_text": "struct {\r\n    NamedGroup named_group_list<2..2^16-1>;\r\n} NamedGroupList;",
    "correct_text": "struct {\r\n    NamedGroup named_group_list<2..2^16-2>;\r\n} NamedGroupList;",
    "notes": "The specified maximum legal length of the named_group_list vector in the NamedGroupList structure is 2^16-1 bytes. This is invalid because NamedGroup is an enum that occupies two bytes, but 2^16-1 is not an exact multiple of the element size (2 bytes), as required in Section 3.4. It appears that the intended upper bound should be 2^16-2 bytes instead.\r\n\r\nAD note: This is scheduled for the bis document via https://github.com/tlswg/tls13-spec/pull/1380 ",
    "submit_date": "2025-05-08",
    "submitter_name": "Albin Johansson",
    "verifier_id": "173",
    "verifier_name": "Paul Wouters",
    "update_date": "2025-05-09 06:10:30"
  }
]
