[
  {
    "errata_id": 1585,
    "doc-id": "RFC5246",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "A.4.2",
    "orig_text": "struct {\r\n    ClientCertificateType certificate_types<1..2^8-1>;\r\n    DistinguishedName certificate_authorities<0..2^16-1>;\r\n} CertificateRequest;\r\n",
    "correct_text": "struct {\r\n    ClientCertificateType certificate_types<1..2^8-1>;\r\n    SignatureAndHashAlgorithm\r\n      supported_signature_algorithms<2^16-1>;\r\n    DistinguishedName certificate_authorities<0..2^16-1>;\r\n} CertificateRequest;\r\n",
    "notes": "The definition in Section 7.4.4 (which includes the \"supported_\r\nsignature_algorithms\" field) is the correct one (confirmed\r\nby Eric Rescorla on 2009-02-27)",
    "submit_date": "2008-11-05",
    "submitter_name": "Pasi Eronen",
    "verifier_id": 111,
    "verifier_name": "Pasi Eronen",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2165,
    "doc-id": "RFC5246",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "6.2.3.2",
    "orig_text": "   Example: If the block length is 8 bytes, the content length\r\n   (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes,\r\n   then the length before padding is 82 bytes (this does not include the\r\n\r\n\r\n\r\nDierks & Rescorla           Standards Track                    [Page 23]\r\n\f\r\nRFC 5246                          TLS                        August 2008\r\n\r\n\r\n   IV.  Thus, the padding length modulo 8 must be equal to 6 in order to\r\n   make the total length an even multiple of 8 bytes (the block length).\r\n   The padding length can be 6, 14, 22, and so on, through 254.  If the\r\n   padding length were the minimum necessary, 6, the padding would be 6\r\n   bytes, each containing the value 6.  Thus, the last 8 octets of the\r\n   GenericBlockCipher before block encryption would be xx 06 06 06 06 06\r\n   06 06, where xx is the last octet of the MAC.\r\n",
    "correct_text": "   Example: If the block length is 8 bytes, the content length\r\n   (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes,\r\n   then the length before padding is 82 bytes (this does not include the\r\n\r\n\r\n\r\nDierks & Rescorla           Standards Track                    [Page 23]\r\n\f\r\nRFC 5246                          TLS                        August 2008\r\n\r\n\r\n   IV).  Thus, the padding length modulo 8 must be equal to 6 in order to\r\n   make the total length an even multiple of 8 bytes (the block length).\r\n   The padding length can be 6, 14, 22, and so on, through 254.  If the\r\n   padding length were the minimum necessary, 6, the padding would be 6\r\n   bytes, each containing the value 6.  Thus, the last 8 octets of the\r\n   GenericBlockCipher before block encryption would be xx 06 06 06 06 06\r\n   06 06, where xx is the last octet of the MAC.\r\n",
    "notes": null,
    "submit_date": "2010-04-19",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2390,
    "doc-id": "RFC5246",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "6.2.3.3",
    "orig_text": "   The additional authenticated data, which we denote as\r\n   additional_data, is defined as follows:\r\n\r\n      additional_data = seq_num + TLSCompressed.type +\r\n                        TLSCompressed.version + TLSCompressed.length;\r\n\r\n   where \"+\" denotes concatenation.\r\n\r\n   The aead_output consists of the ciphertext output by the AEAD\r\n   encryption operation.  The length will generally be larger than\r\n   TLSCompressed.length, but by an amount that varies with the AEAD\r\n   cipher.  Since the ciphers might incorporate padding, the amount of\r\n   overhead could vary with different TLSCompressed.length values.  Each\r\n   AEAD cipher MUST NOT produce an expansion of greater than 1024 bytes.\r\n   Symbolically,",
    "correct_text": "   The additional authenticated data, which we denote as\r\n   additional_data, is defined as follows:\r\n\r\n      additional_data = seq_num + TLSCompressed.type +\r\n                        TLSCompressed.version + TLSCompressed.length;\r\n\r\n   where \"+\" denotes concatenation.\r\n\r\n   The aead_output consists of the ciphertext output by the AEAD\r\n   encryption operation.  The length will generally be larger than\r\n   TLSCompressed.length, but by an amount that varies with the AEAD\r\n   cipher.  Each AEAD cipher MUST NOT produce an expansion of greater\r\n   than 1024 bytes.  Symbolically,",
    "notes": "I suggest leaving the sentence about padding out. The value for TLSCompressed.length is required by additional_data for both encryption and decryption. Therefore, it must be possible to determine the TLSCompressed.length from the ciphertext before decryption.\r\n\r\nIn practice this is done by subtracting the integrity check value length from the ciphertext length, where the integrity check value length is defined by each AEAD cipher separately. If the cipher incorporates variable padding, it is impossible to calculate the TLSCompressed.length without an explicit value sent for each ciphertext separately. Therefore to avoid confusion, it would be better not to mention anything about padding at all.\r\n\r\n(issue discussed on tls@ietf.org and with Eric Rescorla, result of both discussions was that padding in AEAD ciphers doesn't seem to be possible with the current specification)",
    "submit_date": "2010-07-23",
    "submitter_name": "Juho Vähä-Herttua",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2643,
    "doc-id": "RFC5246",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "E.3",
    "orig_text": "When a TLS-capable server negotiates SSL 2.0 it SHOULD, after\r\ndecrypting the ENCRYPTED-KEY-DATA field, check that these 8 padding\r\nbytes are 0x03.  If they are not, the server SHOULD generate a random\r\nvalue for SECRET-KEY-DATA, and continue the handshake (which will\r\neventually fail since the keys will not match).",
    "correct_text": "When a TLS-capable server negotiates SSL 2.0 it SHOULD, after\r\ndecrypting the ENCRYPTED-KEY-DATA field, check that these 8 padding\r\nbytes are not all 0x03.  If they are, the server SHOULD generate a random\r\nvalue for SECRET-KEY-DATA, and continue the handshake (which will\r\neventually fail since the keys will not match).",
    "notes": "The condition is the wrong way around.  When the bytes *are* all 0x03, that means the client supports TLS, so there must have been a version rollback attack in order for SSL 2.0 to be negotiated.  For example, see the NSS implementation (line number may rot):\r\n\r\nhttps://mxr.mozilla.org/mozilla/source/security/nss/lib/ssl/sslcon.c#1695",
    "submit_date": "2010-11-22",
    "submitter_name": "Matt McCutchen",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2864,
    "doc-id": "RFC5246",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "A.4.2",
    "orig_text": "struct {\r\n    ClientCertificateType certificate_types<1..2^8-1>;\r\n    DistinguishedName certificate_authorities<0..2^16-1>;\r\n} CertificateRequest;\r\n\r\n--- Fixed by errata 1585 to\r\n\r\nstruct {\r\n    ClientCertificateType certificate_types<1..2^8-1>;\r\n    SignatureAndHashAlgorithm\r\n      supported_signature_algorithms<2^16-1>;\r\n    DistinguishedName certificate_authorities<0..2^16-1>;\r\n} CertificateRequest;",
    "correct_text": "struct {\r\n    ClientCertificateType certificate_types<1..2^8-1>;\r\n    SignatureAndHashAlgorithm\r\n      supported_signature_algorithms<2..2^16-2>;\r\n    DistinguishedName certificate_authorities<0..2^16-1>;\r\n} CertificateRequest;",
    "notes": "The supported_signature_algorithms field is a variable length array. As such ceiling and floor should be specified, and they should be multiple of the base type (which is two bytes long in this case).",
    "submit_date": "2011-07-19",
    "submitter_name": "Alfredo Pironti",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 2865,
    "doc-id": "RFC5246",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "7.4.4",
    "orig_text": "struct {\r\n    ClientCertificateType certificate_types<1..2^8-1>;\r\n    SignatureAndHashAlgorithm\r\n      supported_signature_algorithms<2^16-1>;\r\n    DistinguishedName certificate_authorities<0..2^16-1>;\r\n} CertificateRequest;",
    "correct_text": "struct {\r\n    ClientCertificateType certificate_types<1..2^8-1>;\r\n    SignatureAndHashAlgorithm\r\n      supported_signature_algorithms<2..2^16-2>;\r\n    DistinguishedName certificate_authorities<0..2^16-1>;\r\n} CertificateRequest;",
    "notes": "The supported_signature_algorithms field is a variable length array. As such ceiling and floor should be specified, and they should be multiple of the base type (which is two bytes long in this case). See section 7.4.1.4.1 for a valid definition of this field.",
    "submit_date": "2011-07-19",
    "submitter_name": "Alfredo Pironti",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3122,
    "doc-id": "RFC5246",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "A.4.",
    "orig_text": "   enum {\r\n       hello_request(0), client_hello(1), server_hello(2),\r\n       certificate(11), server_key_exchange (12),\r\n       certificate_request(13), server_hello_done(14),\r\n       certificate_verify(15), client_key_exchange(16),\r\n       finished(20)\r\n       (255)\r\n   } HandshakeType;\r\n",
    "correct_text": "   enum {\r\n       hello_request(0), client_hello(1), server_hello(2),\r\n       certificate(11), server_key_exchange (12),\r\n       certificate_request(13), server_hello_done(14),\r\n       certificate_verify(15), client_key_exchange(16),\r\n       finished(20),\r\n       (255)\r\n   } HandshakeType;\r\n",
    "notes": "The comma after finished(20) is missing in the original text.",
    "submit_date": "2012-02-16",
    "submitter_name": "Daniel Otte",
    "verifier_id": 2,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3123,
    "doc-id": "RFC5246",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "A.4.2.",
    "orig_text": "   struct {\r\n       select (KeyExchangeAlgorithm) {\r\n           case dh_anon:\r\n               ServerDHParams params;\r\n           case dhe_dss:\r\n           case dhe_rsa:\r\n               ServerDHParams params;\r\n               digitally-signed struct {\r\n                   opaque client_random[32];\r\n                   opaque server_random[32];\r\n                   ServerDHParams params;\r\n               } signed_params;\r\n           case rsa:\r\n           case dh_dss:\r\n           case dh_rsa:\r\n               struct {} ;\r\n              /* message is omitted for rsa, dh_dss, and dh_rsa */\r\n           /* may be extended, e.g., for ECDH -- see [TLSECC] */\r\n   } ServerKeyExchange;\r\n",
    "correct_text": "   struct {\r\n       select (KeyExchangeAlgorithm) {\r\n           case dh_anon:\r\n               ServerDHParams params;\r\n           case dhe_dss:\r\n           case dhe_rsa:\r\n               ServerDHParams params;\r\n               digitally-signed struct {\r\n                   opaque client_random[32];\r\n                   opaque server_random[32];\r\n                   ServerDHParams params;\r\n               } signed_params;\r\n           case rsa:\r\n           case dh_dss:\r\n           case dh_rsa:\r\n               struct {} ;\r\n              /* message is omitted for rsa, dh_dss, and dh_rsa */\r\n           /* may be extended, e.g., for ECDH -- see [TLSECC] */\r\n       };\r\n   } ServerKeyExchange;\r\n",
    "notes": "The '};' which belongs to 'select (KeyExchangeAlgorithm) {' is missing in the original text.",
    "submit_date": "2012-02-16",
    "submitter_name": "Daniel Otte",
    "verifier_id": 2,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 3191,
    "doc-id": "RFC5246",
    "errata_status_code": "Rejected",
    "errata_type_code": "Editorial",
    "section": "Meta-Data",
    "orig_text": "Obsoletes: 3268, 4346, 4366\r\nUpdates: 4492",
    "correct_text": "Updates: 4492",
    "notes": "\"Obsoletes: 4366\" is factually incorrect, because it is impossible to implement TLSv1.1 (rfc4346) or TLSv1.0(rfc2246) from the TLSv1.2 spec alone. (IPv6 does not obsolete IPv4 and HTTP/1.1 does not obsolete HTTP/1.0 either).\r\n\r\n\"Obsoletes: 4366\" is factually incorrect, because some of the TLS extensions defined in rfc4366 do NOT appear in rfc5246 (and were updated by rfc6066).  On top of that, in order to implement TLS extensions for TLSv1.0 or TLSv1.1, rfc4366 is indispensible, because it describes the necessary changes to the TLSv1.0 & TLSv1.1 PDUs, information that would be cumbersome to extract from rfc5246 compared to simply using rfc4366.\r\n\r\n\"Obsoletes: 3268\" is factually incorrect, because 3268 is the document needed to implement the AES ciphersuites in implementations of TLS _prior_ to TLSv1.2,\r\nsuch as TLSv1.0(rfc2246) and TLSv1.1(rfc4346), i.e. to add support for AES ciphersuites to an existing implementation of TLSv1.0, one would use TLSv1.0(rfc2246) plus rfc3268, rather than TLSv1.0 plus some undefined fragments of rfc5246.\n --VERIFIER NOTES-- \nIf you're looking to implement TLS 1.1 or TLS 1.0 you should be looking in those earlier specifications not RFC 5246.\r\n\r\nOne RFC can be obsoleted by more than RFC.",
    "submit_date": "2012-04-12",
    "submitter_name": "Martin Rex",
    "verifier_id": 124,
    "verifier_name": "Sean Turner",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4007,
    "doc-id": "RFC5246",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Technical",
    "section": "7.3.",
    "orig_text": "Note: To help avoid pipeline stalls, ChangeCipherSpec is an\r\n   independent TLS protocol content type, and is not actually a TLS\r\n   handshake message.\r\n",
    "correct_text": "Note: To avoid ChangeCipherSpec being transmitted in mix with\r\n   other handshake fragments in one record, ChangeCipherSpec is\r\n   an independent TLS protocol content type, and is not actually\r\n   a TLS handshake message.  To help avoid pipeline stalls, \r\n   ChangeCipherSpec is sent from both the server and the client.\r\n",
    "notes": "The original text can be read like we can handle ChangeCipherSpec asynchronously.\r\nThis is harmful and may  be a cause of CCS Injection vulnerability.",
    "submit_date": "2014-06-06",
    "submitter_name": "KIKUCHI Masashi",
    "verifier_id": 128,
    "verifier_name": "Stephen Farrell",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4109,
    "doc-id": "RFC5246",
    "errata_status_code": "Verified",
    "errata_type_code": "Technical",
    "section": "A.4.2",
    "orig_text": "   opaque ASN.1Cert<2^24-1>;\r\n",
    "correct_text": "   opaque ASN.1Cert<1..2^24-1>;",
    "notes": "The appendix definition of ASN.1Cert leaves out the floor of the variable-length vector, which must be specified according to the vector syntax specification in section 4.3. Fortunately, the original definition of ASN.1Cert in section 7.4.2 does specify the floor as 1, so the definition in A.4.2 should be updated to match.",
    "submit_date": "2014-09-11",
    "submitter_name": "Christopher Armstrong",
    "verifier_id": 128,
    "verifier_name": "Stephen Farrell",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4382,
    "doc-id": "RFC5246",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 4.3,
    "orig_text": "In the following example, Datum is defined to be three consecutive\r\n   bytes that the protocol does not interpret, while Data is three\r\n   consecutive Datum, consuming a total of nine bytes.\r\n\r\n      opaque Datum[3];      /* three uninterpreted bytes */\r\n      Datum Data[9];        /* 3 consecutive 3 byte vectors */\r\n",
    "correct_text": "In the following example, Datum is defined to be three consecutive\r\n   bytes that the protocol does not interpret, while Data is three\r\n   consecutive Datum, consuming a total of nine bytes.\r\n\r\n      opaque Datum[3];      /* three uninterpreted bytes */\r\n      Datum Data[3];        /* 3 consecutive 3 byte vectors */\r\n",
    "notes": "The 9 in \"Datum Data[9]\" should be a 3 because Datum is a data type that consumes 3 bytes, so as written the Data vector is 27 bytes long. To make it a 9 byte vector the 9 must change to a 3.\n --VERIFIER NOTES-- \n   This is not correct. The value here is the number of bytes, not the count of items.",
    "submit_date": "2015-05-29",
    "submitter_name": "Laura Corcoran",
    "verifier_id": 156,
    "verifier_name": "EKR",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4507,
    "doc-id": "RFC5246",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "7.4.1.2",
    "orig_text": "After sending the ClientHello message, the client waits for a\r\nServerHello message.  Any handshake message returned by the server,\r\nexcept for a HelloRequest, is treated as a fatal error.\r\n",
    "correct_text": "After sending the ClientHello message, the client waits for a\r\nServerHello message.  Any other handshake message returned by the\r\nserver, except for a HelloRequest, is treated as a fatal error.",
    "notes": "A ServerHello received after a ClientHello should not be treated as a fatal error.",
    "submit_date": "2015-10-19",
    "submitter_name": "Benjamin Kaduk",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4750,
    "doc-id": "RFC5246",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "4.3 Vectors",
    "orig_text": "The length of\r\n   an encoded vector must be an even multiple of the length of a single\r\n   element (for example, a 17-byte vector of uint16 would be illegal).",
    "correct_text": "The length of\r\n   an encoded vector must be a whole multiple of the length of a single\r\n   element (for example, a 17-byte vector of uint16 would be illegal).",
    "notes": "Original text implies vectors can only contain even (0,2,4,6,8...) numbers of elements.  The example does not resolve this but indicates the intent is that parts of elements are not allowed. It is clear from other examples that odd numbers of elements are permitted.",
    "submit_date": "2016-07-27",
    "submitter_name": "Adrien de Croy",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4885,
    "doc-id": "RFC5246",
    "errata_status_code": "Held for Document Update",
    "errata_type_code": "Editorial",
    "section": "6.1.",
    "orig_text": "   server random\r\n      A 32-byte value provided by the server.\r\n\r\n      These parameters are defined in the presentation language as:\r\n\r\n      enum { server, client } ConnectionEnd;",
    "correct_text": "   server random\r\n      A 32-byte value provided by the server.\r\n\r\n   These parameters are defined in the presentation language as:\r\n\r\n      enum { server, client } ConnectionEnd;",
    "notes": "The line \"These parameters are ...\" after the list of parameters is at the same indentation level as the list of parameters, instead of coming back left by one level.",
    "submit_date": "2016-12-13",
    "submitter_name": "Wail Yahyaoui",
    "verifier_id": 128,
    "verifier_name": "Stephen Farrell",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 4912,
    "doc-id": "RFC5246",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "A.4.1",
    "orig_text": "   SignatureAndHashAlgorithm\r\n    supported_signature_algorithms<2..2^16-1>;\r\n",
    "correct_text": "   SignatureAndHashAlgorithm\r\n    supported_signature_algorithms<2..2^16-2>;\r\n",
    "notes": "Error in last sentence. See errata ID 2865.",
    "submit_date": "2017-01-18",
    "submitter_name": "Nikolai Malykh",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5036,
    "doc-id": "RFC5246",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": "7.4.1.2",
    "orig_text": "The ClientHello Structure indicates that a SessionID could be present.\r\nHowever if I take a wireshark of a TLS session I always see a \"Session \r\nID Length\" field, either with value 0 or value 32",
    "correct_text": "In the ClientHello structure and ServerHello structure, include \r\na 1 byte \"Session ID Length\" field.",
    "notes": "The ClientHello Structure indicates that a SessionID could be present.\r\nHowever if I take a wireshark of a TLS session I always see a \r\n\"Session ID Length\" field, either with value 0 or value 32.",
    "submit_date": "2017-06-09",
    "submitter_name": "Stefan Goeman",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5352,
    "doc-id": "RFC5246",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "6.2.3.3.",
    "orig_text": "struct {\r\n    opaque nonce_explicit[SecurityParameters.record_iv_length];\r\n    aead-ciphered struct {\r\n        opaque content[TLSCompressed.length];\r\n    };\r\n} GenericAEADCipher;",
    "correct_text": "struct {\r\n    opaque nonce_explicit[SecurityParameters.record_iv_length];\r\n    aead-ciphered struct {\r\n        opaque content[TLSCiphertext.length];\r\n    };\r\n} GenericAEADCipher;",
    "notes": "6.2.3.3. says: \"The aead_output consists of the ciphertext output by the AEAD encryption operation. The length will generally be larger than TLSCompressed.length, [...]\".\r\n\r\nThe definition is duplicated at A.1., and needs the same adjustment.\n --VERIFIER NOTES-- \naead-ciphered is an operator that takes content as the input.",
    "submit_date": "2018-05-09",
    "submitter_name": "Loic Etienne",
    "verifier_id": 156,
    "verifier_name": "Eric Rescorla",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5409,
    "doc-id": "RFC5246",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": "Appendix A.5",
    "orig_text": "   Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are\r\n   reserved to avoid collision with Fortezza-based cipher suites in\r\n   SSL 3.",
    "correct_text": "   Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are\r\n   reserved to avoid collision with Fortezza-based cipher suites in\r\n   SSL 3. The cipher suite value { 0x00, 0x1E } firstly also assigned to\r\n   Fortezza has been released and has since been be reassigned. ",
    "notes": "RFC 2712 (Addition of Kerberos Cipher Suites to Transport Layer Security) in its Draft 01 version introduces three new cipher suites colliding with the three Fortezza ones. The Draft 02 version partially corrects that, by moving the Kerberos cipher suites values by two.\r\nThis omission of the third cipher suite has never been corrected, and this remains in the same state in the final RFC 2712, RFC 2246 and its successors including this one.\r\n\r\nChanging the first Kerberos cipher suite value, or moving all of them, would now not make any sense. Enhancing the note as suggested is probably enough to mention how one Fortezza cipher suite disappeared.\n --VERIFIER NOTES-- \n   RFC 5246 is not the appropriate location to document this conflict.",
    "submit_date": "2018-06-26",
    "submitter_name": "Eugene Adell",
    "verifier_id": 159,
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 5535,
    "doc-id": "RFC5246",
    "errata_status_code": "Rejected",
    "errata_type_code": "Technical",
    "section": 4.7,
    "orig_text": "   In DSA, the 20 bytes of the SHA-1 hash are run directly through the\r\n   Digital Signing Algorithm with no additional hashing. ...",
    "correct_text": "   In DSA, the bytes of the selected hash are run directly through the\r\n   Digital Signing Algorithm with no additional hashing. ...",
    "notes": "In 2246 and 4346 this statement (then using the less-accurate spellings DSS and SHA) was correct because only SHA1 was used for DSA (and ECDSA, in 4492, versus SHA1+MD5 for RSA), but 5246 changed this to allow specifying one of several hashes, with selection constrained by the signature_algorithms extension (if present) or CertificateRequest field from the peer.\r\n\r\nFIPS 186 actually defines the hashing step as part of signature generation and verification, so it might be even better to make this something like \"For DSA, signature generation applies the selected hash [to the contents] and then computes two values, r and s.\" similar to the way the preceding paragraph of 5246 \"In RSA signing\" differs from the 2246 and 4346 versions by no longer treating the hashing as separate, but that is a bigger change to an obsoleted document, and arguably problematic because the normative reference is FIPS 186-2; as indicated in Appendix B on page 80, 186-3 which officially allowed DSA to use FIPS 180-3 hashes (not only SHA-1) was released in draft before 5246 but not finalized until after (2006-03 to 2009-06 versus 2008-08).\n --VERIFIER NOTES-- \n As described in the reported Notes, at the time of publication, the DSA specification in force only allowed for the usage of SHA-1.  So the document was correct at time of publication and an errata is not appropriate, even though subsequent events have allowed for the usage of a broader set of hash algorithms with DSA.",
    "submit_date": "2018-10-19",
    "submitter_name": "Dave Thompson",
    "verifier_id": 159,
    "verifier_name": "Benjamin Kaduk",
    "update_date": "2019-09-10 09:09:03"
  },
  {
    "errata_id": 6244,
    "doc-id": "RFC5246",
    "errata_status_code": "Reported",
    "errata_type_code": "Editorial",
    "section": "6.2.3.2",
    "orig_text": "IV\r\nThe Initialization Vector (IV) SHOULD be chosen at random, and\r\nMUST be unpredictable. Note that in versions of TLS prior to 1.1,\r\nthere was no IV field, and the last ciphertext block of the\r\nprevious record (the \"CBC residue\") was used as the IV. This was\r\nchanged to prevent the attacks described in [CBCATT]. For block\r\nciphers, the IV length is of length\r\nSecurityParameters.record_iv_length, which is equal to the\r\nSecurityParameters.block_size.",
    "correct_text": "IV\r\nThe Initialization Vector (IV) SHOULD be chosen at random, and\r\nMUST be unpredictable. Note that in versions of TLS prior to 1.1,\r\nthere was no IV field, and the last ciphertext block of the\r\nprevious record (the \"CBC residue\") was used as the IV. This was\r\nchanged to prevent the attacks described in [CBCATT]. For block\r\nciphers, the IV length is of length\r\nSecurityParameters.record_iv_length, which is equal to the\r\nSecurityParameters.block_length.",
    "notes": "This is an error here. The structure SecurityParameters hasn't the element block_size.\r\nIt has the element block_length.\r\nSee in section 6.1:\r\nstruct {\r\nConnectionEnd entity;\r\nPRFAlgorithm prf_algorithm;\r\nBulkCipherAlgorithm bulk_cipher_algorithm;\r\nCipherType cipher_type;\r\nuint8 enc_key_length;\r\nuint8 block_length;\r\nuint8 fixed_iv_length;\r\nuint8 record_iv_length;\r\nMACAlgorithm mac_algorithm;\r\nuint8 mac_length;\r\nuint8 mac_key_length;\r\nCompressionMethod compression_algorithm;\r\nopaque master_secret[48];\r\nopaque client_random[32];\r\nopaque server_random[32];\r\n} SecurityParameters;",
    "submit_date": "2020-07-29",
    "submitter_name": "Victor S. Osipov",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  },
  {
    "errata_id": 6572,
    "doc-id": "RFC5246",
    "errata_status_code": "Reported",
    "errata_type_code": "Technical",
    "section": 9,
    "orig_text": "In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the cipher suite TLS_RSA_WITH_AES_128_CBC_SHA (see Appendix A.5 for the definition).",
    "correct_text": "In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the cipher suite TLS_RSA_WITH_AES_128_GCM_SHA256 (see Appendix A.5 for the definition).",
    "notes": "A must-be-implement cipher suite should not relay on a bulk encryption algorithm which is vulnerable to plain-text attacks or on a secure hash algorithm which has been proven to be insecure.",
    "submit_date": "2021-05-05",
    "submitter_name": "Johannes Görlich",
    "verifier_id": 99,
    "verifier_name": null,
    "update_date": null
  }
]
